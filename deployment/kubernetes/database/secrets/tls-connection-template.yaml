# =============================================================================
# Database TLS Connection Templates
# SEC-004: TLS 1.3 Configuration for All Services
# =============================================================================
#
# This file provides ExternalSecret templates for database connections
# with TLS parameters. These templates show how to configure PostgreSQL
# and Redis connections with proper SSL settings.
#
# Prerequisites:
# - External Secrets Operator installed
# - AWS Secrets Manager configured
# - ClusterSecretStore "aws-secrets-manager" configured
#
# Usage:
# - Copy the relevant template to your namespace
# - Update the remoteRef keys to match your secrets
# - Apply with: kubectl apply -f tls-connection-template.yaml
# =============================================================================

---
# PostgreSQL Connection with SSL (verify-full mode)
#
# This template creates a Kubernetes Secret containing PostgreSQL connection
# parameters with TLS enabled. The connection uses verify-full mode to ensure
# certificate chain and hostname verification.
#
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: postgres-tls-connection
  namespace: greenlang
  labels:
    app.kubernetes.io/name: postgres-tls-connection
    app.kubernetes.io/component: database-secrets
    app.kubernetes.io/part-of: greenlang
    greenlang.io/component: sec-004
    greenlang.io/security-level: critical
  annotations:
    greenlang.io/description: "PostgreSQL connection with TLS verification"
    greenlang.io/tls-mode: "verify-full"
spec:
  # Refresh from AWS Secrets Manager every hour
  refreshInterval: 1h

  # Reference to the ClusterSecretStore
  secretStoreRef:
    name: aws-secrets-manager
    kind: ClusterSecretStore

  # Target Kubernetes Secret configuration
  target:
    name: postgres-connection
    creationPolicy: Owner
    deletionPolicy: Retain
    template:
      type: Opaque
      metadata:
        labels:
          app.kubernetes.io/name: postgres-connection
          app.kubernetes.io/component: database-secrets
          app.kubernetes.io/part-of: greenlang
          greenlang.io/tls-enabled: "true"
        annotations:
          greenlang.io/synced-at: "{{ .syncedAt }}"
      data:
        # Full connection string with SSL parameters
        # Format: postgresql://user:pass@host:port/db?sslmode=verify-full&sslrootcert=/path/to/ca.pem
        DATABASE_URL: "postgresql://{{ .username }}:{{ .password }}@{{ .host }}:{{ .port }}/{{ .database }}?sslmode=verify-full&sslrootcert=/etc/ssl/certs/rds-combined-ca-bundle.pem"

        # Individual parameters for applications that need them separately
        POSTGRES_HOST: "{{ .host }}"
        POSTGRES_PORT: "{{ .port }}"
        POSTGRES_DB: "{{ .database }}"
        POSTGRES_USER: "{{ .username }}"
        POSTGRES_PASSWORD: "{{ .password }}"

        # SSL parameters
        POSTGRES_SSLMODE: "verify-full"
        POSTGRES_SSLROOTCERT: "/etc/ssl/certs/rds-combined-ca-bundle.pem"

        # psycopg format (for Python applications)
        PSYCOPG_CONNINFO: "host={{ .host }} port={{ .port }} dbname={{ .database }} user={{ .username }} password={{ .password }} sslmode=verify-full sslrootcert=/etc/ssl/certs/rds-combined-ca-bundle.pem"

        # SQLAlchemy async URL (for async applications)
        SQLALCHEMY_DATABASE_URI: "postgresql+asyncpg://{{ .username }}:{{ .password }}@{{ .host }}:{{ .port }}/{{ .database }}?ssl=require"

  # Data mapping from AWS Secrets Manager
  data:
    - secretKey: host
      remoteRef:
        key: greenlang/prod/postgres
        property: host

    - secretKey: port
      remoteRef:
        key: greenlang/prod/postgres
        property: port

    - secretKey: database
      remoteRef:
        key: greenlang/prod/postgres
        property: database

    - secretKey: username
      remoteRef:
        key: greenlang/prod/postgres
        property: username

    - secretKey: password
      remoteRef:
        key: greenlang/prod/postgres
        property: password

    - secretKey: syncedAt
      remoteRef:
        key: greenlang/prod/postgres
        metadataPolicy: Fetch
        property: createdDate

---
# Redis Connection with TLS
#
# This template creates a Kubernetes Secret containing Redis connection
# parameters with TLS enabled. The connection uses the rediss:// scheme
# for TLS connections to ElastiCache.
#
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: redis-tls-connection
  namespace: greenlang
  labels:
    app.kubernetes.io/name: redis-tls-connection
    app.kubernetes.io/component: database-secrets
    app.kubernetes.io/part-of: greenlang
    greenlang.io/component: sec-004
    greenlang.io/security-level: critical
  annotations:
    greenlang.io/description: "Redis/ElastiCache connection with TLS"
    greenlang.io/tls-mode: "required"
spec:
  refreshInterval: 1h

  secretStoreRef:
    name: aws-secrets-manager
    kind: ClusterSecretStore

  target:
    name: redis-connection
    creationPolicy: Owner
    deletionPolicy: Retain
    template:
      type: Opaque
      metadata:
        labels:
          app.kubernetes.io/name: redis-connection
          app.kubernetes.io/component: database-secrets
          app.kubernetes.io/part-of: greenlang
          greenlang.io/tls-enabled: "true"
        annotations:
          greenlang.io/synced-at: "{{ .syncedAt }}"
      data:
        # Redis URL with TLS (rediss:// scheme)
        REDIS_URL: "rediss://:{{ .password }}@{{ .host }}:{{ .port }}/0"

        # Individual parameters
        REDIS_HOST: "{{ .host }}"
        REDIS_PORT: "{{ .port }}"
        REDIS_PASSWORD: "{{ .password }}"

        # SSL parameters for redis-py
        REDIS_SSL: "true"
        REDIS_SSL_CERT_REQS: "required"
        REDIS_SSL_CA_CERTS: "/etc/ssl/certs/AmazonRootCA1.pem"
        REDIS_SSL_CHECK_HOSTNAME: "true"

        # Celery broker URL
        CELERY_BROKER_URL: "rediss://:{{ .password }}@{{ .host }}:{{ .port }}/1?ssl_cert_reqs=required"

        # Celery result backend URL
        CELERY_RESULT_BACKEND: "rediss://:{{ .password }}@{{ .host }}:{{ .port }}/2?ssl_cert_reqs=required"

  data:
    - secretKey: host
      remoteRef:
        key: greenlang/prod/redis
        property: host

    - secretKey: port
      remoteRef:
        key: greenlang/prod/redis
        property: port

    - secretKey: password
      remoteRef:
        key: greenlang/prod/redis
        property: auth_token

    - secretKey: syncedAt
      remoteRef:
        key: greenlang/prod/redis
        metadataPolicy: Fetch
        property: createdDate

---
# ConfigMap for TLS CA Certificates
#
# This ConfigMap contains paths to CA certificate bundles that pods
# should mount for TLS verification. The actual certificates should
# be mounted from a separate volume or init container.
#
apiVersion: v1
kind: ConfigMap
metadata:
  name: tls-ca-bundle-config
  namespace: greenlang
  labels:
    app.kubernetes.io/name: tls-ca-bundle-config
    app.kubernetes.io/component: tls-config
    app.kubernetes.io/part-of: greenlang
    greenlang.io/component: sec-004
data:
  # AWS RDS CA bundle path
  RDS_CA_BUNDLE_PATH: "/etc/ssl/certs/rds-combined-ca-bundle.pem"

  # AWS ElastiCache CA path
  ELASTICACHE_CA_PATH: "/etc/ssl/certs/AmazonRootCA1.pem"

  # System CA bundle path
  SYSTEM_CA_BUNDLE: "/etc/ssl/certs/ca-certificates.crt"

  # TLS configuration
  TLS_MIN_VERSION: "TLSv1.2"
  TLS_VERIFY: "true"

  # Cipher suites (TLS 1.2)
  TLS_CIPHERS: "ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256"

---
# Example Deployment showing how to use TLS secrets
#
# This deployment example demonstrates:
# - Mounting TLS secrets as environment variables
# - Mounting CA certificates as volumes
# - Configuring the application for TLS
#
# apiVersion: apps/v1
# kind: Deployment
# metadata:
#   name: example-app
#   namespace: greenlang
# spec:
#   template:
#     spec:
#       containers:
#         - name: app
#           envFrom:
#             - secretRef:
#                 name: postgres-connection
#             - secretRef:
#                 name: redis-connection
#             - configMapRef:
#                 name: tls-ca-bundle-config
#           volumeMounts:
#             - name: ca-certs
#               mountPath: /etc/ssl/certs
#               readOnly: true
#       volumes:
#         - name: ca-certs
#           configMap:
#             name: aws-ca-certificates
#
---
# CA Certificates ConfigMap
#
# This ConfigMap contains the actual CA certificate content.
# In production, this should be populated by an init container
# or external process that fetches fresh certificates.
#
apiVersion: v1
kind: ConfigMap
metadata:
  name: aws-ca-certificates-info
  namespace: greenlang
  labels:
    app.kubernetes.io/name: aws-ca-certificates-info
    app.kubernetes.io/component: tls-certificates
    app.kubernetes.io/part-of: greenlang
    greenlang.io/component: sec-004
  annotations:
    greenlang.io/certificate-source: "AWS Trust Services"
    greenlang.io/auto-update: "true"
data:
  # Information about certificate sources
  rds-ca-bundle.info: |
    Source: https://truststore.pki.rds.amazonaws.com/global/global-bundle.pem
    Description: AWS RDS Combined CA Bundle for all regions
    Last Updated: See annotation
    Usage: PostgreSQL SSL verification (verify-full mode)

  amazon-root-ca.info: |
    Source: https://www.amazontrust.com/repository/AmazonRootCA1.pem
    Description: Amazon Root CA 1 certificate
    Last Updated: See annotation
    Usage: ElastiCache SSL verification

---
# NetworkPolicy allowing database connections over TLS
#
# This NetworkPolicy allows egress to database endpoints on TLS ports.
#
apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: allow-database-tls-egress
  namespace: greenlang
  labels:
    app.kubernetes.io/name: allow-database-tls-egress
    app.kubernetes.io/component: network-policy
    app.kubernetes.io/part-of: greenlang
    greenlang.io/component: sec-004
spec:
  podSelector:
    matchLabels:
      greenlang.io/database-access: "true"
  policyTypes:
    - Egress
  egress:
    # PostgreSQL (Aurora) - TLS on port 5432
    - to:
        - ipBlock:
            cidr: 10.0.0.0/8  # VPC CIDR - adjust for your environment
      ports:
        - protocol: TCP
          port: 5432

    # Redis (ElastiCache) - TLS on port 6379
    - to:
        - ipBlock:
            cidr: 10.0.0.0/8  # VPC CIDR - adjust for your environment
      ports:
        - protocol: TCP
          port: 6379

    # DNS resolution
    - to:
        - namespaceSelector: {}
          podSelector:
            matchLabels:
              k8s-app: kube-dns
      ports:
        - protocol: UDP
          port: 53
        - protocol: TCP
          port: 53
