"""
GL-014 ExchangerPro - OpenTelemetry Tracing
===========================================================

Provides distributed tracing for the agent using OpenTelemetry.

Features:
- Automatic span creation for functions
- Trace context propagation
- Provenance hash recording
- Performance metrics

Generated by GreenLang Enhancement Script
"""

import functools
import hashlib
import json
import logging
import time
from contextlib import contextmanager
from dataclasses import dataclass
from datetime import datetime, timezone
from typing import Any, Callable, Dict, Optional, TypeVar

logger = logging.getLogger(__name__)

# Agent configuration
AGENT_ID = "GL-014"
AGENT_NAME = "ExchangerPro"

# Try to import OpenTelemetry
try:
    from opentelemetry import trace
    from opentelemetry.trace import Span, StatusCode
    from opentelemetry.sdk.trace import TracerProvider
    from opentelemetry.sdk.resources import Resource
    OTEL_AVAILABLE = True
except ImportError:
    OTEL_AVAILABLE = False
    logger.warning("OpenTelemetry not installed. Using fallback tracing.")


@dataclass
class SpanRecord:
    """Record of a traced span for fallback mode."""
    trace_id: str
    span_id: str
    operation_name: str
    start_time: datetime
    end_time: Optional[datetime] = None
    duration_ms: float = 0.0
    status: str = "OK"
    attributes: Dict[str, Any] = None

    def __post_init__(self):
        if self.attributes is None:
            self.attributes = {}


class TracingManager:
    """
    Manages distributed tracing for GL-014.

    Provides OpenTelemetry integration with fallback for
    environments without OTEL.
    """

    def __init__(
        self,
        service_name: str = AGENT_ID,
        service_version: str = "1.0.0",
    ):
        self.service_name = service_name
        self.service_version = service_version
        self.spans: list[SpanRecord] = []

        if OTEL_AVAILABLE:
            self._setup_otel()
        else:
            self.tracer = None
            logger.info("Using fallback tracing (no OpenTelemetry)")

    def _setup_otel(self):
        """Setup OpenTelemetry tracer."""
        resource = Resource.create({
            "service.name": self.service_name,
            "service.version": self.service_version,
            "greenlang.agent_id": AGENT_ID,
        })

        provider = TracerProvider(resource=resource)
        trace.set_tracer_provider(provider)
        self.tracer = trace.get_tracer(self.service_name)

        logger.info(f"Initialized OpenTelemetry tracing for {AGENT_ID}")

    @contextmanager
    def span(
        self,
        name: str,
        attributes: Optional[Dict[str, Any]] = None,
    ):
        """
        Create a traced span context.

        Args:
            name: Operation name
            attributes: Span attributes

        Yields:
            Span object (OTEL or fallback)
        """
        start_time = datetime.now(timezone.utc)
        attrs = attributes or {}
        attrs["agent_id"] = AGENT_ID

        if OTEL_AVAILABLE and self.tracer:
            with self.tracer.start_as_current_span(name) as span:
                for key, value in attrs.items():
                    span.set_attribute(key, str(value))
                try:
                    yield span
                    span.set_status(StatusCode.OK)
                except Exception as e:
                    span.set_status(StatusCode.ERROR, str(e))
                    span.record_exception(e)
                    raise
        else:
            # Fallback tracing
            import uuid
            record = SpanRecord(
                trace_id=str(uuid.uuid4()),
                span_id=str(uuid.uuid4())[:16],
                operation_name=name,
                start_time=start_time,
                attributes=attrs,
            )
            try:
                yield record
                record.status = "OK"
            except Exception as e:
                record.status = f"ERROR: {e}"
                raise
            finally:
                record.end_time = datetime.now(timezone.utc)
                record.duration_ms = (
                    record.end_time - record.start_time
                ).total_seconds() * 1000
                self.spans.append(record)

    def get_recent_spans(self, limit: int = 100) -> list[SpanRecord]:
        """Get recent span records (fallback mode only)."""
        return self.spans[-limit:]


# Global tracer instance
_tracer: Optional[TracingManager] = None


def get_tracer() -> TracingManager:
    """Get or create the global tracer instance."""
    global _tracer
    if _tracer is None:
        _tracer = TracingManager()
    return _tracer


T = TypeVar('T')


def traced(name: Optional[str] = None) -> Callable:
    """
    Decorator for automatic function tracing.

    Example:
        @traced()
        def calculate_efficiency(data):
            return {"efficiency": 0.85}
    """
    def decorator(func: Callable[..., T]) -> Callable[..., T]:
        span_name = name or func.__name__

        @functools.wraps(func)
        def wrapper(*args, **kwargs) -> T:
            tracer = get_tracer()

            # Compute input hash for provenance
            input_data = {"args": str(args), "kwargs": str(kwargs)}
            input_hash = hashlib.sha256(
                json.dumps(input_data, sort_keys=True).encode()
            ).hexdigest()[:16]

            with tracer.span(
                span_name,
                attributes={
                    "function": func.__name__,
                    "input_hash": input_hash,
                }
            ) as span:
                result = func(*args, **kwargs)

                # Record output hash
                if hasattr(span, 'set_attribute'):
                    output_hash = hashlib.sha256(
                        json.dumps(result, sort_keys=True, default=str).encode()
                    ).hexdigest()[:16]
                    span.set_attribute("output_hash", output_hash)

                return result

        return wrapper
    return decorator


__all__ = [
    "TracingManager",
    "SpanRecord",
    "get_tracer",
    "traced",
]
