"""
GL-006 HEATRECLAIM - Circuit Breaker Pattern
=============================================================

Implements circuit breaker pattern for external service calls.

States:
- CLOSED: Normal operation, requests pass through
- OPEN: Circuit tripped, requests fail fast
- HALF_OPEN: Testing if service recovered

Generated by GreenLang Enhancement Script
"""

import logging
import threading
import time
from dataclasses import dataclass, field
from datetime import datetime, timezone
from enum import Enum, auto
from functools import wraps
from typing import Any, Callable, Optional, TypeVar

logger = logging.getLogger(__name__)

# Agent configuration
AGENT_ID = "GL-006"
AGENT_NAME = "HEATRECLAIM"


class CircuitState(Enum):
    """Circuit breaker states."""
    CLOSED = auto()
    OPEN = auto()
    HALF_OPEN = auto()


@dataclass
class CircuitStats:
    """Statistics for circuit breaker."""
    total_calls: int = 0
    successful_calls: int = 0
    failed_calls: int = 0
    rejected_calls: int = 0
    last_failure_time: Optional[datetime] = None
    consecutive_failures: int = 0
    consecutive_successes: int = 0


class CircuitBreakerError(Exception):
    """Raised when circuit breaker is open."""
    pass


class CircuitBreaker:
    """
    Circuit breaker for GL-006.

    Prevents cascading failures by failing fast when a service
    is unresponsive.
    """

    def __init__(
        self,
        name: str,
        failure_threshold: int = 5,
        success_threshold: int = 3,
        timeout_seconds: float = 30.0,
        half_open_max_calls: int = 3,
    ):
        """
        Initialize circuit breaker.

        Args:
            name: Circuit breaker name
            failure_threshold: Failures before opening circuit
            success_threshold: Successes in half-open to close
            timeout_seconds: Time before retrying after opening
            half_open_max_calls: Max calls in half-open state
        """
        self.name = name
        self.failure_threshold = failure_threshold
        self.success_threshold = success_threshold
        self.timeout_seconds = timeout_seconds
        self.half_open_max_calls = half_open_max_calls

        self._state = CircuitState.CLOSED
        self._stats = CircuitStats()
        self._half_open_calls = 0
        self._lock = threading.RLock()

        logger.info(
            f"Initialized circuit breaker '{name}' for {AGENT_ID} "
            f"(threshold={failure_threshold}, timeout={timeout_seconds}s)"
        )

    @property
    def state(self) -> CircuitState:
        """Get current circuit state."""
        with self._lock:
            return self._state

    @property
    def stats(self) -> CircuitStats:
        """Get circuit statistics."""
        with self._lock:
            return self._stats

    def is_call_permitted(self) -> bool:
        """Check if a call is permitted."""
        with self._lock:
            if self._state == CircuitState.CLOSED:
                return True

            if self._state == CircuitState.OPEN:
                # Check if timeout has passed
                if self._stats.last_failure_time:
                    elapsed = (
                        datetime.now(timezone.utc) - self._stats.last_failure_time
                    ).total_seconds()

                    if elapsed >= self.timeout_seconds:
                        self._transition_to_half_open()
                        return True

                return False

            if self._state == CircuitState.HALF_OPEN:
                return self._half_open_calls < self.half_open_max_calls

            return False

    def record_success(self):
        """Record a successful call."""
        with self._lock:
            self._stats.total_calls += 1
            self._stats.successful_calls += 1
            self._stats.consecutive_successes += 1
            self._stats.consecutive_failures = 0

            if self._state == CircuitState.HALF_OPEN:
                if self._stats.consecutive_successes >= self.success_threshold:
                    self._transition_to_closed()

    def record_failure(self, error: Optional[Exception] = None):
        """Record a failed call."""
        with self._lock:
            self._stats.total_calls += 1
            self._stats.failed_calls += 1
            self._stats.consecutive_failures += 1
            self._stats.consecutive_successes = 0
            self._stats.last_failure_time = datetime.now(timezone.utc)

            if self._state == CircuitState.CLOSED:
                if self._stats.consecutive_failures >= self.failure_threshold:
                    self._transition_to_open()

            elif self._state == CircuitState.HALF_OPEN:
                self._transition_to_open()

    def record_rejected(self):
        """Record a rejected call (circuit open)."""
        with self._lock:
            self._stats.total_calls += 1
            self._stats.rejected_calls += 1

    def _transition_to_open(self):
        """Transition to OPEN state."""
        self._state = CircuitState.OPEN
        self._half_open_calls = 0
        logger.warning(
            f"Circuit '{self.name}' OPENED after {self._stats.consecutive_failures} failures"
        )

    def _transition_to_half_open(self):
        """Transition to HALF_OPEN state."""
        self._state = CircuitState.HALF_OPEN
        self._half_open_calls = 0
        self._stats.consecutive_successes = 0
        logger.info(f"Circuit '{self.name}' entering HALF_OPEN state")

    def _transition_to_closed(self):
        """Transition to CLOSED state."""
        self._state = CircuitState.CLOSED
        self._stats.consecutive_failures = 0
        self._half_open_calls = 0
        logger.info(f"Circuit '{self.name}' CLOSED after successful recovery")

    def reset(self):
        """Reset circuit breaker to initial state."""
        with self._lock:
            self._state = CircuitState.CLOSED
            self._stats = CircuitStats()
            self._half_open_calls = 0
            logger.info(f"Circuit '{self.name}' reset")

    def execute(self, func: Callable, *args, **kwargs) -> Any:
        """
        Execute function with circuit breaker protection.

        Args:
            func: Function to execute
            *args: Positional arguments
            **kwargs: Keyword arguments

        Returns:
            Function result

        Raises:
            CircuitBreakerError: If circuit is open
        """
        if not self.is_call_permitted():
            self.record_rejected()
            raise CircuitBreakerError(
                f"Circuit '{self.name}' is {self.state.name} - call rejected"
            )

        if self._state == CircuitState.HALF_OPEN:
            with self._lock:
                self._half_open_calls += 1

        try:
            result = func(*args, **kwargs)
            self.record_success()
            return result
        except Exception as e:
            self.record_failure(e)
            raise


# Registry of circuit breakers
_circuit_breakers: dict[str, CircuitBreaker] = {}


def get_circuit_breaker(
    name: str,
    failure_threshold: int = 5,
    timeout_seconds: float = 30.0,
) -> CircuitBreaker:
    """Get or create a named circuit breaker."""
    if name not in _circuit_breakers:
        _circuit_breakers[name] = CircuitBreaker(
            name=name,
            failure_threshold=failure_threshold,
            timeout_seconds=timeout_seconds,
        )
    return _circuit_breakers[name]


T = TypeVar('T')


def with_circuit_breaker(
    name: str,
    failure_threshold: int = 5,
    timeout_seconds: float = 30.0,
) -> Callable:
    """
    Decorator for circuit breaker protection.

    Example:
        @with_circuit_breaker("external_api")
        def call_external_service():
            return requests.get("http://api.example.com")
    """
    def decorator(func: Callable[..., T]) -> Callable[..., T]:
        circuit = get_circuit_breaker(name, failure_threshold, timeout_seconds)

        @wraps(func)
        def wrapper(*args, **kwargs) -> T:
            return circuit.execute(func, *args, **kwargs)

        return wrapper
    return decorator


__all__ = [
    "CircuitBreaker",
    "CircuitBreakerError",
    "CircuitState",
    "CircuitStats",
    "get_circuit_breaker",
    "with_circuit_breaker",
]
