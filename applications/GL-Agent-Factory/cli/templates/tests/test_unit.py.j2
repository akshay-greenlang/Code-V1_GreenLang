"""
Unit Tests for {{ cookiecutter.agent_name }}

Auto-generated by GreenLang Agent Factory
Tests individual methods and components in isolation.
"""

import pytest
import hashlib
from datetime import datetime

from agent import {{ cookiecutter.agent_class_name }}, {{ cookiecutter.agent_class_name }}Input, {{ cookiecutter.agent_class_name }}Output


class TestAgentInitialization:
    """Tests for agent initialization."""

    def test_default_initialization(self):
        """Test agent initializes with default configuration."""
        agent = {{ cookiecutter.agent_class_name }}()

        assert agent.id == "{{ cookiecutter.agent_id }}"
        assert agent.version == "{{ cookiecutter.version }}"
        assert agent.name == "{{ cookiecutter.agent_name }}"

    def test_custom_config_initialization(self):
        """Test agent initializes with custom configuration."""
        config = {"custom_key": "custom_value"}
        agent = {{ cookiecutter.agent_class_name }}(config=config)

        assert agent.config["custom_key"] == "custom_value"


class TestInputValidation:
    """Tests for input validation."""

    def test_valid_input_passes_validation(self, agent, sample_input):
        """Test that valid input passes validation."""
        result = agent._validate_input(sample_input)

        assert result["is_valid"] is True
        assert len(result["errors"]) == 0

    def test_invalid_input_fails_validation(self, agent, invalid_inputs):
        """Test that invalid input fails validation with appropriate errors."""
        for input_dict, expected_error in invalid_inputs:
            try:
                input_data = {{ cookiecutter.agent_class_name }}Input(**input_dict)
                result = agent._validate_input(input_data)
                assert not result["is_valid"], f"Expected validation to fail for {input_dict}"
            except Exception as e:
                # Pydantic validation error is also acceptable
                assert expected_error.lower() in str(e).lower()


class TestCoreProcessing:
    """Tests for core processing logic."""

    def test_process_returns_output_model(self, agent, sample_input):
        """Test that process returns correct output type."""
        result = agent.process(sample_input)

        assert isinstance(result, {{ cookiecutter.agent_class_name }}Output)

    def test_process_includes_provenance_hash(self, agent, sample_input):
        """Test that output includes valid SHA-256 provenance hash."""
        result = agent.process(sample_input)

        assert result.provenance_hash is not None
        assert len(result.provenance_hash) == 64  # SHA-256 hex length
        # Verify it's valid hex
        int(result.provenance_hash, 16)

    def test_process_tracks_processing_time(self, agent, sample_input):
        """Test that processing time is tracked."""
        result = agent.process(sample_input)

        assert result.processing_time_ms > 0
        assert result.processing_time_ms < 10000  # Should complete in <10s

    def test_process_sets_validation_status(self, agent, sample_input):
        """Test that validation status is set correctly."""
        result = agent.process(sample_input)

        assert result.validation_status in ["PASS", "FAIL"]


class TestProvenanceTracking:
    """Tests for provenance hash calculation."""

    def test_provenance_is_deterministic(self, agent, sample_input):
        """Test that same input produces same provenance hash."""
        result1 = agent.process(sample_input)
        result2 = agent.process(sample_input)

        assert result1.provenance_hash == result2.provenance_hash

    def test_provenance_changes_with_input(self, agent, valid_inputs):
        """Test that different inputs produce different provenance hashes."""
        if len(valid_inputs) < 2:
            pytest.skip("Need at least 2 valid inputs to test")

        result1 = agent.process(valid_inputs[0])
        result2 = agent.process(valid_inputs[1])

        assert result1.provenance_hash != result2.provenance_hash

    def test_provenance_hash_format(self, agent, sample_input):
        """Test provenance hash is valid SHA-256 format."""
        result = agent.process(sample_input)

        # Should be 64 character hex string
        assert len(result.provenance_hash) == 64
        assert all(c in '0123456789abcdef' for c in result.provenance_hash)


class TestOutputValidation:
    """Tests for output validation."""

    def test_output_validation_passes_for_valid_result(self, agent, sample_input):
        """Test output validation passes for valid processing results."""
        result = agent.process(sample_input)

        assert result.validation_status == "PASS"

    def test_output_model_is_serializable(self, agent, sample_input):
        """Test that output can be serialized to JSON."""
        result = agent.process(sample_input)

        # Should not raise
        json_str = result.json()
        assert isinstance(json_str, str)
        assert "provenance_hash" in json_str


class TestErrorHandling:
    """Tests for error handling."""

    def test_invalid_input_raises_value_error(self, agent):
        """Test that invalid input raises ValueError."""
        # Create intentionally invalid input
        with pytest.raises((ValueError, Exception)):
            agent.process(None)

    def test_error_includes_descriptive_message(self, agent, invalid_inputs):
        """Test that errors include descriptive messages."""
        for input_dict, expected_error in invalid_inputs:
            try:
                input_data = {{ cookiecutter.agent_class_name }}Input(**input_dict)
                agent.process(input_data)
            except Exception as e:
                assert len(str(e)) > 0, "Error message should not be empty"


class TestDeterminism:
    """Tests for deterministic behavior (D01 certification)."""

    def test_100_runs_produce_identical_results(self, agent, sample_input):
        """Test that 100 consecutive runs produce byte-identical outputs."""
        results = [agent.process(sample_input) for _ in range(100)]

        # All provenance hashes should be identical
        first_hash = results[0].provenance_hash
        assert all(r.provenance_hash == first_hash for r in results)

        # All results should be identical
        first_result = results[0].result
        assert all(r.result == first_result for r in results)

    def test_order_independence(self, agent, valid_inputs):
        """Test that processing order doesn't affect individual results."""
        if len(valid_inputs) < 2:
            pytest.skip("Need at least 2 valid inputs to test")

        # Process in order A, B
        result_a1 = agent.process(valid_inputs[0])
        result_b1 = agent.process(valid_inputs[1])

        # Process in order B, A
        result_b2 = agent.process(valid_inputs[1])
        result_a2 = agent.process(valid_inputs[0])

        assert result_a1.provenance_hash == result_a2.provenance_hash
        assert result_b1.provenance_hash == result_b2.provenance_hash
