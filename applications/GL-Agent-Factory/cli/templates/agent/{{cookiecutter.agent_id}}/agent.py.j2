"""
{{ cookiecutter.agent_name }} Agent

Auto-generated by GreenLang Agent Factory
Version: {{ cookiecutter.version }}
Type: {{ cookiecutter.agent_type }}
Domain: {{ cookiecutter.domain }}

This module implements the {{ cookiecutter.agent_name }} for {{ cookiecutter.domain }} operations.
{{ cookiecutter.description }}
"""

from typing import Dict, List, Optional, Any
from pydantic import BaseModel, Field, validator
import hashlib
import logging
from datetime import datetime

logger = logging.getLogger(__name__)


class {{ cookiecutter.agent_class_name }}Input(BaseModel):
    """Input data model for {{ cookiecutter.agent_class_name }}."""

    # Define input fields with types, descriptions, and validation
    {% for field in cookiecutter.input_fields %}
    {{ field.name }}: {{ field.type }} = Field({{ field.default }}, description="{{ field.description }}")
    {% endfor %}

    class Config:
        """Pydantic configuration."""
        extra = "forbid"


class {{ cookiecutter.agent_class_name }}Output(BaseModel):
    """Output data model for {{ cookiecutter.agent_class_name }}."""

    result: Any = Field(..., description="Primary result")
    provenance_hash: str = Field(..., description="SHA-256 hash for audit trail")
    processing_time_ms: float = Field(..., description="Processing duration")
    validation_status: str = Field(..., description="PASS or FAIL")
    {% for field in cookiecutter.output_fields %}
    {{ field.name }}: {{ field.type }} = Field({{ field.default }}, description="{{ field.description }}")
    {% endfor %}


class {{ cookiecutter.agent_class_name }}:
    """
    {{ cookiecutter.agent_class_name }} implementation.

    This agent is responsible for {{ cookiecutter.description }}.
    It follows GreenLang's zero-hallucination principle by using only
    deterministic calculations and validated data sources.

    Attributes:
        config: Agent configuration
        version: Agent version string

    Example:
        >>> agent = {{ cookiecutter.agent_class_name }}()
        >>> result = agent.process(input_data)
        >>> assert result.validation_status == "PASS"
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """Initialize {{ cookiecutter.agent_class_name }}."""
        self.config = config or {}
        self.id = "{{ cookiecutter.agent_id }}"
        self.version = "{{ cookiecutter.version }}"
        self.name = "{{ cookiecutter.agent_name }}"
        logger.info(f"Initialized {self.name} v{self.version}")

    def process(self, input_data: {{ cookiecutter.agent_class_name }}Input) -> {{ cookiecutter.agent_class_name }}Output:
        """
        Main processing method.

        Args:
            input_data: Validated input data

        Returns:
            Processed output with provenance hash

        Raises:
            ValueError: If input data fails validation
            ProcessingError: If processing fails
        """
        start_time = datetime.now()

        try:
            # Step 1: Validate input
            validation_result = self._validate_input(input_data)
            if not validation_result["is_valid"]:
                raise ValueError(f"Input validation failed: {validation_result['errors']}")

            # Step 2: Process data (zero-hallucination approach)
            processed_data = self._process_core_logic(input_data)

            # Step 3: Calculate provenance hash
            provenance_hash = self._calculate_provenance(input_data, processed_data)

            # Step 4: Validate output
            output_validation = self._validate_output(processed_data)

            # Step 5: Create output
            processing_time = (datetime.now() - start_time).total_seconds() * 1000

            return {{ cookiecutter.agent_class_name }}Output(
                result=processed_data,
                provenance_hash=provenance_hash,
                processing_time_ms=processing_time,
                validation_status="PASS" if output_validation["is_valid"] else "FAIL"
            )

        except Exception as e:
            logger.error(f"{{ cookiecutter.agent_class_name }} processing failed: {str(e)}", exc_info=True)
            raise

    def _validate_input(self, input_data: {{ cookiecutter.agent_class_name }}Input) -> Dict[str, Any]:
        """Validate input data meets all requirements."""
        errors = []
        warnings = []

        # Add custom validation logic here
        # Example: Check for required fields, valid ranges, etc.

        return {
            "is_valid": len(errors) == 0,
            "errors": errors,
            "warnings": warnings
        }

    def _process_core_logic(self, input_data: {{ cookiecutter.agent_class_name }}Input) -> Any:
        """
        Core processing logic - ZERO HALLUCINATION.

        This method implements deterministic processing only.
        No LLM calls allowed for numeric calculations.
        """
        # TODO: Implement core processing logic
        # Use only:
        # - Database lookups
        # - Python arithmetic
        # - Formula engine evaluation
        # - Pandas aggregations

        result = {}

        return result

    def _calculate_provenance(self, input_data: Any, output_data: Any) -> str:
        """Calculate SHA-256 hash for complete audit trail."""
        provenance_str = f"{input_data.json()}{str(output_data)}"
        return hashlib.sha256(provenance_str.encode()).hexdigest()

    def _validate_output(self, output_data: Any) -> Dict[str, Any]:
        """Validate output meets all requirements."""
        errors = []

        # Add output validation logic here

        return {
            "is_valid": len(errors) == 0,
            "errors": errors
        }


if __name__ == "__main__":
    # Example usage
    agent = {{ cookiecutter.agent_class_name }}()

    # Create sample input
    sample_input = {{ cookiecutter.agent_class_name }}Input(
        # Add sample input values
    )

    # Process
    result = agent.process(sample_input)
    print(f"Result: {result}")
    print(f"Provenance Hash: {result.provenance_hash}")
