"""
{{ pack.name }} - {{ pack.description | truncate(80) }}

Agent ID: {{ pack.id }}
Version: {{ pack.version }}
Category: {{ pack.category }}

This module is AUTO-GENERATED by the GreenLang Agent Factory.
Do not edit manually - regenerate from pack.yaml instead.

Generated: {{ generated_at }}
Code Hash: {{ code_hash }}

ZERO-HALLUCINATION GUARANTEE:
- All numeric calculations use deterministic tools only
- No LLM calls in the calculation path
- Complete provenance tracking with SHA-256 hashes
- All data sources cited and versioned
{% if metadata.regulatory %}

REGULATORY COMPLIANCE:
{% for standard in metadata.regulatory.standards %}
- {{ standard }}
{% endfor %}
{% endif %}
"""

import hashlib
import json
import logging
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, Field, validator

logger = logging.getLogger(__name__)


# =============================================================================
# Constants
# =============================================================================

AGENT_ID = "{{ pack.id }}"
AGENT_VERSION = "{{ pack.version }}"
CODE_HASH = "{{ code_hash }}"
GENERATED_AT = "{{ generated_at }}"
DETERMINISTIC = {{ compute.deterministic | default(true) | lower }}
SEED = {{ compute.seed | default(42) }}


# =============================================================================
# Enums
# =============================================================================

{% for input in compute.inputs.values() %}
{% if input.enum %}
class {{ input.name | pascal_case }}Enum(str, Enum):
    """Valid values for {{ input.name }}."""
{% for value in input.enum %}
    {{ value | upper | replace('-', '_') | replace('.', '_') }} = "{{ value }}"
{% endfor %}

{% endif %}
{% endfor %}

# =============================================================================
# Input/Output Models
# =============================================================================

class {{ pack.id | replace('-', '_') | pascal_case }}Input(BaseModel):
    """
    Input model for {{ pack.name }}.

    All inputs are validated before calculation.
    """

{% for name, input in compute.inputs.items() %}
    {{ name }}: {% if not input.required %}Optional[{% endif %}{{ input.dtype | dtype_to_python }}{% if not input.required %}]{% endif %} = Field(
        {% if input.required %}...{% elif input.default is defined %}{{ input.default | tojson }}{% else %}None{% endif %},
        description="{{ input.description | default(name) }}"{% if input.ge is defined %},
        ge={{ input.ge }}{% endif %}{% if input.le is defined %},
        le={{ input.le }}{% endif %}

    )
{% endfor %}

    class Config:
        extra = "forbid"
        validate_assignment = True


class {{ pack.id | replace('-', '_') | pascal_case }}Output(BaseModel):
    """
    Output model for {{ pack.name }}.

    All outputs include provenance tracking for audit compliance.
    """

{% for name, output in compute.outputs.items() %}
    {{ name }}: {% if output.nullable | default(false) %}Optional[{% endif %}{{ output.dtype | dtype_to_python }}{% if output.nullable | default(false) %}]{% endif %} = Field(
        {% if output.nullable | default(false) %}None{% else %}...{% endif %},
        description="{{ output.description | default(name) }}"
    )
{% endfor %}

    class Config:
        extra = "allow"


# =============================================================================
# Supporting Models
# =============================================================================

class EmissionFactor(BaseModel):
    """Emission factor with provenance."""

    value: float
    unit: str
    source: str
    year: int
    uncertainty_lower: Optional[float] = None
    uncertainty_upper: Optional[float] = None
    ref: Optional[str] = None


class CalculationStep(BaseModel):
    """Record of a single calculation step for provenance."""

    step_type: str
    timestamp: str
    data: Dict[str, Any]


# =============================================================================
# Agent Implementation
# =============================================================================

class {{ pack.id | replace('-', '_') | pascal_case }}Agent:
    """
    {{ pack.name }}

    {{ pack.description | wordwrap(72) | indent(4) }}

    This agent enforces ZERO-HALLUCINATION principles:
    1. All calculations are deterministic (no LLM in calculation path)
    2. All emission factors from authoritative sources
    3. Complete SHA-256 provenance tracking
    4. Full reproducibility with pinned factors

    Attributes:
        AGENT_ID: Unique agent identifier
        VERSION: Agent version
        DETERMINISTIC: Whether calculations are deterministic

    Example:
        >>> agent = {{ pack.id | replace('-', '_') | pascal_case }}Agent()
        >>> result = agent.run({{ pack.id | replace('-', '_') | pascal_case }}Input(
        ...     # Add your inputs here
        ... ))
        >>> print(f"Result: {result}")
    """

    # Agent metadata
    AGENT_ID = AGENT_ID
    VERSION = AGENT_VERSION
    DESCRIPTION = "{{ pack.description | truncate(100) }}"
    DETERMINISTIC = DETERMINISTIC

{% if factors %}
    # Emission factors from authoritative sources
    EMISSION_FACTORS: Dict[str, Dict[str, EmissionFactor]] = {
{% for factor in factors %}
{% set fuel_type = factor.ref.split('/')[3] if '/' in factor.ref else 'unknown' %}
        "{{ fuel_type }}": {
            "{{ factor.region | default('GLOBAL') }}": EmissionFactor(
                value={{ factor.value }},
                unit="{{ factor.unit }}",
                source="{{ factor.ref.split('/')[2] | upper if '/' in factor.ref else 'UNKNOWN' }}",
                year={{ factor.ref.split('/')[4] if '/' in factor.ref and factor.ref.split('/') | length > 4 else 2024 }},
                ref="{{ factor.ref }}",
            ),
        },
{% endfor %}
    }
{% endif %}

    # Unit conversion factors
    UNIT_CONVERSIONS: Dict[tuple, float] = {
        ("cf", "m3"): 0.0283168,
        ("therm", "m3"): 2.832,
        ("GJ", "m3"): 26.137,
        ("gal", "L"): 3.78541,
        ("MWh", "kWh"): 1000,
        ("t", "kg"): 1000,
        ("short_ton", "kg"): 907.185,
    }

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        Initialize the {{ pack.name }}.

        Args:
            config: Optional configuration overrides
        """
        self.config = config or {}
        self._provenance_steps: List[CalculationStep] = []

        logger.info(f"{{ pack.id | replace('-', '_') | pascal_case }}Agent initialized (version {self.VERSION})")

    def run(
        self,
        input_data: {{ pack.id | replace('-', '_') | pascal_case }}Input
    ) -> {{ pack.id | replace('-', '_') | pascal_case }}Output:
        """
        Execute the calculation.

        This method performs a ZERO-HALLUCINATION calculation:
        All numeric operations use deterministic formulas and validated factors.

        Args:
            input_data: Validated input data

        Returns:
            Calculation result with provenance

        Raises:
            ValueError: If required data is missing or invalid
        """
        start_time = datetime.utcnow()
        self._provenance_steps = []

        logger.info(f"Executing {self.AGENT_ID} with inputs: {input_data.dict()}")

        try:
            # Execute core calculation logic
            result_data = self._execute_calculation(input_data)

            # Calculate provenance hash
            provenance_hash = self._calculate_provenance_hash(input_data, result_data)

            # Build output
            output = {{ pack.id | replace('-', '_') | pascal_case }}Output(
                **result_data,
                provenance_hash=provenance_hash,
                calculated_at=datetime.utcnow(),
            )

            duration_ms = (datetime.utcnow() - start_time).total_seconds() * 1000
            logger.info(
                f"Calculation complete (duration: {duration_ms:.2f}ms, "
                f"provenance: {provenance_hash[:16]}...)"
            )

            return output

        except Exception as e:
            logger.error(f"Calculation failed: {str(e)}", exc_info=True)
            raise

    def _execute_calculation(
        self,
        input_data: {{ pack.id | replace('-', '_') | pascal_case }}Input
    ) -> Dict[str, Any]:
        """
        Execute core calculation logic.

        ZERO-HALLUCINATION: All calculations are deterministic.
        Override this method to implement specific calculation logic.
        """
        # TODO: Implement calculation logic based on pack.yaml spec
        # This is a placeholder - actual implementation should be generated
        # based on the specific agent type

        raise NotImplementedError(
            "Calculation logic must be implemented based on pack.yaml specification"
        )

    def _get_emission_factor(
        self,
        factor_type: str,
        region: str,
    ) -> Optional[EmissionFactor]:
        """
        Look up emission factor from validated database.

        ZERO-HALLUCINATION: All factors from authoritative sources.
        """
        type_factors = self.EMISSION_FACTORS.get(factor_type, {})

        # Try exact region match
        if region in type_factors:
            return type_factors[region]

        # Try parent region (EU hierarchy)
        region_hierarchy = {"DE": "EU", "FR": "EU", "IT": "EU", "ES": "EU", "UK": "EU"}
        parent = region_hierarchy.get(region)
        if parent and parent in type_factors:
            return type_factors[parent]

        # Fall back to US or GLOBAL
        if "US" in type_factors:
            logger.warning(f"Using US emission factor for region {region}")
            return type_factors["US"]

        if "GLOBAL" in type_factors:
            logger.warning(f"Using GLOBAL emission factor for region {region}")
            return type_factors["GLOBAL"]

        return None

    def _convert_units(
        self,
        value: float,
        from_unit: str,
        to_unit_with_denominator: str,
    ) -> float:
        """
        Convert units if needed.

        Returns the value converted to match emission factor denominator.
        """
        # Extract denominator from EF unit (e.g., kgCO2e/m3 -> m3)
        target_unit = (
            to_unit_with_denominator.split("/")[1]
            if "/" in to_unit_with_denominator
            else to_unit_with_denominator
        )

        if from_unit == target_unit:
            return value

        # Look up conversion
        conversion = self.UNIT_CONVERSIONS.get((from_unit, target_unit))
        if conversion:
            return value * conversion

        # Try reverse conversion
        reverse = self.UNIT_CONVERSIONS.get((target_unit, from_unit))
        if reverse:
            return value / reverse

        logger.warning(f"No conversion found: {from_unit} -> {target_unit}")
        return value

    def _track_step(self, step_type: str, data: Dict[str, Any]) -> None:
        """Track a calculation step for provenance."""
        self._provenance_steps.append(CalculationStep(
            step_type=step_type,
            timestamp=datetime.utcnow().isoformat(),
            data=data,
        ))

    def _calculate_provenance_hash(
        self,
        input_data: {{ pack.id | replace('-', '_') | pascal_case }}Input,
        output_data: Dict[str, Any],
    ) -> str:
        """
        Calculate SHA-256 hash of complete provenance chain.

        This hash enables:
        - Verification that calculation was deterministic
        - Audit trail for regulatory compliance
        - Reproducibility checking
        """
        provenance_data = {
            "agent_id": self.AGENT_ID,
            "version": self.VERSION,
            "code_hash": CODE_HASH,
            "inputs": input_data.dict(),
            "outputs": output_data,
            "steps": [s.dict() for s in self._provenance_steps],
            "seed": SEED,
            "timestamp": datetime.utcnow().isoformat(),
        }

        json_str = json.dumps(provenance_data, sort_keys=True, default=str)
        return hashlib.sha256(json_str.encode()).hexdigest()


# =============================================================================
# Factory Function
# =============================================================================

def create_agent(**kwargs) -> {{ pack.id | replace('-', '_') | pascal_case }}Agent:
    """Factory function to create agent instance."""
    return {{ pack.id | replace('-', '_') | pascal_case }}Agent(**kwargs)


# =============================================================================
# Pack Specification (for reference)
# =============================================================================

PACK_SPEC = {
    "schema_version": "{{ schema_version | default('2.0.0') }}",
    "id": "{{ pack.id }}",
    "name": "{{ pack.name }}",
    "version": "{{ pack.version }}",
    "category": "{{ pack.category }}",
    "deterministic": {{ compute.deterministic | default(true) | lower }},
}
