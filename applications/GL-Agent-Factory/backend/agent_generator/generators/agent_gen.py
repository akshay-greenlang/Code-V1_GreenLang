"""
Agent Generator Module for GreenLang Agent Factory

This module generates complete agent.py files from AgentSpec definitions.
It uses Jinja2 templates to create production-ready Python code with:

- Full type hints and Pydantic models
- Zero-hallucination calculation patterns
- Provenance tracking with SHA-256 hashes
- Comprehensive error handling
- Logging at all key points
- Unit test generation

Example:
    >>> generator = AgentGenerator(config)
    >>> code = generator.generate_agent(spec, agent_def)
    >>> print(code)  # Complete Python module
"""

import hashlib
import logging
import re
from datetime import datetime
from typing import Any, Dict, List, Optional, Set

from jinja2 import Environment, BaseLoader, Template

from backend.agent_generator.parser.yaml_parser import (
    AgentSpec,
    AgentDefinition,
    InputDefinition,
    OutputDefinition,
    ToolDefinition,
)

logger = logging.getLogger(__name__)


# =============================================================================
# Jinja2 Templates
# =============================================================================

AGENT_TEMPLATE = '''"""
{{ agent.name }}

{{ agent.description or 'Generated by GreenLang Agent Factory.' }}

This agent implements:
{% for inp in agent.inputs %}
- Input: {{ inp.name }} ({{ inp.type }}){% if inp.description %} - {{ inp.description }}{% endif %}

{% endfor %}
{% for out in agent.outputs %}
- Output: {{ out.name }} ({{ out.type }}){% if out.description %} - {{ out.description }}{% endif %}

{% endfor %}
Pack: {{ spec.pack.name }} v{{ spec.pack.version }}
Generated: {{ timestamp }}

Example:
    >>> agent = {{ class_name }}()
    >>> result = agent.run({{ input_class_name }}(
    ...     # Provide input parameters
    ... ))
    >>> print(result.provenance_hash)
"""

import hashlib
import json
import logging
from datetime import datetime
from decimal import Decimal
from enum import Enum
from typing import Any, Dict, List, Optional, Union

from pydantic import BaseModel, Field, validator

logger = logging.getLogger(__name__)


# =============================================================================
# Input/Output Models
# =============================================================================

{{ input_model }}


{{ output_model }}


# =============================================================================
# Agent Implementation
# =============================================================================

class {{ class_name }}:
    """
    {{ agent.name }} implementation.

    {{ agent.description or 'Generated by GreenLang Agent Factory.' }}

    This agent follows GreenLang's zero-hallucination principle:
    - All numeric calculations are deterministic
    - Complete provenance tracking with SHA-256 hashes
    - No LLM calls in the calculation path

    Attributes:
        config: Agent configuration dictionary
        version: Agent version string

    Example:
        >>> agent = {{ class_name }}()
        >>> result = agent.run({{ input_class_name }}(...))
        >>> assert result.provenance_hash is not None
    """

    # Agent metadata
    AGENT_ID = "{{ spec.pack.id }}/{{ agent.id }}"
    VERSION = "{{ spec.pack.version }}"
    DESCRIPTION = "{{ agent.description or agent.name }}"

    def __init__(self, config: Optional[Dict[str, Any]] = None):
        """
        Initialize the {{ agent.name }}.

        Args:
            config: Optional configuration overrides
        """
        self.config = config or {}
        self._provenance_steps: List[Dict[str, Any]] = []

        logger.info(f"{{ class_name }} initialized (version {self.VERSION})")

    def run(self, input_data: {{ input_class_name }}) -> {{ output_class_name }}:
        """
        Execute the agent's main processing logic.

        This method implements ZERO-HALLUCINATION processing:
        - All calculations are deterministic
        - Complete provenance tracking
        - No LLM in calculation path

        Args:
            input_data: Validated input data

        Returns:
            Processing result with provenance hash

        Raises:
            ValueError: If input validation fails
            ProcessingError: If processing fails
        """
        start_time = datetime.utcnow()
        self._provenance_steps = []

        logger.info(f"{{ class_name }}.run() started")

        try:
            # Step 1: Validate input
            validation_result = self._validate_input(input_data)
            if not validation_result["is_valid"]:
                raise ValueError(f"Input validation failed: {validation_result['errors']}")

            self._track_step("input_validation", {
                "is_valid": True,
                "input_hash": self._hash_input(input_data),
            })

            # Step 2: Process core logic (ZERO-HALLUCINATION)
            processed_data = self._process_core_logic(input_data)

            self._track_step("core_processing", {
                "processed": True,
            })

            # Step 3: Calculate provenance hash
            provenance_hash = self._calculate_provenance_hash()

            # Step 4: Calculate processing time
            processing_time_ms = (datetime.utcnow() - start_time).total_seconds() * 1000

            # Step 5: Create output
            output = {{ output_class_name }}(
{% for out in agent.outputs %}
{% if out.name == 'provenance_hash' %}
                provenance_hash=provenance_hash,
{% elif out.name == 'processing_time_ms' %}
                processing_time_ms=processing_time_ms,
{% elif out.name == 'validation_status' %}
                validation_status="PASS",
{% else %}
                {{ out.name }}=processed_data.get("{{ out.name }}"),
{% endif %}
{% endfor %}
            )

            logger.info(
                f"{{ class_name }}.run() completed in {processing_time_ms:.2f}ms "
                f"(provenance: {provenance_hash[:16]}...)"
            )

            return output

        except ValueError as e:
            logger.error(f"Validation error in {{ class_name }}: {e}")
            raise

        except Exception as e:
            logger.error(f"Processing error in {{ class_name }}: {e}", exc_info=True)
            raise ProcessingError(f"{{ class_name }} processing failed: {str(e)}")

    def _validate_input(self, input_data: {{ input_class_name }}) -> Dict[str, Any]:
        """
        Validate input data meets all requirements.

        Args:
            input_data: Input data to validate

        Returns:
            Dictionary with is_valid and errors
        """
        errors: List[str] = []

        # Pydantic already validates types, add custom validation here
{% for inp in agent.inputs %}
{% if inp.required %}
        if input_data.{{ inp.name }} is None:
            errors.append("{{ inp.name }} is required")
{% endif %}
{% endfor %}

        return {
            "is_valid": len(errors) == 0,
            "errors": errors,
        }

    def _process_core_logic(self, input_data: {{ input_class_name }}) -> Dict[str, Any]:
        """
        Core processing logic - ZERO HALLUCINATION.

        This method implements deterministic processing only.
        No LLM calls allowed for numeric calculations.

        Args:
            input_data: Validated input data

        Returns:
            Dictionary with processed results
        """
        result: Dict[str, Any] = {}

        # TODO: Implement your zero-hallucination processing logic here
        # Example patterns:
        #
        # 1. Database lookups:
        #    value = self._lookup_from_db(input_data.key)
        #
        # 2. Deterministic calculations:
        #    result["total"] = input_data.quantity * factor
        #
        # 3. Formula evaluation:
        #    result["emissions"] = self._calculate_emissions(input_data)

        logger.debug(f"Core logic processing for {{ class_name }}")

        return result

    def _hash_input(self, input_data: {{ input_class_name }}) -> str:
        """Calculate SHA-256 hash of input data."""
        input_json = input_data.json(sort_keys=True)
        return hashlib.sha256(input_json.encode()).hexdigest()

    def _track_step(self, step_type: str, data: Dict[str, Any]) -> None:
        """
        Track a processing step for provenance.

        Args:
            step_type: Type of step (e.g., 'validation', 'calculation')
            data: Step data to record
        """
        self._provenance_steps.append({
            "step_type": step_type,
            "timestamp": datetime.utcnow().isoformat(),
            "data": data,
        })

    def _calculate_provenance_hash(self) -> str:
        """
        Calculate SHA-256 hash of complete provenance chain.

        This hash enables:
        - Verification that processing was deterministic
        - Audit trail for regulatory compliance
        - Reproducibility checking

        Returns:
            64-character hex string
        """
        provenance_data = {
            "agent_id": self.AGENT_ID,
            "version": self.VERSION,
            "steps": self._provenance_steps,
            "timestamp": datetime.utcnow().isoformat(),
        }

        json_str = json.dumps(provenance_data, sort_keys=True, default=str)
        return hashlib.sha256(json_str.encode()).hexdigest()


# =============================================================================
# Exceptions
# =============================================================================

class ProcessingError(Exception):
    """Exception raised when agent processing fails."""

    def __init__(self, message: str, details: Optional[Dict[str, Any]] = None):
        self.message = message
        self.details = details or {}
        super().__init__(self.message)


# =============================================================================
# Pack Specification
# =============================================================================

PACK_SPEC = {
    "schema_version": "2.0.0",
    "id": "{{ spec.pack.id }}/{{ agent.id }}",
    "name": "{{ agent.name }}",
    "version": "{{ spec.pack.version }}",
    "summary": "{{ agent.description or agent.name }}",
    "tags": {{ tags }},
    "owners": ["{{ spec.pack.author }}"],
    "compute": {
        "entrypoint": "python://{{ module_path }}:{{ class_name }}",
        "deterministic": True,
    },
    "provenance": {
        "enable_audit": True,
    },
}
'''

TEST_TEMPLATE = '''"""
Unit Tests for {{ class_name }}

Generated by GreenLang Agent Factory.
"""

import pytest
from datetime import datetime
from decimal import Decimal

from {{ module_import_path }} import (
    {{ class_name }},
    {{ input_class_name }},
    {{ output_class_name }},
)


class Test{{ class_name }}:
    """Test suite for {{ class_name }}."""

    @pytest.fixture
    def agent(self):
        """Create agent instance for testing."""
        return {{ class_name }}()

    @pytest.fixture
    def valid_input(self):
        """Create valid input data for testing."""
        return {{ input_class_name }}(
{% for inp in agent.inputs %}
{% if inp.required %}
            {{ inp.name }}={{ default_value(inp.type) }},
{% endif %}
{% endfor %}
        )

    def test_agent_initialization(self, agent):
        """Test agent initializes correctly."""
        assert agent is not None
        assert agent.AGENT_ID == "{{ spec.pack.id }}/{{ agent.id }}"
        assert agent.VERSION == "{{ spec.pack.version }}"

    def test_agent_run_returns_output(self, agent, valid_input):
        """Test agent run returns valid output."""
        result = agent.run(valid_input)

        assert result is not None
        assert isinstance(result, {{ output_class_name }})

    def test_agent_run_has_provenance_hash(self, agent, valid_input):
        """Test agent output includes provenance hash."""
        result = agent.run(valid_input)

        assert hasattr(result, "provenance_hash") or True  # Adjust based on outputs
        # Provenance hash should be 64 character hex string
        # assert len(result.provenance_hash) == 64

    def test_agent_run_tracks_processing_time(self, agent, valid_input):
        """Test agent tracks processing time."""
        result = agent.run(valid_input)

        # Processing should complete in reasonable time
        if hasattr(result, "processing_time_ms"):
            assert result.processing_time_ms >= 0
            assert result.processing_time_ms < 60000  # Less than 1 minute

    def test_agent_validates_input(self, agent):
        """Test agent validates input data."""
        # This test checks that invalid input is rejected
        # Customize based on your validation requirements
        pass

    def test_agent_deterministic_output(self, agent, valid_input):
        """Test agent produces deterministic output for same input."""
        result1 = agent.run(valid_input)
        result2 = agent.run(valid_input)

        # Core outputs should be the same (excluding timestamps)
        # Customize based on your output fields
        pass

    def test_agent_config_override(self):
        """Test agent accepts config overrides."""
        custom_config = {"custom_key": "custom_value"}
        agent = {{ class_name }}(config=custom_config)

        assert agent.config["custom_key"] == "custom_value"


class Test{{ input_class_name }}:
    """Test suite for {{ input_class_name }} model."""

    def test_valid_input_creation(self):
        """Test creating valid input model."""
        input_data = {{ input_class_name }}(
{% for inp in agent.inputs %}
{% if inp.required %}
            {{ inp.name }}={{ default_value(inp.type) }},
{% endif %}
{% endfor %}
        )
        assert input_data is not None

{% for inp in agent.inputs %}
{% if inp.required %}
    def test_{{ inp.name }}_required(self):
        """Test {{ inp.name }} is required."""
        with pytest.raises(Exception):
            {{ input_class_name }}(
{% for other_inp in agent.inputs %}
{% if other_inp.required and other_inp.name != inp.name %}
                {{ other_inp.name }}={{ default_value(other_inp.type) }},
{% endif %}
{% endfor %}
            )

{% endif %}
{% endfor %}


class Test{{ output_class_name }}:
    """Test suite for {{ output_class_name }} model."""

    def test_valid_output_creation(self):
        """Test creating valid output model."""
        # Customize based on your output fields
        pass
'''


# =============================================================================
# Agent Generator
# =============================================================================

class AgentGenerator:
    """
    Generator for agent.py files.

    This generator creates complete Python agent implementations
    from AgentSpec definitions using Jinja2 templates.

    Features:
    - Full type hints and Pydantic models
    - Zero-hallucination calculation patterns
    - Provenance tracking with SHA-256 hashes
    - Comprehensive error handling
    - Logging at all key points

    Example:
        >>> generator = AgentGenerator(config)
        >>> code = generator.generate_agent(spec, agent_def)
    """

    # Type mapping from YAML types to Python types
    TYPE_MAPPING = {
        "string": "str",
        "str": "str",
        "integer": "int",
        "int": "int",
        "float": "float",
        "float64": "float",
        "boolean": "bool",
        "bool": "bool",
        "object": "Dict[str, Any]",
        "dict": "Dict[str, Any]",
        "array": "List[Any]",
        "list": "List[Any]",
        "date": "datetime",
        "datetime": "datetime",
        "any": "Any",
    }

    # Default values for test generation
    DEFAULT_VALUES = {
        "str": '"test_value"',
        "string": '"test_value"',
        "int": "1",
        "integer": "1",
        "float": "1.0",
        "float64": "1.0",
        "bool": "True",
        "boolean": "True",
        "dict": "{}",
        "object": "{}",
        "list": "[]",
        "array": "[]",
        "date": "datetime.now()",
        "datetime": "datetime.now()",
        "any": "None",
    }

    def __init__(self, config: Any = None):
        """
        Initialize the agent generator.

        Args:
            config: Generator configuration
        """
        self.config = config
        self._env = Environment(loader=BaseLoader())

        # Add custom filters
        self._env.filters["pascal_case"] = self._to_pascal_case
        self._env.filters["snake_case"] = self._to_snake_case

        logger.info("AgentGenerator initialized")

    def generate_agent(self, spec: AgentSpec, agent: AgentDefinition) -> str:
        """
        Generate complete agent.py code for an agent.

        Args:
            spec: The complete AgentSpec
            agent: The agent definition to generate

        Returns:
            Complete Python module code as string
        """
        logger.info(f"Generating agent code for: {agent.id}")

        # Generate class names
        class_name = agent.get_class_name()
        input_class_name = f"{class_name}Input"
        output_class_name = f"{class_name}Output"

        # Generate input model
        input_model = self._generate_input_model(agent, input_class_name)

        # Generate output model
        output_model = self._generate_output_model(agent, output_class_name)

        # Generate tags
        tags = self._generate_tags(spec, agent)

        # Generate module path
        module_path = f"agents.{agent.get_module_name()}"

        # Render template
        template = self._env.from_string(AGENT_TEMPLATE)
        code = template.render(
            spec=spec,
            agent=agent,
            class_name=class_name,
            input_class_name=input_class_name,
            output_class_name=output_class_name,
            input_model=input_model,
            output_model=output_model,
            tags=tags,
            module_path=module_path,
            timestamp=datetime.utcnow().isoformat(),
        )

        logger.info(f"Generated {len(code)} characters for {agent.id}")
        return code

    def generate_tests(self, spec: AgentSpec, agent: AgentDefinition) -> str:
        """
        Generate unit tests for an agent.

        Args:
            spec: The complete AgentSpec
            agent: The agent definition to generate tests for

        Returns:
            Complete Python test module code as string
        """
        logger.info(f"Generating tests for: {agent.id}")

        class_name = agent.get_class_name()
        input_class_name = f"{class_name}Input"
        output_class_name = f"{class_name}Output"
        module_import_path = f"agents.{agent.get_module_name()}"

        # Add default_value function to template context
        def default_value(type_str: str) -> str:
            base_type = type_str.lower().split("[")[0]
            return self.DEFAULT_VALUES.get(base_type, "None")

        template = self._env.from_string(TEST_TEMPLATE)
        code = template.render(
            spec=spec,
            agent=agent,
            class_name=class_name,
            input_class_name=input_class_name,
            output_class_name=output_class_name,
            module_import_path=module_import_path,
            default_value=default_value,
        )

        return code

    def _generate_input_model(
        self,
        agent: AgentDefinition,
        class_name: str,
    ) -> str:
        """Generate Pydantic input model."""
        lines = [
            f"class {class_name}(BaseModel):",
            f'    """',
            f"    Input model for {agent.name}.",
            f"",
        ]

        # Add field descriptions to docstring
        if agent.inputs:
            lines.append("    Attributes:")
            for inp in agent.inputs:
                desc = inp.description or f"{inp.name} field"
                lines.append(f"        {inp.name}: {desc}")

        lines.append('    """')
        lines.append("")

        # Generate fields
        if not agent.inputs:
            lines.append("    pass")
        else:
            for inp in agent.inputs:
                field_def = self._generate_field(inp)
                lines.append(f"    {field_def}")

            # Add validators if needed
            validators = self._generate_validators(agent.inputs)
            if validators:
                lines.append("")
                lines.extend(validators)

        return "\n".join(lines)

    def _generate_output_model(
        self,
        agent: AgentDefinition,
        class_name: str,
    ) -> str:
        """Generate Pydantic output model."""
        lines = [
            f"class {class_name}(BaseModel):",
            f'    """',
            f"    Output model for {agent.name}.",
            f"",
            f"    All outputs include provenance tracking for audit compliance.",
            f'    """',
            f"",
        ]

        # Generate fields
        if not agent.outputs:
            # Add default provenance output
            lines.append('    provenance_hash: str = Field(..., description="SHA-256 provenance hash")')
            lines.append('    processing_time_ms: float = Field(..., description="Processing time in ms")')
        else:
            for out in agent.outputs:
                python_type = self._map_type(out.type)
                desc = out.description or f"{out.name} output"
                lines.append(
                    f'    {out.name}: {python_type} = Field(..., description="{desc}")'
                )

            # Ensure provenance outputs exist
            output_names = {out.name for out in agent.outputs}
            if "provenance_hash" not in output_names:
                lines.append('    provenance_hash: str = Field(..., description="SHA-256 provenance hash")')
            if "processing_time_ms" not in output_names:
                lines.append('    processing_time_ms: float = Field(..., description="Processing time in ms")')

        return "\n".join(lines)

    def _generate_field(self, inp: InputDefinition) -> str:
        """Generate a Pydantic field definition."""
        python_type = self._map_type(inp.type)

        # Build Field arguments
        field_args = []

        if inp.required:
            field_args.append("...")
        elif inp.default is not None:
            field_args.append(repr(inp.default))
        else:
            # Optional field
            python_type = f"Optional[{python_type}]"
            field_args.append("None")

        if inp.description:
            field_args.append(f'description="{inp.description}"')

        # Add constraints
        for constraint, value in inp.constraints.items():
            if constraint == "ge":
                field_args.append(f"ge={value}")
            elif constraint == "le":
                field_args.append(f"le={value}")
            elif constraint == "gt":
                field_args.append(f"gt={value}")
            elif constraint == "lt":
                field_args.append(f"lt={value}")
            elif constraint == "min_length":
                field_args.append(f"min_length={value}")
            elif constraint == "max_length":
                field_args.append(f"max_length={value}")
            elif constraint == "regex":
                field_args.append(f'regex="{value}"')

        field_str = ", ".join(field_args)
        return f"{inp.name}: {python_type} = Field({field_str})"

    def _generate_validators(self, inputs: List[InputDefinition]) -> List[str]:
        """Generate Pydantic validators for inputs."""
        validators = []

        for inp in inputs:
            if inp.constraints:
                # Add custom validator if needed
                pass

        return validators

    def _generate_tags(self, spec: AgentSpec, agent: AgentDefinition) -> str:
        """Generate tags list for pack spec."""
        tags = set()

        # Add pack category
        if spec.pack.category:
            tags.add(spec.pack.category)

        # Add agent type
        tags.add(agent.type)

        # Add agent ID parts
        for part in agent.id.split("-"):
            if len(part) > 2:
                tags.add(part)

        return repr(sorted(tags))

    def _map_type(self, type_str: str) -> str:
        """Map YAML type to Python type."""
        # Check direct mapping
        lower_type = type_str.lower()
        if lower_type in self.TYPE_MAPPING:
            return self.TYPE_MAPPING[lower_type]

        # Handle generic types like List[str]
        if "[" in type_str:
            return type_str

        # Assume custom type (keep as-is)
        return type_str

    @staticmethod
    def _to_pascal_case(s: str) -> str:
        """Convert string to PascalCase."""
        parts = re.split(r"[-_\s]", s)
        return "".join(word.capitalize() for word in parts)

    @staticmethod
    def _to_snake_case(s: str) -> str:
        """Convert string to snake_case."""
        s = re.sub(r"([A-Z]+)([A-Z][a-z])", r"\1_\2", s)
        s = re.sub(r"([a-z\d])([A-Z])", r"\1_\2", s)
        return s.replace("-", "_").lower()


# =============================================================================
# Unit Test Stubs
# =============================================================================

def _test_agent_generator():
    """
    Unit test stub for AgentGenerator.

    Run with: pytest backend/agent_generator/generators/agent_gen.py
    """
    from backend.agent_generator.parser.yaml_parser import (
        AgentSpec,
        PackSpec,
        AgentDefinition,
        InputDefinition,
        OutputDefinition,
    )

    # Create test spec
    spec = AgentSpec(
        pack=PackSpec(
            id="test-agent-v1",
            name="Test Agent Pack",
            version="1.0.0",
            description="Test pack for unit testing",
            author="GreenLang",
        ),
        agents=[
            AgentDefinition(
                id="test-validator",
                name="Test Validator",
                type="deterministic-calculator",
                description="A test validator agent",
                inputs=[
                    InputDefinition(
                        name="input_value",
                        type="float",
                        required=True,
                        description="Input value to process",
                    ),
                    InputDefinition(
                        name="region",
                        type="str",
                        required=False,
                        default="US",
                        description="Region code",
                    ),
                ],
                outputs=[
                    OutputDefinition(
                        name="result",
                        type="float",
                        description="Calculated result",
                    ),
                    OutputDefinition(
                        name="confidence",
                        type="float",
                        description="Confidence score",
                    ),
                ],
            ),
        ],
        tools=[],
    )

    # Generate code
    generator = AgentGenerator()
    code = generator.generate_agent(spec, spec.agents[0])

    # Verify code contains expected elements
    assert "class TestValidatorAgent:" in code
    assert "class TestValidatorAgentInput(BaseModel):" in code
    assert "class TestValidatorAgentOutput(BaseModel):" in code
    assert "def run(self" in code
    assert "provenance_hash" in code
    assert "SHA-256" in code

    print(f"Generated code length: {len(code)} characters")
    print("AgentGenerator tests passed!")


if __name__ == "__main__":
    _test_agent_generator()
