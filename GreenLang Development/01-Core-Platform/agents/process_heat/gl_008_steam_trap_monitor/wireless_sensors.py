# -*- coding: utf-8 -*-
"""
GL-008 TRAPCATCHER - Wireless Sensor Network Module

This module provides wireless sensor network integration for continuous
steam trap monitoring using ultrasonic and temperature sensors.

Features:
    - Wireless sensor data collection
    - Sensor health monitoring
    - Data aggregation and buffering
    - Alert generation for sensor issues
    - Support for multiple protocols (LoRaWAN, ZigBee, WiFi)

Sensor Types Supported:
    - Ultrasonic: Continuous acoustic monitoring
    - Temperature: Inlet/outlet temperature monitoring
    - Conductivity: Steam vs condensate detection

Example:
    >>> from greenlang.agents.process_heat.gl_008_steam_trap_monitor.wireless_sensors import (
    ...     WirelessSensorNetwork,
    ...     SensorDataCollector,
    ... )
    >>> network = WirelessSensorNetwork(config.wireless)
    >>> collector = SensorDataCollector(network)
    >>> readings = collector.get_latest_readings("ST-001")
"""

from dataclasses import dataclass, field
from datetime import datetime, timezone, timedelta
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple, Callable
import hashlib
import json
import logging
import threading
import time
from collections import deque

from pydantic import BaseModel, Field

from greenlang.agents.process_heat.gl_008_steam_trap_monitor.config import (
    WirelessSensorConfig,
    SensorConfig,
    SensorType,
    AlertSeverity,
)
from greenlang.agents.process_heat.gl_008_steam_trap_monitor.schemas import (
    SensorReading,
    UltrasonicReading,
    TemperatureReading,
)

logger = logging.getLogger(__name__)


# =============================================================================
# SENSOR STATUS
# =============================================================================

class SensorStatus(str, Enum):
    """Wireless sensor operational status."""
    ONLINE = "online"
    OFFLINE = "offline"
    LOW_BATTERY = "low_battery"
    WEAK_SIGNAL = "weak_signal"
    ERROR = "error"
    MAINTENANCE = "maintenance"


@dataclass
class SensorHealth:
    """Sensor health information."""

    sensor_id: str
    status: SensorStatus
    battery_level_pct: Optional[float] = None
    signal_strength_dbm: Optional[float] = None
    last_reading_time: Optional[datetime] = None
    readings_last_24h: int = 0
    error_count: int = 0
    last_error: Optional[str] = None
    firmware_version: Optional[str] = None


@dataclass
class SensorAlert:
    """Alert generated by sensor network."""

    alert_id: str
    sensor_id: str
    severity: AlertSeverity
    alert_type: str
    message: str
    timestamp: datetime
    acknowledged: bool = False
    acknowledged_by: Optional[str] = None
    acknowledged_time: Optional[datetime] = None


# =============================================================================
# SENSOR READING BUFFER
# =============================================================================

class SensorReadingBuffer:
    """
    Thread-safe circular buffer for sensor readings.

    Maintains a fixed-size buffer of recent readings for each sensor,
    enabling trend analysis and data smoothing.
    """

    def __init__(self, max_readings: int = 100) -> None:
        """
        Initialize reading buffer.

        Args:
            max_readings: Maximum readings to retain per sensor
        """
        self._max_readings = max_readings
        self._buffers: Dict[str, deque] = {}
        self._lock = threading.RLock()

    def add_reading(
        self,
        sensor_id: str,
        reading: SensorReading,
    ) -> None:
        """Add a reading to the buffer."""
        with self._lock:
            if sensor_id not in self._buffers:
                self._buffers[sensor_id] = deque(maxlen=self._max_readings)
            self._buffers[sensor_id].append(reading)

    def get_readings(
        self,
        sensor_id: str,
        count: Optional[int] = None,
    ) -> List[SensorReading]:
        """Get recent readings for a sensor."""
        with self._lock:
            if sensor_id not in self._buffers:
                return []

            readings = list(self._buffers[sensor_id])
            if count is not None:
                return readings[-count:]
            return readings

    def get_latest(self, sensor_id: str) -> Optional[SensorReading]:
        """Get the most recent reading for a sensor."""
        readings = self.get_readings(sensor_id, count=1)
        return readings[0] if readings else None

    def clear(self, sensor_id: Optional[str] = None) -> None:
        """Clear buffer for a sensor or all sensors."""
        with self._lock:
            if sensor_id:
                self._buffers.pop(sensor_id, None)
            else:
                self._buffers.clear()


# =============================================================================
# DATA AGGREGATOR
# =============================================================================

class DataAggregator:
    """
    Aggregates sensor readings for analysis and storage.

    Performs time-windowed aggregation (average, min, max) for
    efficient storage and trend analysis.
    """

    def __init__(self, window_minutes: int = 15) -> None:
        """
        Initialize data aggregator.

        Args:
            window_minutes: Aggregation window size
        """
        self.window_minutes = window_minutes
        self._aggregation_count = 0

    def aggregate_ultrasonic(
        self,
        readings: List[UltrasonicReading],
    ) -> Optional[UltrasonicReading]:
        """
        Aggregate ultrasonic readings into single reading.

        Args:
            readings: List of readings to aggregate

        Returns:
            Aggregated UltrasonicReading
        """
        if not readings:
            return None

        self._aggregation_count += 1

        # Calculate statistics
        db_values = [r.decibel_level_db for r in readings]
        avg_db = sum(db_values) / len(db_values)
        max_db = max(db_values)

        # Determine cycling/continuous from any reading
        cycling = any(r.cycling_detected for r in readings)
        continuous = any(r.continuous_flow_detected for r in readings)

        # Use latest timestamp
        latest_time = max(r.timestamp for r in readings)

        return UltrasonicReading(
            sensor_id=readings[0].sensor_id,
            timestamp=latest_time,
            decibel_level_db=round(avg_db, 1),
            frequency_khz=readings[0].frequency_khz,
            peak_amplitude=max_db,
            rms_amplitude=avg_db,
            cycling_detected=cycling,
            continuous_flow_detected=continuous,
            quality_score=sum(r.quality_score for r in readings) / len(readings),
        )

    def aggregate_temperature(
        self,
        readings: List[TemperatureReading],
    ) -> Optional[TemperatureReading]:
        """
        Aggregate temperature readings into single reading.

        Args:
            readings: List of readings to aggregate

        Returns:
            Aggregated TemperatureReading
        """
        if not readings:
            return None

        self._aggregation_count += 1

        # Calculate averages
        inlet_temps = [r.inlet_temp_f for r in readings]
        outlet_temps = [r.outlet_temp_f for r in readings]
        avg_inlet = sum(inlet_temps) / len(inlet_temps)
        avg_outlet = sum(outlet_temps) / len(outlet_temps)

        # Use latest timestamp
        latest_time = max(r.timestamp for r in readings)

        return TemperatureReading(
            sensor_id=readings[0].sensor_id,
            timestamp=latest_time,
            inlet_temp_f=round(avg_inlet, 1),
            outlet_temp_f=round(avg_outlet, 1),
            delta_t_f=round(avg_inlet - avg_outlet, 1),
            quality_score=sum(r.quality_score for r in readings) / len(readings),
        )

    @property
    def aggregation_count(self) -> int:
        """Get aggregation count."""
        return self._aggregation_count


# =============================================================================
# SENSOR HEALTH MONITOR
# =============================================================================

class SensorHealthMonitor:
    """
    Monitors health of wireless sensors.

    Tracks battery levels, signal strength, reading frequency,
    and generates alerts for sensor issues.
    """

    def __init__(self, config: WirelessSensorConfig) -> None:
        """
        Initialize health monitor.

        Args:
            config: Wireless sensor configuration
        """
        self.config = config
        self._sensor_health: Dict[str, SensorHealth] = {}
        self._alerts: List[SensorAlert] = []
        self._lock = threading.RLock()
        self._alert_callbacks: List[Callable[[SensorAlert], None]] = []

    def register_sensor(
        self,
        sensor_id: str,
        initial_battery: Optional[float] = None,
        initial_signal: Optional[float] = None,
    ) -> None:
        """Register a sensor for health monitoring."""
        with self._lock:
            self._sensor_health[sensor_id] = SensorHealth(
                sensor_id=sensor_id,
                status=SensorStatus.ONLINE,
                battery_level_pct=initial_battery,
                signal_strength_dbm=initial_signal,
            )

    def update_sensor_health(
        self,
        sensor_id: str,
        battery_level: Optional[float] = None,
        signal_strength: Optional[float] = None,
        reading_time: Optional[datetime] = None,
    ) -> None:
        """Update sensor health metrics."""
        with self._lock:
            if sensor_id not in self._sensor_health:
                self.register_sensor(sensor_id, battery_level, signal_strength)

            health = self._sensor_health[sensor_id]

            if battery_level is not None:
                health.battery_level_pct = battery_level
                # Check for low battery
                if battery_level < self.config.battery_low_threshold_pct:
                    self._create_alert(
                        sensor_id=sensor_id,
                        severity=AlertSeverity.WARNING,
                        alert_type="low_battery",
                        message=f"Sensor {sensor_id} battery low: {battery_level:.0f}%",
                    )
                    health.status = SensorStatus.LOW_BATTERY

            if signal_strength is not None:
                health.signal_strength_dbm = signal_strength
                # Check for weak signal
                if signal_strength < self.config.signal_low_threshold_dbm:
                    self._create_alert(
                        sensor_id=sensor_id,
                        severity=AlertSeverity.WARNING,
                        alert_type="weak_signal",
                        message=f"Sensor {sensor_id} signal weak: {signal_strength:.0f} dBm",
                    )
                    health.status = SensorStatus.WEAK_SIGNAL

            if reading_time is not None:
                health.last_reading_time = reading_time
                health.readings_last_24h += 1

    def check_offline_sensors(self) -> List[str]:
        """
        Check for sensors that have gone offline.

        Returns:
            List of offline sensor IDs
        """
        offline_sensors = []
        now = datetime.now(timezone.utc)
        offline_threshold = timedelta(minutes=self.config.offline_alert_minutes)

        with self._lock:
            for sensor_id, health in self._sensor_health.items():
                if health.last_reading_time is None:
                    continue

                time_since_reading = now - health.last_reading_time

                if time_since_reading > offline_threshold:
                    if health.status != SensorStatus.OFFLINE:
                        health.status = SensorStatus.OFFLINE
                        offline_sensors.append(sensor_id)
                        self._create_alert(
                            sensor_id=sensor_id,
                            severity=AlertSeverity.CRITICAL,
                            alert_type="offline",
                            message=f"Sensor {sensor_id} offline for "
                                    f"{time_since_reading.total_seconds() / 60:.0f} minutes",
                        )

        return offline_sensors

    def get_sensor_health(
        self,
        sensor_id: str,
    ) -> Optional[SensorHealth]:
        """Get health information for a sensor."""
        return self._sensor_health.get(sensor_id)

    def get_all_sensor_health(self) -> Dict[str, SensorHealth]:
        """Get health information for all sensors."""
        return dict(self._sensor_health)

    def get_sensors_by_status(
        self,
        status: SensorStatus,
    ) -> List[str]:
        """Get sensors with a specific status."""
        return [
            sensor_id for sensor_id, health in self._sensor_health.items()
            if health.status == status
        ]

    def get_alerts(
        self,
        unacknowledged_only: bool = False,
    ) -> List[SensorAlert]:
        """Get sensor alerts."""
        with self._lock:
            if unacknowledged_only:
                return [a for a in self._alerts if not a.acknowledged]
            return list(self._alerts)

    def acknowledge_alert(
        self,
        alert_id: str,
        acknowledged_by: str,
    ) -> bool:
        """Acknowledge an alert."""
        with self._lock:
            for alert in self._alerts:
                if alert.alert_id == alert_id:
                    alert.acknowledged = True
                    alert.acknowledged_by = acknowledged_by
                    alert.acknowledged_time = datetime.now(timezone.utc)
                    return True
        return False

    def register_alert_callback(
        self,
        callback: Callable[[SensorAlert], None],
    ) -> None:
        """Register callback for new alerts."""
        self._alert_callbacks.append(callback)

    def _create_alert(
        self,
        sensor_id: str,
        severity: AlertSeverity,
        alert_type: str,
        message: str,
    ) -> None:
        """Create and store an alert."""
        alert = SensorAlert(
            alert_id=hashlib.md5(
                f"{sensor_id}{alert_type}{datetime.now().isoformat()}".encode()
            ).hexdigest()[:12],
            sensor_id=sensor_id,
            severity=severity,
            alert_type=alert_type,
            message=message,
            timestamp=datetime.now(timezone.utc),
        )

        with self._lock:
            self._alerts.append(alert)

        # Notify callbacks
        for callback in self._alert_callbacks:
            try:
                callback(alert)
            except Exception as e:
                logger.error(f"Alert callback error: {e}")

        logger.info(f"Sensor alert: {alert.message}")


# =============================================================================
# SENSOR DATA COLLECTOR
# =============================================================================

class SensorDataCollector:
    """
    Collects data from wireless sensors.

    Manages data retrieval, buffering, and aggregation for
    all sensors in the network.
    """

    def __init__(
        self,
        network: "WirelessSensorNetwork",
    ) -> None:
        """
        Initialize data collector.

        Args:
            network: Wireless sensor network
        """
        self._network = network
        self._buffer = SensorReadingBuffer()
        self._aggregator = DataAggregator()
        self._collection_count = 0

    def collect_reading(
        self,
        sensor_id: str,
        reading: SensorReading,
    ) -> None:
        """
        Collect a reading from a sensor.

        Args:
            sensor_id: Sensor identifier
            reading: Sensor reading
        """
        self._collection_count += 1
        self._buffer.add_reading(sensor_id, reading)

        # Update sensor health
        self._network.health_monitor.update_sensor_health(
            sensor_id=sensor_id,
            reading_time=reading.timestamp,
        )

    def get_latest_readings(
        self,
        trap_id: str,
    ) -> Tuple[List[UltrasonicReading], List[TemperatureReading]]:
        """
        Get latest readings for a trap.

        Args:
            trap_id: Trap identifier

        Returns:
            Tuple of (ultrasonic_readings, temperature_readings)
        """
        # Get sensors associated with trap
        sensors = self._network.get_sensors_for_trap(trap_id)

        ultrasonic = []
        temperature = []

        for sensor_id in sensors:
            reading = self._buffer.get_latest(sensor_id)
            if reading is None:
                continue

            if isinstance(reading, UltrasonicReading):
                ultrasonic.append(reading)
            elif isinstance(reading, TemperatureReading):
                temperature.append(reading)

        return ultrasonic, temperature

    def get_aggregated_readings(
        self,
        trap_id: str,
        time_window_minutes: int = 15,
    ) -> Tuple[Optional[UltrasonicReading], Optional[TemperatureReading]]:
        """
        Get aggregated readings for a trap.

        Args:
            trap_id: Trap identifier
            time_window_minutes: Aggregation window

        Returns:
            Tuple of (aggregated_ultrasonic, aggregated_temperature)
        """
        sensors = self._network.get_sensors_for_trap(trap_id)
        cutoff = datetime.now(timezone.utc) - timedelta(minutes=time_window_minutes)

        ultrasonic_readings = []
        temperature_readings = []

        for sensor_id in sensors:
            readings = self._buffer.get_readings(sensor_id)

            for reading in readings:
                if reading.timestamp < cutoff:
                    continue

                if isinstance(reading, UltrasonicReading):
                    ultrasonic_readings.append(reading)
                elif isinstance(reading, TemperatureReading):
                    temperature_readings.append(reading)

        # Aggregate
        agg_ultrasonic = self._aggregator.aggregate_ultrasonic(ultrasonic_readings)
        agg_temperature = self._aggregator.aggregate_temperature(temperature_readings)

        return agg_ultrasonic, agg_temperature

    @property
    def collection_count(self) -> int:
        """Get collection count."""
        return self._collection_count


# =============================================================================
# WIRELESS SENSOR NETWORK
# =============================================================================

class WirelessSensorNetwork:
    """
    Wireless sensor network for steam trap monitoring.

    Manages wireless sensors, data collection, health monitoring,
    and integration with trap monitoring system.

    Supports protocols:
    - LoRaWAN (long range, low power)
    - ZigBee (mesh networking)
    - WiFi (high bandwidth)
    - WirelessHART (industrial)

    Example:
        >>> config = WirelessSensorConfig(protocol="LoRaWAN")
        >>> network = WirelessSensorNetwork(config)
        >>> network.register_sensor("SENSOR-001", trap_id="ST-001")
        >>> collector = SensorDataCollector(network)
    """

    def __init__(self, config: WirelessSensorConfig) -> None:
        """
        Initialize wireless sensor network.

        Args:
            config: Wireless sensor configuration
        """
        self.config = config
        self._sensors: Dict[str, SensorConfig] = {}
        self._trap_to_sensors: Dict[str, List[str]] = {}
        self._health_monitor = SensorHealthMonitor(config)
        self._lock = threading.RLock()

        logger.info(
            f"WirelessSensorNetwork initialized with {config.protocol} protocol"
        )

    def register_sensor(
        self,
        sensor_id: str,
        trap_id: str,
        sensor_type: SensorType,
        **kwargs,
    ) -> None:
        """
        Register a sensor in the network.

        Args:
            sensor_id: Unique sensor identifier
            trap_id: Associated trap identifier
            sensor_type: Type of sensor
            **kwargs: Additional sensor configuration
        """
        with self._lock:
            sensor_config = SensorConfig(
                sensor_id=sensor_id,
                sensor_type=sensor_type,
                **kwargs,
            )
            self._sensors[sensor_id] = sensor_config

            # Map sensor to trap
            if trap_id not in self._trap_to_sensors:
                self._trap_to_sensors[trap_id] = []
            self._trap_to_sensors[trap_id].append(sensor_id)

            # Register for health monitoring
            self._health_monitor.register_sensor(
                sensor_id,
                initial_battery=kwargs.get("battery_level_pct"),
                initial_signal=kwargs.get("signal_strength_dbm"),
            )

        logger.debug(f"Registered sensor {sensor_id} for trap {trap_id}")

    def get_sensor(self, sensor_id: str) -> Optional[SensorConfig]:
        """Get sensor configuration."""
        return self._sensors.get(sensor_id)

    def get_sensors_for_trap(self, trap_id: str) -> List[str]:
        """Get sensor IDs associated with a trap."""
        return self._trap_to_sensors.get(trap_id, [])

    def get_all_sensors(self) -> Dict[str, SensorConfig]:
        """Get all registered sensors."""
        return dict(self._sensors)

    def get_network_status(self) -> Dict[str, Any]:
        """
        Get overall network status.

        Returns:
            Network status summary
        """
        online = len(self._health_monitor.get_sensors_by_status(SensorStatus.ONLINE))
        offline = len(self._health_monitor.get_sensors_by_status(SensorStatus.OFFLINE))
        low_battery = len(self._health_monitor.get_sensors_by_status(SensorStatus.LOW_BATTERY))
        weak_signal = len(self._health_monitor.get_sensors_by_status(SensorStatus.WEAK_SIGNAL))

        total = len(self._sensors)

        return {
            "total_sensors": total,
            "online": online,
            "offline": offline,
            "low_battery": low_battery,
            "weak_signal": weak_signal,
            "health_rate": online / total if total > 0 else 0.0,
            "protocol": self.config.protocol,
            "gateway_ip": self.config.gateway_ip,
            "unacknowledged_alerts": len(
                self._health_monitor.get_alerts(unacknowledged_only=True)
            ),
        }

    @property
    def health_monitor(self) -> SensorHealthMonitor:
        """Get health monitor."""
        return self._health_monitor

    @property
    def sensor_count(self) -> int:
        """Get registered sensor count."""
        return len(self._sensors)
