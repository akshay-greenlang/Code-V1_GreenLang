# -*- coding: utf-8 -*-
"""
Agent Intelligence Interface (AII) - Mandatory Contract for AI-Native Agents

This module defines the MANDATORY interface that all GreenLang agents MUST
implement to be considered "intelligent". The AI Factory MUST generate agents
that conform to this interface.

PURPOSE:
- Solve the "Intelligence Paradox" by mandating LLM integration
- Provide a clear contract for what "intelligent" means
- Enable validation of agent intelligence capabilities
- Support automated testing of intelligence features

MANDATORY vs OPTIONAL:
- MANDATORY: generate_explanation() - ALL agents must explain their outputs
- MANDATORY: get_intelligence_level() - ALL agents must declare their level
- OPTIONAL: generate_recommendations() - For agents that provide advice
- OPTIONAL: detect_anomalies() - For agents that monitor data quality
- OPTIONAL: reason_about() - For agents with general reasoning needs

VALIDATION:
The AgentIntelligenceValidator class verifies that agents properly implement
this interface. The AI Factory MUST use this validator before accepting
any new agent.

Author: GreenLang Intelligence Framework
Date: December 2025
Status: Production - MANDATORY for all new agents
"""

from __future__ import annotations
from abc import ABC, abstractmethod
from enum import Enum
from typing import Any, Dict, List, Optional, Protocol, runtime_checkable
from pydantic import BaseModel, Field
import logging

logger = logging.getLogger(__name__)


class IntelligenceLevel(str, Enum):
    """
    Intelligence levels for GreenLang agents.

    NONE: DEPRECATED - Not allowed for new agents (existing only)
    BASIC: Minimum - explanation generation only
    STANDARD: Default - explanations + recommendations
    ADVANCED: Full - reasoning, anomaly detection, RAG
    FULL: Maximum - all capabilities including chain-of-thought
    """
    NONE = "none"  # DEPRECATED - Existing agents only
    BASIC = "basic"
    STANDARD = "standard"
    ADVANCED = "advanced"
    FULL = "full"


class IntelligenceCapabilities(BaseModel):
    """Capabilities an intelligent agent provides."""
    can_explain: bool = Field(True, description="Can generate explanations")
    can_recommend: bool = Field(False, description="Can generate recommendations")
    can_detect_anomalies: bool = Field(False, description="Can detect anomalies")
    can_reason: bool = Field(False, description="Can do general reasoning")
    can_validate: bool = Field(False, description="Can validate with reasoning")
    uses_rag: bool = Field(False, description="Uses RAG for domain knowledge")
    uses_tools: bool = Field(False, description="Uses LLM tool calling")


@runtime_checkable
class IntelligentAgent(Protocol):
    """
    Protocol defining the MANDATORY interface for intelligent agents.

    All agents generated by the AI Factory MUST implement this protocol.
    Existing agents being retrofitted MUST add these methods.

    This is enforced by AgentIntelligenceValidator.
    """

    def get_intelligence_level(self) -> IntelligenceLevel:
        """
        Return the agent's intelligence level.

        MANDATORY: All agents must implement this.

        Returns:
            IntelligenceLevel enum value
        """
        ...

    def get_intelligence_capabilities(self) -> IntelligenceCapabilities:
        """
        Return the agent's intelligence capabilities.

        MANDATORY: All agents must implement this.

        Returns:
            IntelligenceCapabilities instance
        """
        ...

    def generate_explanation(
        self,
        input_data: Dict[str, Any],
        output_data: Dict[str, Any],
        calculation_steps: Optional[List[str]] = None
    ) -> str:
        """
        Generate a natural language explanation.

        MANDATORY: All agents must implement this.

        Args:
            input_data: Input provided to the agent
            output_data: Output from the agent
            calculation_steps: Optional list of calculation steps

        Returns:
            Natural language explanation string
        """
        ...


@runtime_checkable
class RecommendingAgent(Protocol):
    """Protocol for agents that can generate recommendations."""

    def generate_recommendations(
        self,
        analysis: Dict[str, Any],
        max_recommendations: int = 5,
        focus_areas: Optional[List[str]] = None
    ) -> List[Dict[str, Any]]:
        """Generate actionable recommendations."""
        ...


@runtime_checkable
class AnomalyDetectingAgent(Protocol):
    """Protocol for agents that can detect anomalies."""

    def detect_anomalies(
        self,
        data: Dict[str, Any],
        expected_ranges: Optional[Dict[str, tuple]] = None
    ) -> List[Dict[str, Any]]:
        """Detect anomalies in data."""
        ...


@runtime_checkable
class ReasoningAgent(Protocol):
    """Protocol for agents that can do general reasoning."""

    def reason_about(
        self,
        question: str,
        context: Dict[str, Any],
        chain_of_thought: bool = False
    ) -> str:
        """Reason about a question given context."""
        ...


@runtime_checkable
class ValidatingAgent(Protocol):
    """Protocol for agents that can validate with reasoning."""

    def validate_with_reasoning(
        self,
        input_data: Dict[str, Any],
        rules: Optional[List[str]] = None
    ) -> tuple[bool, str]:
        """Validate input with LLM reasoning."""
        ...


# =============================================================================
# VALIDATION
# =============================================================================

class ValidationResult(BaseModel):
    """Result of agent intelligence validation."""
    is_valid: bool = Field(..., description="Whether agent passes validation")
    agent_name: str = Field(..., description="Name of validated agent")
    intelligence_level: Optional[IntelligenceLevel] = Field(None, description="Agent's intelligence level")
    capabilities: Optional[IntelligenceCapabilities] = Field(None, description="Agent's capabilities")
    errors: List[str] = Field(default_factory=list, description="Validation errors")
    warnings: List[str] = Field(default_factory=list, description="Validation warnings")
    recommendations: List[str] = Field(default_factory=list, description="Improvement recommendations")


class AgentIntelligenceValidator:
    """
    Validates that agents properly implement intelligence interfaces.

    This validator is used by:
    1. AI Factory - Before accepting generated agents
    2. CI/CD Pipeline - To ensure all agents are intelligent
    3. Runtime - To verify agent capabilities before use

    Usage:
        validator = AgentIntelligenceValidator()
        result = validator.validate(my_agent)

        if not result.is_valid:
            raise ValueError(f"Agent not intelligent: {result.errors}")
    """

    # Minimum required intelligence level for new agents
    MINIMUM_LEVEL = IntelligenceLevel.BASIC

    # Methods that MUST exist
    MANDATORY_METHODS = [
        'get_intelligence_level',
        'get_intelligence_capabilities',
        'generate_explanation'
    ]

    # Methods for each intelligence level
    LEVEL_REQUIREMENTS = {
        IntelligenceLevel.NONE: [],  # DEPRECATED
        IntelligenceLevel.BASIC: ['generate_explanation'],
        IntelligenceLevel.STANDARD: ['generate_explanation', 'generate_recommendations'],
        IntelligenceLevel.ADVANCED: [
            'generate_explanation',
            'generate_recommendations',
            'detect_anomalies',
            'reason_about'
        ],
        IntelligenceLevel.FULL: [
            'generate_explanation',
            'generate_recommendations',
            'detect_anomalies',
            'reason_about',
            'validate_with_reasoning'
        ]
    }

    def validate(
        self,
        agent: Any,
        allow_none_level: bool = False,
        strict: bool = True
    ) -> ValidationResult:
        """
        Validate an agent's intelligence implementation.

        Args:
            agent: The agent instance to validate
            allow_none_level: Allow NONE intelligence (for existing agents)
            strict: If True, fail on warnings too

        Returns:
            ValidationResult with pass/fail and details
        """
        errors = []
        warnings = []
        recommendations = []

        agent_name = getattr(agent, '__class__', type(agent)).__name__

        # Check mandatory methods exist
        for method in self.MANDATORY_METHODS:
            if not hasattr(agent, method) or not callable(getattr(agent, method)):
                errors.append(f"Missing mandatory method: {method}")

        # If mandatory methods missing, can't continue
        if errors:
            return ValidationResult(
                is_valid=False,
                agent_name=agent_name,
                errors=errors,
                warnings=warnings,
                recommendations=["Implement IntelligentAgent interface"]
            )

        # Get intelligence level
        try:
            level = agent.get_intelligence_level()
            if not isinstance(level, IntelligenceLevel):
                errors.append(f"get_intelligence_level must return IntelligenceLevel enum, got {type(level)}")
                level = None
        except Exception as e:
            errors.append(f"get_intelligence_level() raised exception: {e}")
            level = None

        # Check if NONE level is allowed
        if level == IntelligenceLevel.NONE:
            if not allow_none_level:
                errors.append(
                    "Intelligence level NONE is DEPRECATED. "
                    "New agents must have at least BASIC intelligence."
                )
            else:
                warnings.append(
                    "Agent uses DEPRECATED NONE intelligence level. "
                    "Consider retrofitting with IntelligenceMixin."
                )

        # Get capabilities
        try:
            capabilities = agent.get_intelligence_capabilities()
            if not isinstance(capabilities, IntelligenceCapabilities):
                errors.append(f"get_intelligence_capabilities must return IntelligenceCapabilities")
                capabilities = None
        except Exception as e:
            errors.append(f"get_intelligence_capabilities() raised exception: {e}")
            capabilities = None

        # Check level-specific requirements
        if level and level in self.LEVEL_REQUIREMENTS:
            required_methods = self.LEVEL_REQUIREMENTS[level]
            for method in required_methods:
                if not hasattr(agent, method) or not callable(getattr(agent, method)):
                    errors.append(
                        f"Intelligence level {level.value} requires method: {method}"
                    )

        # Check capabilities match declared level
        if level and capabilities:
            if level == IntelligenceLevel.BASIC and not capabilities.can_explain:
                errors.append("BASIC level must have can_explain=True")
            if level == IntelligenceLevel.STANDARD:
                if not capabilities.can_explain:
                    errors.append("STANDARD level must have can_explain=True")
                if not capabilities.can_recommend:
                    warnings.append("STANDARD level should have can_recommend=True")
            if level in [IntelligenceLevel.ADVANCED, IntelligenceLevel.FULL]:
                if not capabilities.can_reason:
                    warnings.append(f"{level.value} level should have can_reason=True")

        # Test that generate_explanation actually works
        try:
            test_input = {"test": "input"}
            test_output = {"test": "output"}
            explanation = agent.generate_explanation(test_input, test_output)
            if not explanation or not isinstance(explanation, str):
                errors.append("generate_explanation must return non-empty string")
            elif len(explanation) < 10:
                warnings.append("generate_explanation returned very short response")
        except Exception as e:
            errors.append(f"generate_explanation() failed: {e}")

        # Add recommendations
        if level == IntelligenceLevel.BASIC:
            recommendations.append(
                "Consider upgrading to STANDARD level for recommendations"
            )
        if capabilities and not capabilities.can_detect_anomalies:
            recommendations.append(
                "Consider enabling anomaly detection for data quality"
            )

        # Determine validity
        is_valid = len(errors) == 0
        if strict and warnings:
            is_valid = False

        return ValidationResult(
            is_valid=is_valid,
            agent_name=agent_name,
            intelligence_level=level,
            capabilities=capabilities,
            errors=errors,
            warnings=warnings,
            recommendations=recommendations
        )

    def validate_class(
        self,
        agent_class: type,
        allow_none_level: bool = False
    ) -> ValidationResult:
        """
        Validate an agent class (not instance).

        Args:
            agent_class: The agent class to validate
            allow_none_level: Allow NONE intelligence

        Returns:
            ValidationResult
        """
        errors = []
        warnings = []

        class_name = agent_class.__name__

        # Check mandatory methods exist on class
        for method in self.MANDATORY_METHODS:
            if not hasattr(agent_class, method):
                errors.append(f"Class missing method: {method}")

        # Check if class inherits from proper base
        from greenlang.agents.intelligent_base import IntelligentAgentBase
        from greenlang.agents.intelligence_mixin import IntelligenceMixin
        from greenlang.agents.base import BaseAgent

        has_intelligence = (
            issubclass(agent_class, IntelligentAgentBase) or
            IntelligenceMixin in agent_class.__mro__
        )

        if not has_intelligence:
            if issubclass(agent_class, BaseAgent):
                errors.append(
                    f"{class_name} extends BaseAgent but not IntelligentAgentBase. "
                    "New agents must use IntelligentAgentBase or IntelligenceMixin."
                )
            else:
                errors.append(
                    f"{class_name} does not inherit from IntelligentAgentBase or use IntelligenceMixin"
                )

        return ValidationResult(
            is_valid=len(errors) == 0,
            agent_name=class_name,
            errors=errors,
            warnings=warnings,
            recommendations=["Extend IntelligentAgentBase instead of BaseAgent"]
        )


# =============================================================================
# FACTORY ENFORCEMENT
# =============================================================================

def require_intelligence(agent_class: type) -> type:
    """
    Class decorator that enforces intelligence requirements.

    Use this decorator on agent classes to ensure they meet
    intelligence requirements at definition time.

    Usage:
        @require_intelligence
        class MyAgent(IntelligentAgentBase):
            ...
    """
    validator = AgentIntelligenceValidator()
    result = validator.validate_class(agent_class)

    if not result.is_valid:
        error_msg = f"Agent {agent_class.__name__} failed intelligence validation:\n"
        error_msg += "\n".join(f"  - {e}" for e in result.errors)
        raise TypeError(error_msg)

    # Add validated marker
    agent_class._intelligence_validated = True

    return agent_class


def is_intelligent_agent(obj: Any) -> bool:
    """
    Check if an object is an intelligent agent.

    Args:
        obj: Object to check

    Returns:
        True if object implements IntelligentAgent protocol
    """
    return isinstance(obj, IntelligentAgent)


def get_agent_intelligence_level(agent: Any) -> Optional[IntelligenceLevel]:
    """
    Get an agent's intelligence level.

    Args:
        agent: Agent instance

    Returns:
        IntelligenceLevel or None if not intelligent
    """
    if hasattr(agent, 'get_intelligence_level'):
        try:
            return agent.get_intelligence_level()
        except Exception:
            pass
    return None


# =============================================================================
# DEFAULT IMPLEMENTATIONS
# =============================================================================

class IntelligenceDefaults:
    """Default implementations for intelligence methods."""

    @staticmethod
    def get_intelligence_level() -> IntelligenceLevel:
        """Default: BASIC level."""
        return IntelligenceLevel.BASIC

    @staticmethod
    def get_intelligence_capabilities() -> IntelligenceCapabilities:
        """Default capabilities for BASIC level."""
        return IntelligenceCapabilities(
            can_explain=True,
            can_recommend=False,
            can_detect_anomalies=False,
            can_reason=False,
            can_validate=False,
            uses_rag=False,
            uses_tools=False
        )

    @staticmethod
    def generate_explanation(
        input_data: Dict[str, Any],
        output_data: Dict[str, Any],
        calculation_steps: Optional[List[str]] = None
    ) -> str:
        """
        Fallback explanation when LLM is unavailable.

        This generates a basic structured explanation without LLM.
        """
        parts = [
            "Calculation Summary:",
            "",
            f"Input: {input_data}",
            f"Output: {output_data}"
        ]

        if calculation_steps:
            parts.extend(["", "Steps:"])
            parts.extend(f"  {i+1}. {step}" for i, step in enumerate(calculation_steps))

        return "\n".join(parts)


# =============================================================================
# EXPORTS
# =============================================================================

__all__ = [
    'IntelligenceLevel',
    'IntelligenceCapabilities',
    'IntelligentAgent',
    'RecommendingAgent',
    'AnomalyDetectingAgent',
    'ReasoningAgent',
    'ValidatingAgent',
    'ValidationResult',
    'AgentIntelligenceValidator',
    'require_intelligence',
    'is_intelligent_agent',
    'get_agent_intelligence_level',
    'IntelligenceDefaults',
]
