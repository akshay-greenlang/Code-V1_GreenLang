"""
GL-016 WaterGuard - Prometheus Metrics
========================================================

Provides Prometheus metrics for the agent.

Metrics:
- Counters: calculations_total, errors_total
- Histograms: calculation_duration_seconds
- Gauges: active_calculations

Generated by GreenLang Enhancement Script
"""

import logging
import time
from contextlib import contextmanager
from dataclasses import dataclass, field
from datetime import datetime
from typing import Dict, List, Optional

logger = logging.getLogger(__name__)

# Agent configuration
AGENT_ID = "GL-016"
AGENT_NAME = "WaterGuard"

# Try to import prometheus_client
try:
    from prometheus_client import Counter, Histogram, Gauge, generate_latest
    PROMETHEUS_AVAILABLE = True
except ImportError:
    PROMETHEUS_AVAILABLE = False
    logger.warning("prometheus_client not installed. Using fallback metrics.")


@dataclass
class MetricRecord:
    """Fallback metric record."""
    name: str
    value: float
    labels: Dict[str, str] = field(default_factory=dict)
    timestamp: datetime = field(default_factory=datetime.now)


class MetricsManager:
    """
    Manages Prometheus metrics for GL-016.

    Provides metric collection with fallback for environments
    without prometheus_client.
    """

    def __init__(self):
        self.records: List[MetricRecord] = []

        if PROMETHEUS_AVAILABLE:
            self._setup_prometheus()
        else:
            self._counters: Dict[str, float] = {}
            self._histograms: Dict[str, List[float]] = {}
            self._gauges: Dict[str, float] = {}

    def _setup_prometheus(self):
        """Setup Prometheus metrics."""
        # Counters
        self.calculations_total = Counter(
            'calculations_total',
            'Total calculations performed',
            ['agent_id', 'calculation_type']
        )

        self.errors_total = Counter(
            'errors_total',
            'Total errors encountered',
            ['agent_id', 'error_type']
        )

        # Histograms
        self.calculation_duration = Histogram(
            'calculation_duration_seconds',
            'Duration of calculations',
            ['agent_id', 'calculation_type'],
            buckets=[0.01, 0.05, 0.1, 0.25, 0.5, 1.0, 2.5, 5.0, 10.0]
        )

        # Gauges
        self.active_calculations = Gauge(
            'active_calculations',
            'Number of active calculations',
            ['agent_id']
        )

        logger.info(f"Initialized Prometheus metrics for {AGENT_ID}")

    def inc_counter(
        self,
        name: str,
        labels: Optional[Dict[str, str]] = None,
        value: float = 1.0
    ):
        """Increment a counter."""
        labels = labels or {}
        labels.setdefault("agent_id", AGENT_ID)

        if PROMETHEUS_AVAILABLE:
            if name == "calculations":
                self.calculations_total.labels(**labels).inc(value)
            elif name == "errors":
                self.errors_total.labels(**labels).inc(value)
        else:
            key = f"{name}:{labels}"
            self._counters[key] = self._counters.get(key, 0) + value

    def observe_histogram(
        self,
        name: str,
        value: float,
        labels: Optional[Dict[str, str]] = None
    ):
        """Record a histogram observation."""
        labels = labels or {}
        labels.setdefault("agent_id", AGENT_ID)

        if PROMETHEUS_AVAILABLE:
            if name == "calculation_duration":
                self.calculation_duration.labels(**labels).observe(value)
        else:
            key = f"{name}:{labels}"
            if key not in self._histograms:
                self._histograms[key] = []
            self._histograms[key].append(value)

    def set_gauge(
        self,
        name: str,
        value: float,
        labels: Optional[Dict[str, str]] = None
    ):
        """Set a gauge value."""
        labels = labels or {}
        labels.setdefault("agent_id", AGENT_ID)

        if PROMETHEUS_AVAILABLE:
            if name == "active_calculations":
                self.active_calculations.labels(**labels).set(value)
        else:
            key = f"{name}:{labels}"
            self._gauges[key] = value

    @contextmanager
    def measure_duration(
        self,
        calculation_type: str = "default"
    ):
        """
        Context manager for measuring calculation duration.

        Example:
            with metrics.measure_duration("efficiency"):
                result = calculate_efficiency(data)
        """
        start = time.time()
        self.set_gauge("active_calculations", 1)

        try:
            yield
            self.inc_counter("calculations", {"calculation_type": calculation_type})
        except Exception:
            self.inc_counter("errors", {"error_type": calculation_type})
            raise
        finally:
            duration = time.time() - start
            self.observe_histogram(
                "calculation_duration",
                duration,
                {"calculation_type": calculation_type}
            )
            self.set_gauge("active_calculations", 0)

    def get_metrics(self) -> str:
        """Get metrics in Prometheus format."""
        if PROMETHEUS_AVAILABLE:
            return generate_latest().decode('utf-8')
        else:
            # Fallback text format
            lines = []
            for key, value in self._counters.items():
                lines.append(f"{key} {value}")
            for key, values in self._histograms.items():
                avg = sum(values) / len(values) if values else 0
                lines.append(f"{key}_avg {avg}")
            for key, value in self._gauges.items():
                lines.append(f"{key} {value}")
            return "\n".join(lines)


# Global metrics instance
_metrics: Optional[MetricsManager] = None


def get_metrics() -> MetricsManager:
    """Get or create the global metrics instance."""
    global _metrics
    if _metrics is None:
        _metrics = MetricsManager()
    return _metrics


__all__ = [
    "MetricsManager",
    "get_metrics",
]
