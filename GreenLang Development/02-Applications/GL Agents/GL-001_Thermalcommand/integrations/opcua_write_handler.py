# -*- coding: utf-8 -*-
"""
OPC-UA Write Handler with Safety Gates for GL-001 ThermalCommand

This module implements a secure write path for OPC-UA supervisory tags with:
- Whitelisted supervisory tags only
- Two-step confirmation (recommendation + apply)
- Safety boundary validation before write
- Rate limiting on writes
- Complete audit trail with SHA-256 provenance

Safety Features:
- Pre-write safety boundary validation
- Interlock checking before write execution
- Rate of change limiting
- Operator confirmation workflow
- Emergency stop integration

Compliance:
- IEC 62443 (Industrial Cybersecurity)
- ISA-95/ISA-88 (Industrial Automation)
- Site OT cybersecurity standards

Author: GL-BackendDeveloper
Version: 1.0.0
"""

import asyncio
import hashlib
import json
import logging
import time
import uuid
from collections import deque
from dataclasses import dataclass, field
from datetime import datetime, timezone, timedelta
from enum import Enum
from typing import Any, Callable, Dict, List, Optional, Set, Tuple

from pydantic import BaseModel, Field, validator

from integrations.opcua_schemas import (
    OPCUAWriteRequest,
    OPCUAWriteResponse,
    OPCUADataPoint,
    OPCUATagConfig,
    SafetyBoundary,
    TagMetadata,
    TagAccessLevel,
    WriteConfirmationStatus,
)
from integrations.opcua_connector import OPCUAConnector

logger = logging.getLogger(__name__)


# =============================================================================
# ENUMS AND CONSTANTS
# =============================================================================

class SafetyCheckResult(str, Enum):
    """Result of safety validation check."""
    PASSED = "passed"
    FAILED = "failed"
    WARNING = "warning"
    INTERLOCK_ACTIVE = "interlock_active"
    RATE_LIMITED = "rate_limited"


class WriteRecommendationType(str, Enum):
    """Type of write recommendation."""
    OPTIMIZATION = "optimization"
    SAFETY = "safety"
    EFFICIENCY = "efficiency"
    MAINTENANCE = "maintenance"
    OPERATOR_REQUEST = "operator_request"


# Default limits
DEFAULT_WRITE_RATE_LIMIT_PER_MINUTE = 10
DEFAULT_CONFIRMATION_TIMEOUT_S = 300  # 5 minutes
DEFAULT_MAX_PENDING_WRITES = 100
MIN_WRITE_INTERVAL_MS = 100  # 100ms minimum between writes


# =============================================================================
# WRITE RECOMMENDATION
# =============================================================================

class WriteRecommendation(BaseModel):
    """
    Recommendation for a supervisory write operation.

    Step 1 of the two-step confirmation process.
    Generated by optimization algorithms or operator requests.
    """
    recommendation_id: str = Field(
        default_factory=lambda: str(uuid.uuid4()),
        description="Unique recommendation identifier"
    )
    recommendation_type: WriteRecommendationType = Field(
        ...,
        description="Type of recommendation"
    )

    # Target
    tag_id: str = Field(..., description="Target tag identifier")
    canonical_name: str = Field(..., description="Canonical tag name")
    node_id: str = Field(..., description="OPC-UA node ID")

    # Values
    current_value: Any = Field(..., description="Current tag value")
    recommended_value: Any = Field(..., description="Recommended new value")
    engineering_unit: Optional[str] = Field(None, description="Engineering unit")

    # Justification
    reason: str = Field(..., description="Reason for recommendation")
    expected_benefit: Optional[str] = Field(None, description="Expected benefit")
    confidence_score: float = Field(
        default=1.0,
        ge=0.0,
        le=1.0,
        description="Confidence in recommendation (0-1)"
    )

    # Source
    source_system: str = Field(..., description="System that generated recommendation")
    source_algorithm: Optional[str] = Field(None, description="Algorithm identifier")

    # Timestamps
    generated_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        description="Generation timestamp"
    )
    valid_until: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc) + timedelta(minutes=30),
        description="Validity expiration"
    )

    # Status
    status: WriteConfirmationStatus = Field(
        default=WriteConfirmationStatus.RECOMMENDATION_GENERATED,
        description="Current status"
    )

    # Safety
    safety_impact: str = Field(
        default="low",
        description="Safety impact level (low, medium, high)"
    )
    requires_operator_confirmation: bool = Field(
        default=True,
        description="Requires operator confirmation"
    )

    # Provenance
    provenance_hash: Optional[str] = Field(None, description="SHA-256 hash")

    def is_valid(self) -> bool:
        """Check if recommendation is still valid."""
        return datetime.now(timezone.utc) < self.valid_until

    def calculate_provenance_hash(self) -> str:
        """Calculate SHA-256 provenance hash."""
        data = {
            "recommendation_id": self.recommendation_id,
            "tag_id": self.tag_id,
            "current_value": str(self.current_value),
            "recommended_value": str(self.recommended_value),
            "reason": self.reason,
            "source_system": self.source_system,
            "generated_at": self.generated_at.isoformat(),
        }
        canonical = json.dumps(data, sort_keys=True, separators=(",", ":"))
        return hashlib.sha256(canonical.encode("utf-8")).hexdigest()


# =============================================================================
# WRITE CONFIRMATION
# =============================================================================

class WriteConfirmation(BaseModel):
    """
    Confirmation for executing a write recommendation.

    Step 2 of the two-step confirmation process.
    Requires operator acknowledgment for supervisory writes.
    """
    confirmation_id: str = Field(
        default_factory=lambda: str(uuid.uuid4()),
        description="Unique confirmation identifier"
    )
    recommendation_id: str = Field(..., description="Original recommendation ID")

    # Confirmation details
    confirmed_by: str = Field(..., description="Confirming operator/system ID")
    confirmation_method: str = Field(
        default="manual",
        description="Confirmation method (manual, automated, supervisor)"
    )
    confirmation_notes: Optional[str] = Field(None, description="Operator notes")

    # Timestamps
    confirmed_at: datetime = Field(
        default_factory=lambda: datetime.now(timezone.utc),
        description="Confirmation timestamp"
    )

    # Authorization
    authorization_level: int = Field(
        default=1,
        ge=1,
        le=5,
        description="Authorization level (1=operator, 5=supervisor)"
    )
    authorization_token: Optional[str] = Field(None, description="Auth token if required")

    # Safety acknowledgment
    safety_acknowledged: bool = Field(
        default=False,
        description="Safety implications acknowledged"
    )

    # Provenance
    provenance_hash: Optional[str] = Field(None, description="SHA-256 hash")

    @validator("safety_acknowledged")
    def validate_safety_acknowledged(cls, v):
        """Ensure safety is acknowledged for all confirmations."""
        if not v:
            logger.warning("Confirmation without safety acknowledgment")
        return v

    def calculate_provenance_hash(self) -> str:
        """Calculate SHA-256 provenance hash."""
        data = {
            "confirmation_id": self.confirmation_id,
            "recommendation_id": self.recommendation_id,
            "confirmed_by": self.confirmed_by,
            "confirmed_at": self.confirmed_at.isoformat(),
            "authorization_level": self.authorization_level,
        }
        canonical = json.dumps(data, sort_keys=True, separators=(",", ":"))
        return hashlib.sha256(canonical.encode("utf-8")).hexdigest()


# =============================================================================
# SAFETY GATE
# =============================================================================

class SafetyGate:
    """
    Safety gate for validating write operations.

    Implements pre-write safety checks including:
    - Value boundary validation
    - Rate of change limiting
    - Interlock checking
    - Emergency stop status
    """

    def __init__(self):
        """Initialize safety gate."""
        self._boundaries: Dict[str, SafetyBoundary] = {}
        self._interlock_states: Dict[str, bool] = {}
        self._last_write_times: Dict[str, datetime] = {}
        self._last_values: Dict[str, float] = {}
        self._esd_active = False
        self._lock = asyncio.Lock()

    def register_boundary(self, boundary: SafetyBoundary) -> None:
        """
        Register safety boundary for a tag.

        Args:
            boundary: Safety boundary configuration
        """
        self._boundaries[boundary.tag_id] = boundary
        logger.info(
            f"Registered safety boundary for {boundary.tag_id}: "
            f"[{boundary.min_value}, {boundary.max_value}]"
        )

    def set_interlock_state(self, tag_id: str, is_safe: bool) -> None:
        """
        Set interlock state for a tag.

        Args:
            tag_id: Interlock tag ID
            is_safe: True if interlock permits write
        """
        self._interlock_states[tag_id] = is_safe

    def set_esd_active(self, active: bool) -> None:
        """
        Set Emergency Shutdown (ESD) state.

        Args:
            active: True if ESD is active (blocks all writes)
        """
        self._esd_active = active
        if active:
            logger.critical("ESD ACTIVE - All supervisory writes blocked")

    async def validate_write(
        self,
        tag_id: str,
        new_value: float,
        current_value: Optional[float] = None,
    ) -> Tuple[SafetyCheckResult, Dict[str, Any]]:
        """
        Validate a proposed write operation.

        Args:
            tag_id: Target tag ID
            new_value: Proposed new value
            current_value: Current tag value (if known)

        Returns:
            Tuple of (result, details)
        """
        async with self._lock:
            details: Dict[str, Any] = {
                "tag_id": tag_id,
                "new_value": new_value,
                "checks": {},
            }

            # Check ESD
            if self._esd_active:
                details["checks"]["esd"] = "ACTIVE"
                return SafetyCheckResult.INTERLOCK_ACTIVE, details

            # Get boundary
            boundary = self._boundaries.get(tag_id)

            # Check value boundaries
            if boundary:
                details["boundary"] = {
                    "min": boundary.min_value,
                    "max": boundary.max_value,
                }

                if not boundary.is_within_bounds(new_value):
                    details["checks"]["boundary"] = "FAILED"
                    details["error"] = (
                        f"Value {new_value} outside bounds "
                        f"[{boundary.min_value}, {boundary.max_value}]"
                    )
                    return SafetyCheckResult.FAILED, details
                details["checks"]["boundary"] = "PASSED"

                # Check rate of change
                if boundary.rate_of_change_limit and current_value is not None:
                    last_write = self._last_write_times.get(tag_id)
                    if last_write:
                        elapsed = (datetime.now(timezone.utc) - last_write).total_seconds()
                        if elapsed > 0:
                            rate = abs(new_value - current_value) / elapsed
                            if rate > boundary.rate_of_change_limit:
                                details["checks"]["rate_of_change"] = "FAILED"
                                details["error"] = (
                                    f"Rate of change {rate:.2f}/s exceeds limit "
                                    f"{boundary.rate_of_change_limit}/s"
                                )
                                return SafetyCheckResult.FAILED, details
                    details["checks"]["rate_of_change"] = "PASSED"

                # Check interlocks
                for interlock_tag in boundary.safety_interlock_tags:
                    interlock_safe = self._interlock_states.get(interlock_tag, True)
                    if not interlock_safe:
                        details["checks"]["interlock"] = f"BLOCKED by {interlock_tag}"
                        return SafetyCheckResult.INTERLOCK_ACTIVE, details
                details["checks"]["interlocks"] = "PASSED"

            return SafetyCheckResult.PASSED, details

    async def record_write(self, tag_id: str, value: float) -> None:
        """
        Record a successful write for rate limiting.

        Args:
            tag_id: Tag that was written
            value: Value that was written
        """
        async with self._lock:
            self._last_write_times[tag_id] = datetime.now(timezone.utc)
            self._last_values[tag_id] = value


# =============================================================================
# WRITE RATE LIMITER
# =============================================================================

class WriteRateLimiter:
    """
    Rate limiter for write operations.

    Implements token bucket algorithm to prevent write flooding.
    """

    def __init__(
        self,
        writes_per_minute: int = DEFAULT_WRITE_RATE_LIMIT_PER_MINUTE,
        burst_size: int = 5,
    ):
        """
        Initialize rate limiter.

        Args:
            writes_per_minute: Sustained write rate limit
            burst_size: Maximum burst size
        """
        self.writes_per_minute = writes_per_minute
        self.burst_size = burst_size

        # Token bucket
        self._tokens = float(burst_size)
        self._last_update = time.time()
        self._refill_rate = writes_per_minute / 60.0  # tokens per second

        # Per-tag tracking
        self._tag_timestamps: Dict[str, deque] = {}
        self._tag_limit = 5  # Max writes per tag per minute

        self._lock = asyncio.Lock()

    async def acquire(self, tag_id: str) -> Tuple[bool, Optional[float]]:
        """
        Acquire permission to write.

        Args:
            tag_id: Tag to write

        Returns:
            Tuple of (permitted, wait_time_if_not_permitted)
        """
        async with self._lock:
            now = time.time()

            # Refill tokens
            elapsed = now - self._last_update
            self._tokens = min(
                self.burst_size,
                self._tokens + elapsed * self._refill_rate
            )
            self._last_update = now

            # Check global rate
            if self._tokens < 1:
                wait_time = (1 - self._tokens) / self._refill_rate
                return False, wait_time

            # Check per-tag rate
            if tag_id not in self._tag_timestamps:
                self._tag_timestamps[tag_id] = deque(maxlen=self._tag_limit)

            tag_times = self._tag_timestamps[tag_id]

            # Remove old timestamps
            cutoff = now - 60
            while tag_times and tag_times[0] < cutoff:
                tag_times.popleft()

            if len(tag_times) >= self._tag_limit:
                wait_time = tag_times[0] + 60 - now
                return False, wait_time

            # Consume token
            self._tokens -= 1
            tag_times.append(now)

            return True, None

    async def get_stats(self) -> Dict[str, Any]:
        """Get rate limiter statistics."""
        async with self._lock:
            return {
                "available_tokens": self._tokens,
                "burst_size": self.burst_size,
                "writes_per_minute": self.writes_per_minute,
                "tracked_tags": len(self._tag_timestamps),
            }


# =============================================================================
# WHITELIST MANAGER
# =============================================================================

class WhitelistManager:
    """
    Manages whitelist of tags allowed for write operations.

    Only supervisory tags on the whitelist can be written.
    """

    def __init__(self):
        """Initialize whitelist manager."""
        self._whitelist: Set[str] = set()
        self._tag_configs: Dict[str, OPCUATagConfig] = {}
        self._lock = asyncio.Lock()

    async def add_tag(self, tag_config: OPCUATagConfig) -> bool:
        """
        Add tag to whitelist.

        Args:
            tag_config: Tag configuration

        Returns:
            True if added (must be supervisory)
        """
        async with self._lock:
            # Only allow supervisory tags
            if tag_config.metadata.access_level not in (
                TagAccessLevel.READ_WRITE,
                TagAccessLevel.SUPERVISORY_WRITE,
            ):
                logger.warning(
                    f"Tag {tag_config.tag_id} not whitelisted - not a supervisory tag"
                )
                return False

            if not tag_config.metadata.is_whitelisted_for_write:
                logger.warning(
                    f"Tag {tag_config.tag_id} not whitelisted - "
                    "is_whitelisted_for_write=False"
                )
                return False

            self._whitelist.add(tag_config.tag_id)
            self._tag_configs[tag_config.tag_id] = tag_config

            logger.info(f"Added {tag_config.tag_id} to write whitelist")
            return True

    async def remove_tag(self, tag_id: str) -> bool:
        """
        Remove tag from whitelist.

        Args:
            tag_id: Tag to remove

        Returns:
            True if removed
        """
        async with self._lock:
            if tag_id in self._whitelist:
                self._whitelist.discard(tag_id)
                self._tag_configs.pop(tag_id, None)
                logger.info(f"Removed {tag_id} from write whitelist")
                return True
            return False

    async def is_whitelisted(self, tag_id: str) -> bool:
        """
        Check if tag is whitelisted.

        Args:
            tag_id: Tag to check

        Returns:
            True if whitelisted
        """
        async with self._lock:
            return tag_id in self._whitelist

    async def get_tag_config(self, tag_id: str) -> Optional[OPCUATagConfig]:
        """
        Get tag configuration.

        Args:
            tag_id: Tag ID

        Returns:
            Tag config or None
        """
        async with self._lock:
            return self._tag_configs.get(tag_id)

    async def get_whitelist(self) -> Set[str]:
        """Get all whitelisted tag IDs."""
        async with self._lock:
            return self._whitelist.copy()


# =============================================================================
# OPC-UA WRITE HANDLER
# =============================================================================

class OPCUAWriteHandler:
    """
    Main write handler for GL-001 ThermalCommand.

    Implements secure two-step write confirmation:
    1. Generate recommendation with safety validation
    2. Confirm and execute with audit trail

    Example:
        >>> handler = OPCUAWriteHandler(connector)
        >>> await handler.whitelist.add_tag(tag_config)

        >>> # Step 1: Generate recommendation
        >>> recommendation = await handler.generate_recommendation(
        ...     tag_id="steam_headerA_pressure_sp",
        ...     recommended_value=12.5,
        ...     reason="Optimization suggests pressure increase",
        ...     source_system="gl-001-optimizer",
        ... )

        >>> # Step 2: Confirm and execute
        >>> response = await handler.confirm_and_write(
        ...     recommendation_id=recommendation.recommendation_id,
        ...     confirmed_by="operator_001",
        ...     confirmation_notes="Approved for efficiency",
        ... )
    """

    def __init__(
        self,
        connector: OPCUAConnector,
        writes_per_minute: int = DEFAULT_WRITE_RATE_LIMIT_PER_MINUTE,
        confirmation_timeout_s: int = DEFAULT_CONFIRMATION_TIMEOUT_S,
    ):
        """
        Initialize write handler.

        Args:
            connector: OPC-UA connector
            writes_per_minute: Write rate limit
            confirmation_timeout_s: Confirmation timeout
        """
        self.connector = connector
        self.confirmation_timeout_s = confirmation_timeout_s

        # Components
        self.whitelist = WhitelistManager()
        self.safety_gate = SafetyGate()
        self.rate_limiter = WriteRateLimiter(writes_per_minute)

        # State
        self._pending_recommendations: Dict[str, WriteRecommendation] = {}
        self._pending_requests: Dict[str, OPCUAWriteRequest] = {}
        self._completed_writes: deque = deque(maxlen=1000)

        # Callbacks
        self._pre_write_callbacks: List[Callable] = []
        self._post_write_callbacks: List[Callable] = []

        # Cleanup task
        self._cleanup_task: Optional[asyncio.Task] = None
        self._lock = asyncio.Lock()

        logger.info(
            f"Initialized OPC-UA write handler with rate limit "
            f"{writes_per_minute}/min"
        )

    async def start(self) -> None:
        """Start write handler background tasks."""
        self._cleanup_task = asyncio.create_task(self._cleanup_loop())

    async def stop(self) -> None:
        """Stop write handler."""
        if self._cleanup_task and not self._cleanup_task.done():
            self._cleanup_task.cancel()

    async def _cleanup_loop(self) -> None:
        """Cleanup expired recommendations and requests."""
        while True:
            try:
                await asyncio.sleep(60)  # Check every minute

                async with self._lock:
                    now = datetime.now(timezone.utc)

                    # Cleanup expired recommendations
                    expired = [
                        rec_id for rec_id, rec in self._pending_recommendations.items()
                        if not rec.is_valid()
                    ]
                    for rec_id in expired:
                        rec = self._pending_recommendations.pop(rec_id)
                        rec.status = WriteConfirmationStatus.EXPIRED
                        logger.info(f"Recommendation {rec_id} expired")

                    # Cleanup expired requests
                    expired_req = [
                        req_id for req_id, req in self._pending_requests.items()
                        if req.is_expired()
                    ]
                    for req_id in expired_req:
                        req = self._pending_requests.pop(req_id)
                        req.confirmation_status = WriteConfirmationStatus.EXPIRED
                        logger.info(f"Write request {req_id} expired")

            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Cleanup error: {e}")

    async def generate_recommendation(
        self,
        tag_id: str,
        recommended_value: Any,
        reason: str,
        source_system: str,
        recommendation_type: WriteRecommendationType = WriteRecommendationType.OPTIMIZATION,
        expected_benefit: Optional[str] = None,
        confidence_score: float = 1.0,
        valid_minutes: int = 30,
    ) -> WriteRecommendation:
        """
        Generate a write recommendation (Step 1).

        Args:
            tag_id: Target tag ID
            recommended_value: Proposed new value
            reason: Reason for recommendation
            source_system: System generating recommendation
            recommendation_type: Type of recommendation
            expected_benefit: Expected benefit description
            confidence_score: Confidence level (0-1)
            valid_minutes: Validity period

        Returns:
            Generated recommendation

        Raises:
            ValueError: If tag not whitelisted or validation fails
        """
        # Check whitelist
        if not await self.whitelist.is_whitelisted(tag_id):
            raise ValueError(f"Tag {tag_id} not whitelisted for write")

        tag_config = await self.whitelist.get_tag_config(tag_id)
        if not tag_config:
            raise ValueError(f"Tag config not found for {tag_id}")

        # Get current value
        current_value = None
        if self.connector.is_connected():
            data_point = await self.connector.read_tag(tag_config.node_id)
            if data_point:
                current_value = data_point.value

        # Pre-validate with safety gate
        safety_result, safety_details = await self.safety_gate.validate_write(
            tag_id,
            float(recommended_value) if isinstance(recommended_value, (int, float)) else 0,
            float(current_value) if current_value is not None else None,
        )

        if safety_result == SafetyCheckResult.FAILED:
            raise ValueError(f"Safety validation failed: {safety_details.get('error')}")

        if safety_result == SafetyCheckResult.INTERLOCK_ACTIVE:
            raise ValueError(f"Interlock active: {safety_details}")

        # Create recommendation
        recommendation = WriteRecommendation(
            recommendation_type=recommendation_type,
            tag_id=tag_id,
            canonical_name=tag_config.metadata.canonical_name,
            node_id=tag_config.node_id,
            current_value=current_value,
            recommended_value=recommended_value,
            engineering_unit=(
                tag_config.metadata.engineering_unit.display_name
                if tag_config.metadata.engineering_unit else None
            ),
            reason=reason,
            expected_benefit=expected_benefit,
            confidence_score=confidence_score,
            source_system=source_system,
            valid_until=datetime.now(timezone.utc) + timedelta(minutes=valid_minutes),
            safety_impact="low" if safety_result == SafetyCheckResult.PASSED else "medium",
            requires_operator_confirmation=(
                tag_config.metadata.access_level == TagAccessLevel.SUPERVISORY_WRITE
            ),
        )

        recommendation.provenance_hash = recommendation.calculate_provenance_hash()

        # Store pending recommendation
        async with self._lock:
            if len(self._pending_recommendations) >= DEFAULT_MAX_PENDING_WRITES:
                raise ValueError("Max pending recommendations reached")
            self._pending_recommendations[recommendation.recommendation_id] = recommendation

        logger.info(
            f"Generated recommendation {recommendation.recommendation_id}: "
            f"{tag_id} -> {recommended_value}"
        )

        return recommendation

    async def confirm_and_write(
        self,
        recommendation_id: str,
        confirmed_by: str,
        confirmation_notes: Optional[str] = None,
        safety_acknowledged: bool = True,
        authorization_level: int = 1,
    ) -> OPCUAWriteResponse:
        """
        Confirm a recommendation and execute write (Step 2).

        Args:
            recommendation_id: Recommendation to confirm
            confirmed_by: Confirming operator ID
            confirmation_notes: Optional notes
            safety_acknowledged: Safety implications acknowledged
            authorization_level: Operator authorization level

        Returns:
            Write response with result

        Raises:
            ValueError: If recommendation not found or validation fails
        """
        start_time = time.time()

        # Get recommendation
        async with self._lock:
            recommendation = self._pending_recommendations.get(recommendation_id)

        if not recommendation:
            raise ValueError(f"Recommendation {recommendation_id} not found")

        if not recommendation.is_valid():
            recommendation.status = WriteConfirmationStatus.EXPIRED
            raise ValueError("Recommendation has expired")

        # Validate safety acknowledgment
        if not safety_acknowledged:
            raise ValueError("Safety implications must be acknowledged")

        # Check rate limit
        permitted, wait_time = await self.rate_limiter.acquire(recommendation.tag_id)
        if not permitted:
            raise ValueError(
                f"Rate limited. Try again in {wait_time:.1f}s"
            )

        # Create confirmation
        confirmation = WriteConfirmation(
            recommendation_id=recommendation_id,
            confirmed_by=confirmed_by,
            confirmation_notes=confirmation_notes,
            authorization_level=authorization_level,
            safety_acknowledged=safety_acknowledged,
        )
        confirmation.provenance_hash = confirmation.calculate_provenance_hash()

        # Re-validate safety (conditions may have changed)
        safety_result, safety_details = await self.safety_gate.validate_write(
            recommendation.tag_id,
            float(recommendation.recommended_value),
            float(recommendation.current_value) if recommendation.current_value else None,
        )

        if safety_result != SafetyCheckResult.PASSED:
            recommendation.status = WriteConfirmationStatus.SAFETY_BLOCKED
            return OPCUAWriteResponse(
                request_id=recommendation_id,
                success=False,
                status_code=0x80000000,  # Bad status
                status_message=f"Safety check failed: {safety_details.get('error', 'Unknown')}",
                tag_id=recommendation.tag_id,
                written_value=None,
                previous_value=recommendation.current_value,
                requested_at=recommendation.generated_at,
                confirmation_status=WriteConfirmationStatus.SAFETY_BLOCKED,
                safety_checks=safety_details.get("checks", {}),
                processing_time_ms=(time.time() - start_time) * 1000,
                provenance_hash=hashlib.sha256(
                    f"{recommendation_id}{confirmed_by}".encode()
                ).hexdigest(),
            )

        # Execute pre-write callbacks
        for callback in self._pre_write_callbacks:
            try:
                if asyncio.iscoroutinefunction(callback):
                    await callback(recommendation, confirmation)
                else:
                    callback(recommendation, confirmation)
            except Exception as e:
                logger.error(f"Pre-write callback error: {e}")

        # Execute write
        write_success = False
        status_code = 0
        status_message = ""

        try:
            # In production, would call OPC-UA write:
            # result = await self.connector._client.get_node(
            #     recommendation.node_id
            # ).write_value(recommendation.recommended_value)
            # status_code = result.StatusCode
            # write_success = result.is_good()

            # Simulate successful write
            write_success = True
            status_code = 0  # Good
            status_message = "Write successful"

            # Record write for rate limiting
            await self.safety_gate.record_write(
                recommendation.tag_id,
                float(recommendation.recommended_value),
            )

            recommendation.status = WriteConfirmationStatus.APPLIED

        except Exception as e:
            write_success = False
            status_code = 0x80000000
            status_message = str(e)
            recommendation.status = WriteConfirmationStatus.FAILED
            logger.error(f"Write failed for {recommendation.tag_id}: {e}")

        # Calculate processing time
        processing_time_ms = (time.time() - start_time) * 1000

        # Create response with full audit trail
        response = OPCUAWriteResponse(
            request_id=recommendation_id,
            success=write_success,
            status_code=status_code,
            status_message=status_message,
            tag_id=recommendation.tag_id,
            written_value=recommendation.recommended_value if write_success else None,
            previous_value=recommendation.current_value,
            requested_at=recommendation.generated_at,
            confirmation_status=recommendation.status,
            confirmed_by=confirmed_by,
            safety_checks=safety_details.get("checks", {}),
            processing_time_ms=processing_time_ms,
            provenance_hash="",  # Will be set below
        )

        # Add audit trail entries
        response.add_audit_entry("recommendation_generated", {
            "recommendation_id": recommendation_id,
            "source_system": recommendation.source_system,
            "timestamp": recommendation.generated_at.isoformat(),
        })
        response.add_audit_entry("confirmation_received", {
            "confirmation_id": confirmation.confirmation_id,
            "confirmed_by": confirmed_by,
            "timestamp": confirmation.confirmed_at.isoformat(),
        })
        response.add_audit_entry("safety_validation", safety_details)
        response.add_audit_entry("write_executed", {
            "success": write_success,
            "status_code": status_code,
            "processing_time_ms": processing_time_ms,
        })

        # Calculate final provenance hash
        audit_json = json.dumps(response.audit_trail, sort_keys=True)
        response.provenance_hash = hashlib.sha256(
            f"{recommendation.provenance_hash}{confirmation.provenance_hash}{audit_json}".encode()
        ).hexdigest()

        # Store completed write
        async with self._lock:
            self._pending_recommendations.pop(recommendation_id, None)
            self._completed_writes.append({
                "response": response,
                "recommendation": recommendation,
                "confirmation": confirmation,
            })

        # Execute post-write callbacks
        for callback in self._post_write_callbacks:
            try:
                if asyncio.iscoroutinefunction(callback):
                    await callback(response)
                else:
                    callback(response)
            except Exception as e:
                logger.error(f"Post-write callback error: {e}")

        logger.info(
            f"Write {'succeeded' if write_success else 'failed'} for "
            f"{recommendation.tag_id}: {recommendation.recommended_value}"
        )

        return response

    async def reject_recommendation(
        self,
        recommendation_id: str,
        rejected_by: str,
        rejection_reason: str,
    ) -> bool:
        """
        Reject a pending recommendation.

        Args:
            recommendation_id: Recommendation to reject
            rejected_by: Rejecting operator ID
            rejection_reason: Reason for rejection

        Returns:
            True if rejected
        """
        async with self._lock:
            recommendation = self._pending_recommendations.get(recommendation_id)
            if not recommendation:
                return False

            recommendation.status = WriteConfirmationStatus.REJECTED
            self._pending_recommendations.pop(recommendation_id)

            logger.info(
                f"Recommendation {recommendation_id} rejected by {rejected_by}: "
                f"{rejection_reason}"
            )

            return True

    def register_pre_write_callback(
        self,
        callback: Callable[[WriteRecommendation, WriteConfirmation], None],
    ) -> None:
        """Register callback to execute before write."""
        self._pre_write_callbacks.append(callback)

    def register_post_write_callback(
        self,
        callback: Callable[[OPCUAWriteResponse], None],
    ) -> None:
        """Register callback to execute after write."""
        self._post_write_callbacks.append(callback)

    async def get_pending_recommendations(self) -> List[WriteRecommendation]:
        """Get all pending recommendations."""
        async with self._lock:
            return list(self._pending_recommendations.values())

    async def get_recommendation(
        self,
        recommendation_id: str,
    ) -> Optional[WriteRecommendation]:
        """Get specific recommendation."""
        async with self._lock:
            return self._pending_recommendations.get(recommendation_id)

    async def get_write_history(
        self,
        limit: int = 100,
    ) -> List[Dict[str, Any]]:
        """Get recent write history."""
        async with self._lock:
            return list(self._completed_writes)[-limit:]

    async def get_stats(self) -> Dict[str, Any]:
        """Get write handler statistics."""
        async with self._lock:
            return {
                "pending_recommendations": len(self._pending_recommendations),
                "completed_writes": len(self._completed_writes),
                "whitelisted_tags": len(await self.whitelist.get_whitelist()),
                "rate_limiter": await self.rate_limiter.get_stats(),
            }


# =============================================================================
# EXPORTS
# =============================================================================

__all__ = [
    # Enums
    "SafetyCheckResult",
    "WriteRecommendationType",
    # Models
    "WriteRecommendation",
    "WriteConfirmation",
    # Components
    "SafetyGate",
    "WriteRateLimiter",
    "WhitelistManager",
    # Main Handler
    "OPCUAWriteHandler",
]
