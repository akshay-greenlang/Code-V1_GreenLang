"""
Alembic Environment Configuration for GL-Agent-Factory

This module configures the Alembic migration environment for both
synchronous and asynchronous database operations.

Features:
- Async PostgreSQL support via asyncpg
- Model metadata auto-discovery
- Environment variable configuration (ALEMBIC_DATABASE_URL, DATABASE_URL)
- Transaction-per-migration safety
- Proper error handling and logging

Environment Variables:
    ALEMBIC_DATABASE_URL: Primary database URL override
    DATABASE_URL: Alternative database URL (if ALEMBIC_DATABASE_URL not set)
"""

import asyncio
import logging
import os
import sys
from logging.config import fileConfig

from alembic import context
from sqlalchemy import pool
from sqlalchemy.engine import Connection
from sqlalchemy.ext.asyncio import async_engine_from_config

# Ensure backend directory is in Python path for model imports
backend_dir = os.path.dirname(os.path.dirname(os.path.abspath(__file__)))
if backend_dir not in sys.path:
    sys.path.insert(0, backend_dir)

# Import Base and all models for autogenerate support
# These imports ensure all models are registered with SQLAlchemy metadata
from db.base import Base

# Import all models to register them with Base.metadata
# This is required for Alembic autogenerate to detect model changes
from models.tenant import Tenant, TenantUsageLog, TenantInvitation
from models.user import User
from models.agent import Agent
from models.agent_version import AgentVersion
from models.execution import Execution
from models.audit_log import AuditLog

# Configure logging
logger = logging.getLogger("alembic.env")

# Alembic Config object - provides access to alembic.ini values
config = context.config

# Set up Python logging from alembic.ini
if config.config_file_name is not None:
    fileConfig(config.config_file_name)

# Model metadata for autogenerate support
# All imported models above contribute to this metadata
target_metadata = Base.metadata


def get_url() -> str:
    """
    Get database URL from environment or config.

    Priority order:
    1. ALEMBIC_DATABASE_URL environment variable
    2. DATABASE_URL environment variable
    3. sqlalchemy.url from alembic.ini

    Returns:
        Database connection URL string

    Raises:
        ValueError: If no database URL is configured
    """
    # Priority 1: ALEMBIC_DATABASE_URL
    url = os.getenv("ALEMBIC_DATABASE_URL")
    if url:
        logger.info("Using database URL from ALEMBIC_DATABASE_URL")
        return url

    # Priority 2: DATABASE_URL
    url = os.getenv("DATABASE_URL")
    if url:
        logger.info("Using database URL from DATABASE_URL")
        # Convert standard postgresql:// to async driver if needed
        if url.startswith("postgresql://") and "+asyncpg" not in url:
            url = url.replace("postgresql://", "postgresql+asyncpg://", 1)
        return url

    # Priority 3: alembic.ini configuration
    url = config.get_main_option("sqlalchemy.url")
    if url:
        logger.info("Using database URL from alembic.ini")
        return url

    raise ValueError(
        "No database URL configured. Set ALEMBIC_DATABASE_URL, DATABASE_URL, "
        "or configure sqlalchemy.url in alembic.ini"
    )


def include_object(object, name, type_, reflected, compare_to):
    """
    Filter objects for autogenerate.

    This function determines which database objects should be included
    in autogenerated migrations.

    Args:
        object: The SQLAlchemy object being considered
        name: Name of the object
        type_: Type of object (table, column, index, etc.)
        reflected: Whether object was reflected from database
        compare_to: Object being compared to

    Returns:
        True if object should be included in migration
    """
    # Exclude internal PostgreSQL schemas
    if type_ == "table" and name.startswith("pg_"):
        return False

    # Exclude alembic version table
    if type_ == "table" and name == "alembic_version":
        return False

    return True


def run_migrations_offline() -> None:
    """
    Run migrations in 'offline' mode.

    This configures the context with just a URL and not an Engine,
    though an Engine is acceptable here as well. By skipping the Engine
    creation we don't even need a DBAPI to be available.

    Calls to context.execute() here emit the given string to the
    script output.
    """
    url = get_url()
    logger.info(f"Running offline migrations with URL: {url[:20]}...")

    context.configure(
        url=url,
        target_metadata=target_metadata,
        literal_binds=True,
        dialect_opts={"paramstyle": "named"},
        # PostgreSQL-specific options
        compare_type=True,
        compare_server_default=True,
        include_schemas=True,
        include_object=include_object,
    )

    with context.begin_transaction():
        context.run_migrations()


def do_run_migrations(connection: Connection) -> None:
    """
    Run migrations within a database connection context.

    Args:
        connection: Active database connection
    """
    context.configure(
        connection=connection,
        target_metadata=target_metadata,
        # PostgreSQL-specific options
        compare_type=True,
        compare_server_default=True,
        include_schemas=True,
        include_object=include_object,
        # Transaction configuration
        transaction_per_migration=True,
    )

    with context.begin_transaction():
        context.run_migrations()


async def run_async_migrations() -> None:
    """
    Run migrations in 'online' mode with async engine.

    Creates an async Engine and associates a connection with the context.
    Uses asyncpg driver for PostgreSQL async operations.
    """
    configuration = config.get_section(config.config_ini_section, {})
    configuration["sqlalchemy.url"] = get_url()

    logger.info("Creating async engine for migrations...")

    connectable = async_engine_from_config(
        configuration,
        prefix="sqlalchemy.",
        poolclass=pool.NullPool,
    )

    async with connectable.connect() as connection:
        logger.info("Running migrations...")
        await connection.run_sync(do_run_migrations)
        logger.info("Migrations completed successfully")

    await connectable.dispose()


def run_migrations_online() -> None:
    """
    Run migrations in 'online' mode.

    Delegates to async migration runner for asyncpg support.
    """
    try:
        asyncio.run(run_async_migrations())
    except Exception as e:
        logger.error(f"Migration failed: {e}")
        raise


# Determine offline/online mode and run appropriate migration function
if context.is_offline_mode():
    logger.info("Running migrations in offline mode")
    run_migrations_offline()
else:
    logger.info("Running migrations in online mode")
    run_migrations_online()
