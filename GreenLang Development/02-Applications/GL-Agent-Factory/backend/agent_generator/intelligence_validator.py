# -*- coding: utf-8 -*-
"""
Intelligence Validator for AI Factory

This module enforces mandatory LLM intelligence requirements for all agents
generated by the GL-Agent-Factory. It validates that new agents properly
implement the IntelligentAgent interface.

MANDATORY REQUIREMENTS (December 2025+):
1. All new agents MUST extend IntelligentAgentBase OR use IntelligenceMixin
2. All new agents MUST have @require_intelligence decorator
3. All new agents MUST implement get_intelligence_level()
4. All new agents MUST implement get_intelligence_capabilities()
5. Intelligence level NONE is DEPRECATED for new agents

This validator is called during:
- Agent specification parsing
- Code generation
- Agent registration
- Pre-certification checks

Usage:
    from backend.agent_generator.intelligence_validator import (
        IntelligenceValidator,
        validate_agent_spec,
        validate_generated_code,
    )

    validator = IntelligenceValidator()
    result = validator.validate_spec(agent_spec)

    if not result.is_valid:
        raise IntelligenceRequirementError(result.errors)

Author: GreenLang Intelligence Framework
Date: December 2025
Status: Production - MANDATORY
"""

import ast
import re
import logging
from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from typing import Any, Dict, List, Optional, Set

logger = logging.getLogger(__name__)


class IntelligenceLevelEnum(str, Enum):
    """Intelligence levels for agents (mirrors greenlang.agents.intelligent_base)."""
    NONE = "NONE"  # DEPRECATED - Not allowed for new agents
    BASIC = "BASIC"  # Explanation generation only
    STANDARD = "STANDARD"  # Explanations + Recommendations
    ADVANCED = "ADVANCED"  # + Anomaly detection + Reasoning
    FULL = "FULL"  # + Chain-of-thought + RAG


@dataclass
class IntelligenceValidationResult:
    """Result of intelligence validation."""

    is_valid: bool = True
    errors: List[str] = field(default_factory=list)
    warnings: List[str] = field(default_factory=list)
    intelligence_level: Optional[IntelligenceLevelEnum] = None
    capabilities: Dict[str, bool] = field(default_factory=dict)

    def add_error(self, error: str) -> None:
        """Add validation error."""
        self.errors.append(error)
        self.is_valid = False

    def add_warning(self, warning: str) -> None:
        """Add validation warning."""
        self.warnings.append(warning)


class IntelligenceRequirementError(Exception):
    """Raised when intelligence requirements are not met."""

    def __init__(self, errors: List[str]):
        self.errors = errors
        super().__init__(f"Intelligence requirements not met: {'; '.join(errors)}")


class IntelligenceValidator:
    """
    Validator for mandatory LLM intelligence requirements.

    This validator ensures that all agents generated by the AI Factory
    properly implement intelligence capabilities as mandated since
    the Intelligence Paradox resolution in December 2025.

    Attributes:
        strict_mode: If True, treats warnings as errors
        allow_legacy: If True, allows NONE intelligence level (for existing agents only)
    """

    # Required base classes or mixins
    REQUIRED_BASES = {
        "IntelligentAgentBase",
        "IntelligenceMixin",
    }

    # Required methods for intelligence interface
    REQUIRED_METHODS = {
        "get_intelligence_level",
        "get_intelligence_capabilities",
    }

    # Intelligence methods that should be called
    EXPECTED_INTELLIGENCE_METHODS = {
        "generate_explanation",
        "generate_recommendations",
    }

    # Optional intelligence methods
    OPTIONAL_INTELLIGENCE_METHODS = {
        "detect_anomalies",
        "reason_about",
        "validate_with_reasoning",
    }

    def __init__(
        self,
        strict_mode: bool = True,
        allow_legacy: bool = False,
    ):
        """
        Initialize the intelligence validator.

        Args:
            strict_mode: If True, treats warnings as errors
            allow_legacy: If True, allows NONE intelligence level
        """
        self.strict_mode = strict_mode
        self.allow_legacy = allow_legacy

    def validate_spec(self, spec: Dict[str, Any]) -> IntelligenceValidationResult:
        """
        Validate agent specification for intelligence requirements.

        This is called during agent specification parsing to ensure
        the spec includes proper intelligence configuration.

        Args:
            spec: Agent specification dictionary

        Returns:
            IntelligenceValidationResult with errors/warnings
        """
        result = IntelligenceValidationResult()

        # Check if intelligence configuration is present
        intelligence_config = spec.get("intelligence", {})

        if not intelligence_config:
            result.add_error(
                "Missing 'intelligence' configuration in agent spec. "
                "All new agents MUST have intelligence configuration."
            )
            return result

        # Check intelligence level
        level_str = intelligence_config.get("level", "").upper()

        if not level_str:
            result.add_error(
                "Missing 'intelligence.level' in agent spec. "
                "Must be one of: BASIC, STANDARD, ADVANCED, FULL"
            )
        elif level_str == "NONE":
            if not self.allow_legacy:
                result.add_error(
                    "Intelligence level 'NONE' is DEPRECATED and not allowed for new agents. "
                    "Use BASIC, STANDARD, ADVANCED, or FULL instead."
                )
            else:
                result.add_warning(
                    "Intelligence level 'NONE' is deprecated. Consider upgrading to BASIC or higher."
                )
        else:
            try:
                result.intelligence_level = IntelligenceLevelEnum(level_str)
            except ValueError:
                result.add_error(
                    f"Invalid intelligence level '{level_str}'. "
                    f"Must be one of: {', '.join(e.value for e in IntelligenceLevelEnum if e != IntelligenceLevelEnum.NONE)}"
                )

        # Check capabilities configuration
        capabilities = intelligence_config.get("capabilities", {})

        if not capabilities.get("can_explain", False):
            result.add_error(
                "Intelligence capability 'can_explain' must be True. "
                "All agents MUST be able to generate explanations."
            )

        result.capabilities = {
            "can_explain": capabilities.get("can_explain", False),
            "can_recommend": capabilities.get("can_recommend", False),
            "can_detect_anomalies": capabilities.get("can_detect_anomalies", False),
            "can_reason": capabilities.get("can_reason", False),
        }

        # Check regulatory context
        if not intelligence_config.get("regulatory_context"):
            result.add_warning(
                "Missing 'intelligence.regulatory_context'. "
                "Recommend specifying applicable regulations (e.g., 'GHG Protocol, CSRD ESRS E1')"
            )

        # Apply strict mode
        if self.strict_mode and result.warnings:
            for warning in result.warnings:
                result.add_error(f"[Strict Mode] {warning}")

        return result

    def validate_generated_code(self, code: str) -> IntelligenceValidationResult:
        """
        Validate generated Python code for intelligence requirements.

        This is called after code generation to ensure the generated
        agent properly implements intelligence interfaces.

        Args:
            code: Generated Python code as string

        Returns:
            IntelligenceValidationResult with errors/warnings
        """
        result = IntelligenceValidationResult()

        try:
            tree = ast.parse(code)
        except SyntaxError as e:
            result.add_error(f"Syntax error in generated code: {e}")
            return result

        # Find class definitions
        agent_classes = []
        for node in ast.walk(tree):
            if isinstance(node, ast.ClassDef):
                # Check if this is an agent class
                if "Agent" in node.name:
                    agent_classes.append(node)

        if not agent_classes:
            result.add_error("No agent class found in generated code")
            return result

        for agent_class in agent_classes:
            self._validate_agent_class(agent_class, code, result)

        return result

    def _validate_agent_class(
        self,
        node: ast.ClassDef,
        code: str,
        result: IntelligenceValidationResult
    ) -> None:
        """Validate a single agent class definition."""

        # Check base classes
        base_names = set()
        for base in node.bases:
            if isinstance(base, ast.Name):
                base_names.add(base.id)
            elif isinstance(base, ast.Attribute):
                base_names.add(base.attr)

        has_intelligent_base = bool(base_names & self.REQUIRED_BASES)

        if not has_intelligent_base:
            result.add_error(
                f"Agent class '{node.name}' does not extend IntelligentAgentBase "
                f"or include IntelligenceMixin. Found bases: {base_names}"
            )

        # Check for @require_intelligence decorator
        has_decorator = False
        for decorator in node.decorator_list:
            if isinstance(decorator, ast.Name) and decorator.id == "require_intelligence":
                has_decorator = True
            elif isinstance(decorator, ast.Call):
                if isinstance(decorator.func, ast.Name) and decorator.func.id == "require_intelligence":
                    has_decorator = True

        if not has_decorator:
            result.add_error(
                f"Agent class '{node.name}' is missing @require_intelligence decorator. "
                f"This decorator is MANDATORY for all new agents."
            )

        # Check for required methods
        method_names = {
            n.name for n in node.body
            if isinstance(n, (ast.FunctionDef, ast.AsyncFunctionDef))
        }

        missing_methods = self.REQUIRED_METHODS - method_names
        if missing_methods:
            result.add_error(
                f"Agent class '{node.name}' is missing required methods: {missing_methods}. "
                f"These methods are MANDATORY for intelligent agents."
            )

        # Check for intelligence method calls in execute()
        for item in node.body:
            if isinstance(item, (ast.FunctionDef, ast.AsyncFunctionDef)):
                if item.name == "execute":
                    self._check_execute_method(item, node.name, result)

    def _check_execute_method(
        self,
        method: ast.FunctionDef,
        class_name: str,
        result: IntelligenceValidationResult
    ) -> None:
        """Check that execute() calls intelligence methods."""

        intelligence_calls = set()

        for node in ast.walk(method):
            if isinstance(node, ast.Call):
                if isinstance(node.func, ast.Attribute):
                    if node.func.attr in self.EXPECTED_INTELLIGENCE_METHODS:
                        intelligence_calls.add(node.func.attr)

        missing_calls = self.EXPECTED_INTELLIGENCE_METHODS - intelligence_calls
        if missing_calls:
            result.add_warning(
                f"Agent '{class_name}.execute()' does not call: {missing_calls}. "
                f"Intelligent agents should call generate_explanation() and generate_recommendations()."
            )

    def validate_agent_file(self, file_path: Path) -> IntelligenceValidationResult:
        """
        Validate an agent file for intelligence requirements.

        Args:
            file_path: Path to the agent Python file

        Returns:
            IntelligenceValidationResult with errors/warnings
        """
        if not file_path.exists():
            result = IntelligenceValidationResult()
            result.add_error(f"Agent file not found: {file_path}")
            return result

        code = file_path.read_text(encoding="utf-8")
        return self.validate_generated_code(code)

    def validate_for_registration(
        self,
        agent_id: str,
        spec: Dict[str, Any],
        code_path: Optional[Path] = None,
    ) -> IntelligenceValidationResult:
        """
        Comprehensive validation for agent registration.

        This is called before an agent can be registered in the
        Agent Registry Service.

        Args:
            agent_id: Agent identifier
            spec: Agent specification
            code_path: Optional path to agent code

        Returns:
            Combined validation result
        """
        result = IntelligenceValidationResult()

        # Validate spec
        spec_result = self.validate_spec(spec)
        result.errors.extend(spec_result.errors)
        result.warnings.extend(spec_result.warnings)
        result.intelligence_level = spec_result.intelligence_level
        result.capabilities = spec_result.capabilities

        # Validate code if path provided
        if code_path:
            code_result = self.validate_agent_file(code_path)
            result.errors.extend(code_result.errors)
            result.warnings.extend(code_result.warnings)

        result.is_valid = len(result.errors) == 0

        if not result.is_valid:
            logger.warning(
                f"Agent {agent_id} failed intelligence validation: {result.errors}"
            )
        else:
            logger.info(
                f"Agent {agent_id} passed intelligence validation with level: "
                f"{result.intelligence_level}"
            )

        return result

    def validate_for_certification(
        self,
        agent_id: str,
        spec: Dict[str, Any],
        code_path: Path,
    ) -> IntelligenceValidationResult:
        """
        Strict validation for agent certification.

        This is called before an agent can transition to CERTIFIED state.
        It enforces the strictest requirements.

        Args:
            agent_id: Agent identifier
            spec: Agent specification
            code_path: Path to agent code

        Returns:
            Validation result (all warnings treated as errors)
        """
        # Use strict mode for certification
        original_strict = self.strict_mode
        self.strict_mode = True

        try:
            result = self.validate_for_registration(agent_id, spec, code_path)

            # Additional certification checks
            if result.intelligence_level == IntelligenceLevelEnum.BASIC:
                result.add_warning(
                    "Agent has BASIC intelligence level. Consider upgrading to STANDARD "
                    "or higher for better user experience."
                )

            if not result.capabilities.get("can_recommend"):
                result.add_warning(
                    "Agent cannot generate recommendations. Consider enabling "
                    "recommendations for better value."
                )

            return result

        finally:
            self.strict_mode = original_strict


# =============================================================================
# CONVENIENCE FUNCTIONS
# =============================================================================

def validate_agent_spec(spec: Dict[str, Any]) -> IntelligenceValidationResult:
    """
    Convenience function to validate agent specification.

    Args:
        spec: Agent specification dictionary

    Returns:
        IntelligenceValidationResult
    """
    validator = IntelligenceValidator()
    return validator.validate_spec(spec)


def validate_generated_code(code: str) -> IntelligenceValidationResult:
    """
    Convenience function to validate generated code.

    Args:
        code: Generated Python code

    Returns:
        IntelligenceValidationResult
    """
    validator = IntelligenceValidator()
    return validator.validate_generated_code(code)


def enforce_intelligence_requirements(
    spec: Dict[str, Any],
    code: Optional[str] = None,
    raise_on_error: bool = True,
) -> IntelligenceValidationResult:
    """
    Enforce intelligence requirements with optional exception raising.

    This is the main entry point for intelligence validation.

    Args:
        spec: Agent specification
        code: Optional generated code
        raise_on_error: If True, raises IntelligenceRequirementError on failure

    Returns:
        IntelligenceValidationResult

    Raises:
        IntelligenceRequirementError: If validation fails and raise_on_error is True
    """
    validator = IntelligenceValidator()

    result = validator.validate_spec(spec)

    if code:
        code_result = validator.validate_generated_code(code)
        result.errors.extend(code_result.errors)
        result.warnings.extend(code_result.warnings)
        result.is_valid = result.is_valid and code_result.is_valid

    if not result.is_valid and raise_on_error:
        raise IntelligenceRequirementError(result.errors)

    return result


# =============================================================================
# SPEC TEMPLATE WITH INTELLIGENCE
# =============================================================================

INTELLIGENCE_SPEC_TEMPLATE = """
# Intelligence Configuration (MANDATORY for all new agents)
intelligence:
  # Intelligence level (required): BASIC, STANDARD, ADVANCED, or FULL
  # NONE is DEPRECATED and not allowed for new agents
  level: STANDARD

  # Capabilities (required)
  capabilities:
    can_explain: true        # MANDATORY: Must be true
    can_recommend: true      # Recommended: Generate actionable recommendations
    can_detect_anomalies: false  # Optional: Detect unusual patterns
    can_reason: false        # Optional: General-purpose reasoning

  # Regulatory context (recommended)
  regulatory_context: "GHG Protocol, CSRD ESRS E1"

  # Domain context (recommended)
  domain_context: "carbon emissions and sustainability"

  # Budget limits (optional)
  budget:
    max_per_call_usd: 0.10
    max_per_execution_usd: 0.50
"""


def get_intelligence_spec_template() -> str:
    """Get the intelligence configuration template for agent specs."""
    return INTELLIGENCE_SPEC_TEMPLATE


# =============================================================================
# EXAMPLE USAGE
# =============================================================================

if __name__ == "__main__":
    """Example usage of intelligence validator."""

    # Example spec
    example_spec = {
        "agent_id": "emissions/carbon_calculator",
        "name": "Carbon Calculator Agent",
        "version": "1.0.0",
        "intelligence": {
            "level": "STANDARD",
            "capabilities": {
                "can_explain": True,
                "can_recommend": True,
                "can_detect_anomalies": False,
                "can_reason": False,
            },
            "regulatory_context": "GHG Protocol, CSRD ESRS E1",
        }
    }

    # Validate spec
    result = validate_agent_spec(example_spec)

    print("=" * 60)
    print("INTELLIGENCE VALIDATION RESULT")
    print("=" * 60)
    print(f"Valid: {result.is_valid}")
    print(f"Level: {result.intelligence_level}")
    print(f"Capabilities: {result.capabilities}")
    print(f"Errors: {result.errors}")
    print(f"Warnings: {result.warnings}")
