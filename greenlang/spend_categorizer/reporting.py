# -*- coding: utf-8 -*-
"""
Reporting Engine - AGENT-DATA-009: Spend Data Categorizer
============================================================

Multi-format report generation engine for spend categorisation,
emissions, audit, procurement, and executive summary reports.
Supports JSON, CSV, Markdown, HTML, and plain text output.

Supports:
    - Categorisation reports (taxonomy, confidence, coverage)
    - Emissions reports (Scope 3 breakdown, factors, totals)
    - Audit reports (provenance, rule matches, data lineage)
    - Procurement reports (vendor spend, Pareto, concentration)
    - Executive summary reports (KPIs, trends, recommendations)
    - Record export (CSV, JSON)
    - Five output formats: JSON, CSV, MARKDOWN, HTML, TEXT
    - Styled HTML templates with tables
    - Thread-safe in-memory storage
    - SHA-256 provenance hashes on all generated reports

Zero-Hallucination Guarantees:
    - All report data is derived from input records (no fabrication)
    - Aggregations and summaries are pure arithmetic
    - No LLM or ML model in report generation
    - SHA-256 provenance hashes for audit trails

Example:
    >>> from greenlang.spend_categorizer.reporting import ReportingEngine
    >>> engine = ReportingEngine()
    >>> report = engine.generate_categorization_report(records, format="markdown")
    >>> print(report.content[:200])

Author: GreenLang Platform Team
Date: February 2026
PRD: AGENT-DATA-009 Spend Data Categorizer (GL-DATA-SUP-002)
Status: Production Ready
"""

from __future__ import annotations

import csv
import hashlib
import io
import json
import logging
import threading
import time
import uuid
from collections import defaultdict
from datetime import datetime, timezone
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field

logger = logging.getLogger(__name__)

__all__ = [
    "CategorizationReport",
    "ReportingEngine",
]


# ---------------------------------------------------------------------------
# Helpers
# ---------------------------------------------------------------------------


def _utcnow() -> datetime:
    """Return current UTC datetime with microseconds zeroed."""
    return datetime.now(timezone.utc).replace(microsecond=0)


def _generate_id(prefix: str = "rpt") -> str:
    """Generate a unique identifier with a prefix."""
    return f"{prefix}-{uuid.uuid4().hex[:12]}"


# ---------------------------------------------------------------------------
# Supported formats
# ---------------------------------------------------------------------------

_SUPPORTED_FORMATS = {"json", "csv", "markdown", "html", "text"}


# ---------------------------------------------------------------------------
# HTML base template
# ---------------------------------------------------------------------------

_HTML_TEMPLATE = """<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>{title}</title>
<style>
  body {{ font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; margin: 20px; color: #333; background: #fafafa; }}
  h1 {{ color: #1a5632; border-bottom: 2px solid #1a5632; padding-bottom: 8px; }}
  h2 {{ color: #2d7a4f; margin-top: 28px; }}
  h3 {{ color: #3d9969; }}
  table {{ border-collapse: collapse; width: 100%; margin: 16px 0; background: #fff; box-shadow: 0 1px 3px rgba(0,0,0,0.1); }}
  th {{ background-color: #1a5632; color: white; padding: 10px 14px; text-align: left; font-weight: 600; }}
  td {{ padding: 8px 14px; border-bottom: 1px solid #e8e8e8; }}
  tr:nth-child(even) {{ background-color: #f5f9f7; }}
  tr:hover {{ background-color: #e8f5ee; }}
  .summary-box {{ background: #fff; border: 1px solid #ddd; border-radius: 6px; padding: 16px; margin: 12px 0; box-shadow: 0 1px 3px rgba(0,0,0,0.05); }}
  .kpi {{ display: inline-block; text-align: center; margin: 8px 16px; min-width: 120px; }}
  .kpi-value {{ font-size: 28px; font-weight: 700; color: #1a5632; }}
  .kpi-label {{ font-size: 13px; color: #666; margin-top: 4px; }}
  .footer {{ margin-top: 30px; padding-top: 12px; border-top: 1px solid #ddd; font-size: 12px; color: #888; }}
  .provenance {{ font-family: monospace; font-size: 11px; color: #999; word-break: break-all; }}
</style>
</head>
<body>
<h1>{title}</h1>
<p>Generated: {timestamp} | Report ID: {report_id}</p>
{content}
<div class="footer">
  <p>Generated by GreenLang Spend Data Categorizer (AGENT-DATA-009)</p>
  <p class="provenance">Provenance: {provenance_hash}</p>
</div>
</body>
</html>"""


# ---------------------------------------------------------------------------
# Data models
# ---------------------------------------------------------------------------


class CategorizationReport(BaseModel):
    """Generated report container."""

    report_id: str = Field(..., description="Unique report identifier")
    report_type: str = Field(..., description="Report type (categorization, emissions, audit, procurement, executive)")
    title: str = Field(default="", description="Report title")
    format: str = Field(default="markdown", description="Output format")
    content: str = Field(default="", description="Rendered report content")
    record_count: int = Field(default=0, ge=0, description="Number of source records")
    generated_at: str = Field(default="", description="Generation timestamp ISO")
    processing_time_ms: float = Field(default=0.0, description="Generation time")
    provenance_hash: str = Field(default="", description="SHA-256 provenance hash")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Report metadata")

    model_config = {"extra": "forbid"}


# ---------------------------------------------------------------------------
# ReportingEngine
# ---------------------------------------------------------------------------


class ReportingEngine:
    """Multi-format report generation engine.

    Generates categorisation, emissions, audit, procurement, and
    executive summary reports in JSON, CSV, Markdown, HTML, and
    plain text formats.

    Attributes:
        _config: Configuration dictionary.
        _reports: In-memory report storage.
        _lock: Threading lock for thread-safe mutations.
        _stats: Cumulative generation statistics.

    Example:
        >>> engine = ReportingEngine()
        >>> report = engine.generate_categorization_report(records)
        >>> print(report.content[:200])
    """

    def __init__(self, config: Optional[Dict[str, Any]] = None) -> None:
        """Initialize ReportingEngine.

        Args:
            config: Optional configuration dict. Recognised keys:
                - ``default_format``: str (default "markdown")
                - ``include_provenance``: bool (default True)
                - ``max_records_in_report``: int (default 10000)
        """
        self._config = config or {}
        self._default_format: str = self._config.get("default_format", "markdown")
        self._include_provenance: bool = self._config.get("include_provenance", True)
        self._max_records: int = self._config.get("max_records_in_report", 10000)
        self._reports: Dict[str, CategorizationReport] = {}
        self._lock = threading.Lock()
        self._stats: Dict[str, Any] = {
            "reports_generated": 0,
            "by_type": {},
            "by_format": {},
            "total_records_reported": 0,
            "errors": 0,
        }
        logger.info(
            "ReportingEngine initialised: default_format=%s, provenance=%s",
            self._default_format,
            self._include_provenance,
        )

    # ------------------------------------------------------------------
    # Public API - Report Generation
    # ------------------------------------------------------------------

    def generate_categorization_report(
        self,
        records: List[Dict[str, Any]],
        title: Optional[str] = None,
        format: str = "markdown",
    ) -> CategorizationReport:
        """Generate a spend categorisation report.

        Shows taxonomy classification results, confidence distribution,
        coverage rates, and per-category breakdowns.

        Args:
            records: List of categorised spend record dicts.
            title: Optional report title.
            format: Output format (json, csv, markdown, html, text).

        Returns:
            CategorizationReport with rendered content.
        """
        start = time.monotonic()
        title = title or "Spend Categorization Report"
        fmt = self._validate_format(format)

        # Build summary data
        summary = self._build_categorization_summary(records)

        # Render
        content = self._render_categorization(summary, title, fmt)

        return self._build_report(
            "categorization", title, fmt, content, len(records), start,
        )

    def generate_emissions_report(
        self,
        records: List[Dict[str, Any]],
        calculations: List[Dict[str, Any]],
        format: str = "markdown",
    ) -> CategorizationReport:
        """Generate an emissions calculation report.

        Shows total emissions, Scope 3 category breakdown, emission
        factors used, and top emitters.

        Args:
            records: List of spend record dicts.
            calculations: List of emission calculation result dicts.
            format: Output format.

        Returns:
            CategorizationReport with rendered content.
        """
        start = time.monotonic()
        title = "Spend-Based Emissions Report"
        fmt = self._validate_format(format)

        summary = self._build_emissions_summary(records, calculations)
        content = self._render_emissions(summary, title, fmt)

        return self._build_report(
            "emissions", title, fmt, content, len(records), start,
        )

    def generate_audit_report(
        self,
        records: List[Dict[str, Any]],
        classifications: List[Dict[str, Any]],
        format: str = "json",
    ) -> CategorizationReport:
        """Generate an audit trail report.

        Shows provenance hashes, rule matches, data lineage, and
        classification decisions for compliance auditing.

        Args:
            records: List of spend record dicts.
            classifications: List of classification result dicts.
            format: Output format (defaults to JSON for auditability).

        Returns:
            CategorizationReport with rendered content.
        """
        start = time.monotonic()
        title = "Spend Categorization Audit Report"
        fmt = self._validate_format(format)

        summary = self._build_audit_summary(records, classifications)
        content = self._render_audit(summary, title, fmt)

        return self._build_report(
            "audit", title, fmt, content, len(records), start,
        )

    def generate_procurement_report(
        self,
        records: List[Dict[str, Any]],
        analytics: Dict[str, Any],
        format: str = "markdown",
    ) -> CategorizationReport:
        """Generate a procurement analytics report.

        Shows vendor spend analysis, Pareto/ABC classification,
        concentration metrics, and category breakdowns.

        Args:
            records: List of spend record dicts.
            analytics: Analytics results dict (from SpendAnalyticsEngine).
            format: Output format.

        Returns:
            CategorizationReport with rendered content.
        """
        start = time.monotonic()
        title = "Procurement Spend Analytics Report"
        fmt = self._validate_format(format)

        summary = self._build_procurement_summary(records, analytics)
        content = self._render_procurement(summary, title, fmt)

        return self._build_report(
            "procurement", title, fmt, content, len(records), start,
        )

    def generate_executive_summary(
        self,
        analytics: Dict[str, Any],
        format: str = "markdown",
    ) -> CategorizationReport:
        """Generate an executive summary report.

        Provides high-level KPIs, trend indicators, benchmark
        comparison, and strategic recommendations.

        Args:
            analytics: Comprehensive analytics dict.
            format: Output format.

        Returns:
            CategorizationReport with rendered content.
        """
        start = time.monotonic()
        title = "Executive Summary - Spend Emissions Analysis"
        fmt = self._validate_format(format)

        content = self._render_executive(analytics, title, fmt)

        record_count = int(analytics.get("record_count", 0))
        return self._build_report(
            "executive", title, fmt, content, record_count, start,
        )

    # ------------------------------------------------------------------
    # Public API - Record export
    # ------------------------------------------------------------------

    def export_records(
        self,
        records: List[Dict[str, Any]],
        format: str = "csv",
    ) -> str:
        """Export records in the specified format.

        Args:
            records: List of record dicts.
            format: Export format (csv or json).

        Returns:
            Exported content as string.
        """
        fmt = format.lower().strip()
        if fmt == "csv":
            return self.format_csv(records)
        elif fmt == "json":
            return self.format_json(records)
        else:
            return self.format_json(records)

    # ------------------------------------------------------------------
    # Public API - Format helpers
    # ------------------------------------------------------------------

    def format_text(self, data: Any) -> str:
        """Format data as plain text.

        Args:
            data: Data to format (dict, list, or string).

        Returns:
            Plain text representation.
        """
        if isinstance(data, str):
            return data
        if isinstance(data, dict):
            lines: List[str] = []
            for key, value in data.items():
                if isinstance(value, (dict, list)):
                    lines.append(f"{key}:")
                    lines.append(f"  {json.dumps(value, default=str, indent=2)}")
                else:
                    lines.append(f"{key}: {value}")
            return "\n".join(lines)
        if isinstance(data, list):
            return json.dumps(data, indent=2, default=str)
        return str(data)

    def format_json(self, data: Any) -> str:
        """Format data as JSON string.

        Args:
            data: Data to format.

        Returns:
            JSON string.
        """
        return json.dumps(data, indent=2, default=str)

    def format_markdown(self, data: Any) -> str:
        """Format data as Markdown.

        Args:
            data: Data to format (dict or list).

        Returns:
            Markdown string.
        """
        if isinstance(data, str):
            return data
        if isinstance(data, dict):
            return self._dict_to_markdown(data)
        if isinstance(data, list):
            return self._list_to_markdown_table(data)
        return str(data)

    def format_html(self, data: Any) -> str:
        """Format data as HTML.

        Args:
            data: Data to format (dict or list).

        Returns:
            HTML string.
        """
        if isinstance(data, str):
            return f"<pre>{data}</pre>"
        if isinstance(data, dict):
            return self._dict_to_html_table(data)
        if isinstance(data, list):
            return self._list_to_html_table(data)
        return f"<pre>{str(data)}</pre>"

    def format_csv(self, data: Any) -> str:
        """Format data as CSV string.

        Args:
            data: List of dicts to format.

        Returns:
            CSV string.
        """
        if not isinstance(data, list) or not data:
            return ""

        output = io.StringIO()
        if isinstance(data[0], dict):
            fieldnames = list(data[0].keys())
            writer = csv.DictWriter(output, fieldnames=fieldnames)
            writer.writeheader()
            for row in data:
                writer.writerow({k: str(v) for k, v in row.items()})
        else:
            writer_simple = csv.writer(output)
            for row in data:
                writer_simple.writerow([str(row)])

        return output.getvalue()

    def get_statistics(self) -> Dict[str, Any]:
        """Return cumulative reporting statistics.

        Returns:
            Dictionary with generation counters and breakdowns.
        """
        with self._lock:
            stats = dict(self._stats)
            stats["by_type"] = dict(self._stats["by_type"])
            stats["by_format"] = dict(self._stats["by_format"])
        stats["reports_stored"] = len(self._reports)
        stats["supported_formats"] = sorted(_SUPPORTED_FORMATS)
        return stats

    # ------------------------------------------------------------------
    # Internal - Summary builders
    # ------------------------------------------------------------------

    def _build_categorization_summary(
        self,
        records: List[Dict[str, Any]],
    ) -> Dict[str, Any]:
        """Build summary data for categorisation report.

        Args:
            records: Categorised spend records.

        Returns:
            Summary dict.
        """
        total = len(records)
        classified = sum(
            1 for r in records
            if r.get("taxonomy_code") or r.get("category") or r.get("scope3_category")
        )
        total_spend = sum(float(r.get("amount_usd", 0) or 0) for r in records)

        # Confidence distribution
        conf_bins = {"high": 0, "medium": 0, "low": 0, "none": 0}
        for r in records:
            conf = float(r.get("confidence", 0) or 0)
            if conf >= 0.8:
                conf_bins["high"] += 1
            elif conf >= 0.5:
                conf_bins["medium"] += 1
            elif conf > 0:
                conf_bins["low"] += 1
            else:
                conf_bins["none"] += 1

        # By taxonomy system
        by_system: Dict[str, int] = defaultdict(int)
        for r in records:
            sys = str(r.get("taxonomy_system", "unknown"))
            by_system[sys] += 1

        # By category
        by_cat: Dict[str, Dict[str, Any]] = defaultdict(
            lambda: {"count": 0, "spend": 0.0},
        )
        for r in records:
            cat = str(r.get("scope3_category", r.get("category", "Unknown")))
            by_cat[cat]["count"] += 1
            by_cat[cat]["spend"] += float(r.get("amount_usd", 0) or 0)

        return {
            "total_records": total,
            "classified_records": classified,
            "coverage_rate": round(classified / total * 100, 2) if total > 0 else 0.0,
            "total_spend_usd": round(total_spend, 2),
            "confidence_distribution": conf_bins,
            "by_taxonomy_system": dict(by_system),
            "by_category": {
                k: {"count": v["count"], "spend_usd": round(v["spend"], 2)}
                for k, v in sorted(by_cat.items())
            },
        }

    def _build_emissions_summary(
        self,
        records: List[Dict[str, Any]],
        calculations: List[Dict[str, Any]],
    ) -> Dict[str, Any]:
        """Build summary data for emissions report.

        Args:
            records: Spend records.
            calculations: Emission calculation results.

        Returns:
            Summary dict.
        """
        total_spend = sum(float(r.get("amount_usd", 0) or 0) for r in records)
        total_emissions = sum(float(c.get("emissions_kgco2e", 0) or 0) for c in calculations)
        total_tco2e = round(total_emissions / 1000, 4)
        intensity = round(total_emissions / total_spend, 6) if total_spend > 0 else 0.0

        # By Scope 3 category
        by_scope3: Dict[str, Dict[str, float]] = defaultdict(
            lambda: {"spend": 0.0, "emissions": 0.0, "count": 0},
        )
        for c in calculations:
            cat = str(c.get("scope3_category", c.get("category_name", "Unknown")))
            by_scope3[cat]["spend"] += float(c.get("spend_usd", 0) or 0)
            by_scope3[cat]["emissions"] += float(c.get("emissions_kgco2e", 0) or 0)
            by_scope3[cat]["count"] += 1

        # By factor source
        by_source: Dict[str, int] = defaultdict(int)
        for c in calculations:
            src = str(c.get("factor_source", "unknown"))
            by_source[src] += 1

        return {
            "total_spend_usd": round(total_spend, 2),
            "total_emissions_kgco2e": round(total_emissions, 4),
            "total_emissions_tco2e": total_tco2e,
            "intensity_kgco2e_per_usd": intensity,
            "record_count": len(records),
            "calculation_count": len(calculations),
            "by_scope3_category": {
                k: {
                    "spend_usd": round(v["spend"], 2),
                    "emissions_kgco2e": round(v["emissions"], 4),
                    "count": int(v["count"]),
                }
                for k, v in sorted(by_scope3.items())
            },
            "by_factor_source": dict(by_source),
        }

    def _build_audit_summary(
        self,
        records: List[Dict[str, Any]],
        classifications: List[Dict[str, Any]],
    ) -> Dict[str, Any]:
        """Build summary data for audit report.

        Args:
            records: Spend records.
            classifications: Classification results.

        Returns:
            Summary dict with provenance details.
        """
        provenance_hashes = [
            r.get("provenance_hash", "") for r in records if r.get("provenance_hash")
        ]
        classification_hashes = [
            c.get("provenance_hash", "") for c in classifications if c.get("provenance_hash")
        ]

        # By match source
        by_match_source: Dict[str, int] = defaultdict(int)
        for c in classifications:
            src = str(c.get("match_source", c.get("match_type", "unknown")))
            by_match_source[src] += 1

        return {
            "total_records": len(records),
            "total_classifications": len(classifications),
            "records_with_provenance": len(provenance_hashes),
            "classifications_with_provenance": len(classification_hashes),
            "provenance_coverage_pct": round(
                len(provenance_hashes) / len(records) * 100, 2
            ) if records else 0.0,
            "by_match_source": dict(by_match_source),
            "audit_entries": [
                {
                    "record_id": r.get("record_id", ""),
                    "provenance_hash": r.get("provenance_hash", ""),
                    "classification_code": classifications[i].get("code", "") if i < len(classifications) else "",
                    "classification_confidence": classifications[i].get("confidence", 0) if i < len(classifications) else 0,
                }
                for i, r in enumerate(records[:100])  # Limit to 100 entries
            ],
        }

    def _build_procurement_summary(
        self,
        records: List[Dict[str, Any]],
        analytics: Dict[str, Any],
    ) -> Dict[str, Any]:
        """Build summary for procurement report.

        Args:
            records: Spend records.
            analytics: Analytics results.

        Returns:
            Summary dict.
        """
        total_spend = sum(float(r.get("amount_usd", 0) or 0) for r in records)
        vendor_count = len(set(str(r.get("vendor_name", "")) for r in records))

        return {
            "total_spend_usd": round(total_spend, 2),
            "record_count": len(records),
            "vendor_count": vendor_count,
            "analytics": analytics,
        }

    # ------------------------------------------------------------------
    # Internal - Renderers
    # ------------------------------------------------------------------

    def _render_categorization(
        self,
        summary: Dict[str, Any],
        title: str,
        fmt: str,
    ) -> str:
        """Render categorisation report in the specified format.

        Args:
            summary: Summary data.
            title: Report title.
            fmt: Output format.

        Returns:
            Rendered content string.
        """
        if fmt == "json":
            return self.format_json(summary)

        if fmt == "csv":
            rows = []
            for cat, data in summary.get("by_category", {}).items():
                rows.append({"category": cat, **data})
            return self.format_csv(rows)

        if fmt == "text":
            lines = [
                title,
                "=" * len(title),
                "",
                f"Total Records: {summary['total_records']}",
                f"Classified: {summary['classified_records']}",
                f"Coverage: {summary['coverage_rate']}%",
                f"Total Spend: ${summary['total_spend_usd']:,.2f}",
                "",
                "Confidence Distribution:",
            ]
            for level, count in summary["confidence_distribution"].items():
                lines.append(f"  {level}: {count}")
            lines.append("")
            lines.append("By Category:")
            for cat, data in summary.get("by_category", {}).items():
                lines.append(f"  {cat}: {data['count']} records, ${data['spend_usd']:,.2f}")
            return "\n".join(lines)

        if fmt == "html":
            html_content = self._categorization_html(summary)
            return _HTML_TEMPLATE.format(
                title=title,
                timestamp=_utcnow().isoformat(),
                report_id=_generate_id("rpt"),
                content=html_content,
                provenance_hash=self._compute_provenance(title, summary),
            )

        # Markdown (default)
        lines = [
            f"# {title}",
            "",
            f"**Generated:** {_utcnow().isoformat()}",
            "",
            "## Summary",
            "",
            f"| Metric | Value |",
            f"|--------|-------|",
            f"| Total Records | {summary['total_records']} |",
            f"| Classified | {summary['classified_records']} |",
            f"| Coverage Rate | {summary['coverage_rate']}% |",
            f"| Total Spend | ${summary['total_spend_usd']:,.2f} |",
            "",
            "## Confidence Distribution",
            "",
            "| Level | Count |",
            "|-------|-------|",
        ]
        for level, count in summary["confidence_distribution"].items():
            lines.append(f"| {level.title()} | {count} |")

        lines.extend(["", "## Category Breakdown", ""])
        lines.append("| Category | Records | Spend (USD) |")
        lines.append("|----------|---------|-------------|")
        for cat, data in summary.get("by_category", {}).items():
            lines.append(f"| {cat} | {data['count']} | ${data['spend_usd']:,.2f} |")

        return "\n".join(lines)

    def _render_emissions(
        self,
        summary: Dict[str, Any],
        title: str,
        fmt: str,
    ) -> str:
        """Render emissions report.

        Args:
            summary: Summary data.
            title: Report title.
            fmt: Output format.

        Returns:
            Rendered content string.
        """
        if fmt == "json":
            return self.format_json(summary)

        if fmt == "csv":
            rows = []
            for cat, data in summary.get("by_scope3_category", {}).items():
                rows.append({"scope3_category": cat, **data})
            return self.format_csv(rows)

        if fmt == "text":
            lines = [
                title,
                "=" * len(title),
                "",
                f"Total Spend: ${summary['total_spend_usd']:,.2f}",
                f"Total Emissions: {summary['total_emissions_kgco2e']:,.4f} kgCO2e",
                f"Total Emissions: {summary['total_emissions_tco2e']:,.4f} tCO2e",
                f"Intensity: {summary['intensity_kgco2e_per_usd']:.6f} kgCO2e/USD",
                "",
                "By Scope 3 Category:",
            ]
            for cat, data in summary.get("by_scope3_category", {}).items():
                lines.append(
                    f"  {cat}: {data['emissions_kgco2e']:,.4f} kgCO2e "
                    f"(${data['spend_usd']:,.2f}, {data['count']} records)"
                )
            return "\n".join(lines)

        if fmt == "html":
            html_content = self._emissions_html(summary)
            return _HTML_TEMPLATE.format(
                title=title,
                timestamp=_utcnow().isoformat(),
                report_id=_generate_id("rpt"),
                content=html_content,
                provenance_hash=self._compute_provenance(title, summary),
            )

        # Markdown
        lines = [
            f"# {title}",
            "",
            f"**Generated:** {_utcnow().isoformat()}",
            "",
            "## Key Metrics",
            "",
            "| Metric | Value |",
            "|--------|-------|",
            f"| Total Spend | ${summary['total_spend_usd']:,.2f} |",
            f"| Total Emissions | {summary['total_emissions_kgco2e']:,.4f} kgCO2e |",
            f"| Total Emissions | {summary['total_emissions_tco2e']:,.4f} tCO2e |",
            f"| Intensity | {summary['intensity_kgco2e_per_usd']:.6f} kgCO2e/USD |",
            "",
            "## Scope 3 Category Breakdown",
            "",
            "| Category | Spend (USD) | Emissions (kgCO2e) | Records |",
            "|----------|-------------|---------------------|---------|",
        ]
        for cat, data in summary.get("by_scope3_category", {}).items():
            lines.append(
                f"| {cat} | ${data['spend_usd']:,.2f} | "
                f"{data['emissions_kgco2e']:,.4f} | {data['count']} |"
            )
        return "\n".join(lines)

    def _render_audit(
        self,
        summary: Dict[str, Any],
        title: str,
        fmt: str,
    ) -> str:
        """Render audit report.

        Args:
            summary: Summary data.
            title: Report title.
            fmt: Output format.

        Returns:
            Rendered content string.
        """
        if fmt == "json":
            return self.format_json(summary)

        if fmt == "csv":
            return self.format_csv(summary.get("audit_entries", []))

        if fmt == "text":
            lines = [
                title,
                "=" * len(title),
                "",
                f"Total Records: {summary['total_records']}",
                f"Total Classifications: {summary['total_classifications']}",
                f"Provenance Coverage: {summary['provenance_coverage_pct']}%",
                "",
                "Match Source Distribution:",
            ]
            for src, count in summary.get("by_match_source", {}).items():
                lines.append(f"  {src}: {count}")
            return "\n".join(lines)

        # Markdown (and HTML render via markdown)
        lines = [
            f"# {title}",
            "",
            f"**Generated:** {_utcnow().isoformat()}",
            "",
            "## Audit Summary",
            "",
            f"| Metric | Value |",
            f"|--------|-------|",
            f"| Total Records | {summary['total_records']} |",
            f"| Classifications | {summary['total_classifications']} |",
            f"| Provenance Coverage | {summary['provenance_coverage_pct']}% |",
        ]

        if fmt == "html":
            return _HTML_TEMPLATE.format(
                title=title,
                timestamp=_utcnow().isoformat(),
                report_id=_generate_id("rpt"),
                content="\n".join(lines),
                provenance_hash=self._compute_provenance(title, summary),
            )

        return "\n".join(lines)

    def _render_procurement(
        self,
        summary: Dict[str, Any],
        title: str,
        fmt: str,
    ) -> str:
        """Render procurement report.

        Args:
            summary: Summary data.
            title: Report title.
            fmt: Output format.

        Returns:
            Rendered content string.
        """
        if fmt == "json":
            return self.format_json(summary)

        lines = [
            f"# {title}",
            "",
            f"**Generated:** {_utcnow().isoformat()}",
            "",
            "## Procurement Summary",
            "",
            f"| Metric | Value |",
            f"|--------|-------|",
            f"| Total Spend | ${summary['total_spend_usd']:,.2f} |",
            f"| Total Records | {summary['record_count']} |",
            f"| Unique Vendors | {summary['vendor_count']} |",
        ]

        analytics = summary.get("analytics", {})
        if "hhi" in analytics:
            lines.extend([
                "",
                "## Concentration Metrics",
                "",
                f"| Metric | Value |",
                f"|--------|-------|",
                f"| HHI | {analytics.get('hhi', 'N/A')} |",
                f"| CR4 | {analytics.get('cr4', 'N/A')} |",
                f"| Interpretation | {analytics.get('interpretation', 'N/A')} |",
            ])

        if fmt == "html":
            return _HTML_TEMPLATE.format(
                title=title,
                timestamp=_utcnow().isoformat(),
                report_id=_generate_id("rpt"),
                content="\n".join(lines),
                provenance_hash=self._compute_provenance(title, summary),
            )

        if fmt == "text":
            return "\n".join(lines).replace("#", "").replace("|", " ").replace("-", "")

        if fmt == "csv":
            return self.format_csv([summary])

        return "\n".join(lines)

    def _render_executive(
        self,
        analytics: Dict[str, Any],
        title: str,
        fmt: str,
    ) -> str:
        """Render executive summary report.

        Args:
            analytics: Comprehensive analytics dict.
            title: Report title.
            fmt: Output format.

        Returns:
            Rendered content string.
        """
        if fmt == "json":
            return self.format_json(analytics)

        total_spend = analytics.get("total_spend_usd", 0)
        total_emissions = analytics.get("total_emissions_kgco2e", 0)
        intensity = analytics.get("intensity_kgco2e_per_usd", 0)

        lines = [
            f"# {title}",
            "",
            f"**Generated:** {_utcnow().isoformat()}",
            "",
            "## Key Performance Indicators",
            "",
            f"| KPI | Value |",
            f"|-----|-------|",
            f"| Total Spend | ${total_spend:,.2f} |",
            f"| Total Emissions | {total_emissions:,.2f} kgCO2e |",
            f"| Emissions Intensity | {intensity:.6f} kgCO2e/USD |",
            f"| Records Analysed | {analytics.get('record_count', 0)} |",
        ]

        if "performance_rating" in analytics:
            lines.extend([
                "",
                "## Benchmark Comparison",
                "",
                f"- Performance Rating: **{analytics.get('performance_rating', 'N/A')}**",
                f"- Industry: {analytics.get('industry', 'N/A')}",
                f"- Benchmark Intensity: {analytics.get('benchmark_intensity_kgco2e_per_usd', 'N/A')} kgCO2e/USD",
                f"- Intensity Gap: {analytics.get('intensity_gap_pct', 0):.2f}%",
            ])

        lines.extend([
            "",
            "## Recommendations",
            "",
            "1. Focus reduction efforts on highest-intensity categories",
            "2. Engage top suppliers on emission factor improvements",
            "3. Transition to supplier-specific emission factors where possible",
            "4. Set science-based targets for Scope 3 reduction",
            "5. Implement quarterly emissions tracking and reporting",
        ])

        if fmt == "html":
            return _HTML_TEMPLATE.format(
                title=title,
                timestamp=_utcnow().isoformat(),
                report_id=_generate_id("rpt"),
                content="\n".join(lines),
                provenance_hash=self._compute_provenance(title, analytics),
            )

        if fmt == "text":
            return "\n".join(lines).replace("#", "").replace("**", "")

        if fmt == "csv":
            return self.format_csv([analytics])

        return "\n".join(lines)

    # ------------------------------------------------------------------
    # Internal - HTML helpers
    # ------------------------------------------------------------------

    def _categorization_html(self, summary: Dict[str, Any]) -> str:
        """Build HTML content for categorisation report.

        Args:
            summary: Summary data.

        Returns:
            HTML body content.
        """
        parts = [
            '<div class="summary-box">',
            '<div class="kpi"><div class="kpi-value">'
            f'{summary["total_records"]}</div><div class="kpi-label">Total Records</div></div>',
            '<div class="kpi"><div class="kpi-value">'
            f'{summary["coverage_rate"]}%</div><div class="kpi-label">Coverage</div></div>',
            '<div class="kpi"><div class="kpi-value">'
            f'${summary["total_spend_usd"]:,.0f}</div><div class="kpi-label">Total Spend</div></div>',
            '</div>',
            '<h2>Category Breakdown</h2>',
            '<table><tr><th>Category</th><th>Records</th><th>Spend (USD)</th></tr>',
        ]
        for cat, data in summary.get("by_category", {}).items():
            parts.append(
                f'<tr><td>{cat}</td><td>{data["count"]}</td>'
                f'<td>${data["spend_usd"]:,.2f}</td></tr>'
            )
        parts.append('</table>')
        return "\n".join(parts)

    def _emissions_html(self, summary: Dict[str, Any]) -> str:
        """Build HTML content for emissions report.

        Args:
            summary: Summary data.

        Returns:
            HTML body content.
        """
        parts = [
            '<div class="summary-box">',
            '<div class="kpi"><div class="kpi-value">'
            f'{summary["total_emissions_tco2e"]:,.2f}</div><div class="kpi-label">tCO2e</div></div>',
            '<div class="kpi"><div class="kpi-value">'
            f'${summary["total_spend_usd"]:,.0f}</div><div class="kpi-label">Total Spend</div></div>',
            '<div class="kpi"><div class="kpi-value">'
            f'{summary["intensity_kgco2e_per_usd"]:.4f}</div><div class="kpi-label">Intensity</div></div>',
            '</div>',
            '<h2>Scope 3 Category Breakdown</h2>',
            '<table><tr><th>Category</th><th>Spend (USD)</th><th>Emissions (kgCO2e)</th><th>Records</th></tr>',
        ]
        for cat, data in summary.get("by_scope3_category", {}).items():
            parts.append(
                f'<tr><td>{cat}</td><td>${data["spend_usd"]:,.2f}</td>'
                f'<td>{data["emissions_kgco2e"]:,.4f}</td><td>{data["count"]}</td></tr>'
            )
        parts.append('</table>')
        return "\n".join(parts)

    # ------------------------------------------------------------------
    # Internal - Markdown helpers
    # ------------------------------------------------------------------

    def _dict_to_markdown(self, data: Dict[str, Any]) -> str:
        """Convert a dict to Markdown key-value pairs.

        Args:
            data: Dictionary.

        Returns:
            Markdown string.
        """
        lines: List[str] = []
        for key, value in data.items():
            if isinstance(value, dict):
                lines.append(f"\n### {key}\n")
                lines.append(self._dict_to_markdown(value))
            elif isinstance(value, list):
                lines.append(f"\n### {key}\n")
                lines.append(self._list_to_markdown_table(value))
            else:
                lines.append(f"- **{key}**: {value}")
        return "\n".join(lines)

    def _list_to_markdown_table(self, data: List[Any]) -> str:
        """Convert a list of dicts to a Markdown table.

        Args:
            data: List of dicts.

        Returns:
            Markdown table string.
        """
        if not data or not isinstance(data[0], dict):
            return "\n".join(f"- {item}" for item in data)

        headers = list(data[0].keys())
        lines = [
            "| " + " | ".join(headers) + " |",
            "| " + " | ".join("---" for _ in headers) + " |",
        ]
        for row in data:
            values = [str(row.get(h, "")) for h in headers]
            lines.append("| " + " | ".join(values) + " |")
        return "\n".join(lines)

    def _dict_to_html_table(self, data: Dict[str, Any]) -> str:
        """Convert a dict to an HTML table.

        Args:
            data: Dictionary.

        Returns:
            HTML table string.
        """
        rows = [
            f"<tr><th>{k}</th><td>{v}</td></tr>"
            for k, v in data.items()
        ]
        return f"<table>{''.join(rows)}</table>"

    def _list_to_html_table(self, data: List[Any]) -> str:
        """Convert a list of dicts to an HTML table.

        Args:
            data: List of dicts.

        Returns:
            HTML table string.
        """
        if not data or not isinstance(data[0], dict):
            items = "".join(f"<li>{item}</li>" for item in data)
            return f"<ul>{items}</ul>"

        headers = list(data[0].keys())
        header_html = "".join(f"<th>{h}</th>" for h in headers)
        rows_html = ""
        for row in data:
            cells = "".join(f"<td>{row.get(h, '')}</td>" for h in headers)
            rows_html += f"<tr>{cells}</tr>"
        return f"<table><tr>{header_html}</tr>{rows_html}</table>"

    # ------------------------------------------------------------------
    # Internal - Report building
    # ------------------------------------------------------------------

    def _build_report(
        self,
        report_type: str,
        title: str,
        fmt: str,
        content: str,
        record_count: int,
        start_time: float,
    ) -> CategorizationReport:
        """Build and store a CategorizationReport.

        Args:
            report_type: Report type.
            title: Report title.
            fmt: Output format.
            content: Rendered content.
            record_count: Source record count.
            start_time: monotonic start time.

        Returns:
            CategorizationReport.
        """
        elapsed = (time.monotonic() - start_time) * 1000
        rid = _generate_id("rpt")
        now_iso = _utcnow().isoformat()

        provenance_hash = self._compute_provenance(title, {"content_length": len(content)})

        report = CategorizationReport(
            report_id=rid,
            report_type=report_type,
            title=title,
            format=fmt,
            content=content,
            record_count=record_count,
            generated_at=now_iso,
            processing_time_ms=round(elapsed, 2),
            provenance_hash=provenance_hash,
        )

        with self._lock:
            self._reports[rid] = report
            self._stats["reports_generated"] += 1
            self._stats["total_records_reported"] += record_count
            type_counts = self._stats["by_type"]
            type_counts[report_type] = type_counts.get(report_type, 0) + 1
            fmt_counts = self._stats["by_format"]
            fmt_counts[fmt] = fmt_counts.get(fmt, 0) + 1

        logger.info(
            "Generated %s report (%s): %d records, %d chars (%.1f ms)",
            report_type, fmt, record_count, len(content), elapsed,
        )
        return report

    def _validate_format(self, fmt: str) -> str:
        """Validate and normalise a format string.

        Args:
            fmt: Raw format string.

        Returns:
            Normalised format string.
        """
        normalised = fmt.lower().strip()
        if normalised not in _SUPPORTED_FORMATS:
            logger.warning(
                "Unsupported format '%s', falling back to '%s'",
                fmt, self._default_format,
            )
            return self._default_format
        return normalised

    # ------------------------------------------------------------------
    # Internal - Provenance
    # ------------------------------------------------------------------

    def _compute_provenance(
        self,
        title: str,
        data: Any,
    ) -> str:
        """Compute SHA-256 provenance hash for a report.

        Args:
            title: Report title.
            data: Report data (summary or content).

        Returns:
            Hex-encoded SHA-256 hash.
        """
        payload = json.dumps({
            "title": title,
            "data": str(data)[:1000],
            "timestamp": _utcnow().isoformat(),
        }, sort_keys=True)
        return hashlib.sha256(payload.encode("utf-8")).hexdigest()
