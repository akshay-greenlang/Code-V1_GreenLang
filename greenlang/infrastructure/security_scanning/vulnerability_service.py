# -*- coding: utf-8 -*-
"""
Vulnerability Management Service - SEC-007 Security Scanning Pipeline

Centralized service for vulnerability tracking, prioritization, and lifecycle
management. Ingests findings from all security scanners, performs CVE
deduplication, calculates risk scores, and tracks remediation SLA compliance.

Architecture:
    Scanners -> Orchestrator -> VulnerabilityService.ingest_findings()
                                    |
                                    v
                            Deduplication (CVE/fingerprint)
                                    |
                                    v
                            Risk Scoring (CVSS + EPSS + KEV)
                                    |
                                    v
                            PostgreSQL: security.vulnerabilities

Key Features:
    - CVE-based deduplication across multiple scanners
    - Risk scoring: CVSS 3.1 + EPSS + CISA KEV + asset criticality
    - SLA tracking with automatic due date calculation
    - Risk acceptance workflow with approval chain
    - Integration with audit logging

Author: GreenLang Framework Team
Date: February 2026
PRD: SEC-007 Security Scanning Pipeline
Status: Production Ready
"""

from __future__ import annotations

import asyncio
import hashlib
import logging
from dataclasses import dataclass, field
from datetime import datetime, timedelta
from enum import Enum
from typing import Any, Dict, List, Optional, Tuple
from uuid import UUID, uuid4

logger = logging.getLogger(__name__)


# ---------------------------------------------------------------------------
# Enums
# ---------------------------------------------------------------------------


class VulnerabilitySeverity(str, Enum):
    """Vulnerability severity levels (CVSS 3.1 qualitative mapping)."""

    CRITICAL = "critical"
    HIGH = "high"
    MEDIUM = "medium"
    LOW = "low"
    INFO = "info"


class VulnerabilityStatus(str, Enum):
    """Vulnerability lifecycle status."""

    OPEN = "open"
    IN_PROGRESS = "in_progress"
    RESOLVED = "resolved"
    ACCEPTED = "accepted"
    FALSE_POSITIVE = "false_positive"
    WONT_FIX = "wont_fix"


class ExceptionType(str, Enum):
    """Risk exception types."""

    RISK_ACCEPTANCE = "risk_acceptance"
    FALSE_POSITIVE = "false_positive"
    WONT_FIX = "wont_fix"
    DEFERRED = "deferred"
    COMPENSATING_CONTROL = "compensating_control"


# ---------------------------------------------------------------------------
# Data Models
# ---------------------------------------------------------------------------


@dataclass
class ScanFinding:
    """Individual scanner finding for ingestion."""

    scanner: str
    finding_type: str
    severity: str
    message: str
    file_path: Optional[str] = None
    line_start: Optional[int] = None
    line_end: Optional[int] = None
    code_snippet: Optional[str] = None
    cve: Optional[str] = None
    cwe: Optional[str] = None
    rule_id: Optional[str] = None
    confidence: str = "high"
    raw_data: Dict[str, Any] = field(default_factory=dict)
    package_name: Optional[str] = None
    package_version: Optional[str] = None
    fixed_version: Optional[str] = None
    scan_run_id: Optional[UUID] = None
    tenant_id: Optional[UUID] = None


@dataclass
class Vulnerability:
    """Vulnerability record with full details."""

    id: UUID
    cve: Optional[str]
    title: str
    description: Optional[str]
    severity: VulnerabilitySeverity
    status: VulnerabilityStatus
    cvss_score: Optional[float]
    epss_score: Optional[float]
    risk_score: float
    is_exploited: bool
    is_kev: bool
    discovered_at: datetime
    sla_due_at: Optional[datetime]
    resolved_at: Optional[datetime]
    package_name: Optional[str]
    package_version: Optional[str]
    fixed_version: Optional[str]
    remediation_guidance: Optional[str]
    findings_count: int = 0
    tenant_id: Optional[UUID] = None


@dataclass
class VulnerabilityFilter:
    """Filter criteria for vulnerability queries."""

    severities: Optional[List[VulnerabilitySeverity]] = None
    statuses: Optional[List[VulnerabilityStatus]] = None
    cve: Optional[str] = None
    scanner: Optional[str] = None
    package_name: Optional[str] = None
    is_kev: Optional[bool] = None
    sla_breached: Optional[bool] = None
    since: Optional[datetime] = None
    until: Optional[datetime] = None
    tenant_id: Optional[UUID] = None
    limit: int = 100
    offset: int = 0


@dataclass
class SLAReport:
    """SLA compliance report."""

    total_open: int
    within_sla: int
    approaching_sla: int
    breached_sla: int
    by_severity: Dict[str, Dict[str, int]]
    oldest_breach: Optional[datetime]
    average_age_days: float


@dataclass
class RiskAcceptance:
    """Risk acceptance record."""

    vulnerability_id: UUID
    exception_type: ExceptionType
    reason: str
    business_justification: Optional[str]
    compensating_controls: Optional[str]
    approved_by: str
    expires_at: Optional[datetime]
    is_permanent: bool = False


# ---------------------------------------------------------------------------
# Service Configuration
# ---------------------------------------------------------------------------


@dataclass
class VulnerabilityServiceConfig:
    """Configuration for VulnerabilityService.

    Attributes:
        batch_size: Maximum findings to process per batch.
        auto_dedupe: Enable automatic CVE deduplication.
        auto_risk_score: Enable automatic risk score calculation.
        enable_audit_logging: Log all operations to audit service.
        default_sla_days: Default SLA days if not configured.
    """

    batch_size: int = 1000
    auto_dedupe: bool = True
    auto_risk_score: bool = True
    enable_audit_logging: bool = True
    default_sla_days: Dict[str, int] = field(default_factory=lambda: {
        "critical": 1,
        "high": 7,
        "medium": 30,
        "low": 90,
        "info": 365,
    })


# ---------------------------------------------------------------------------
# Vulnerability Service
# ---------------------------------------------------------------------------


class VulnerabilityService:
    """Centralized vulnerability management service.

    Manages the full vulnerability lifecycle from discovery through
    remediation, including deduplication, risk scoring, SLA tracking,
    and risk acceptance workflows.

    Example:
        >>> service = VulnerabilityService(db_pool=pool)
        >>> vulns = await service.ingest_findings(findings)
        >>> report = await service.get_sla_status()
        >>> print(f"Breached SLAs: {report.breached_sla}")
    """

    def __init__(
        self,
        db_pool: Optional[Any] = None,
        config: Optional[VulnerabilityServiceConfig] = None,
        risk_scorer: Optional[Any] = None,
        audit_service: Optional[Any] = None,
    ) -> None:
        """Initialize VulnerabilityService.

        Args:
            db_pool: Async PostgreSQL connection pool.
            config: Service configuration.
            risk_scorer: Optional RiskScorer instance for risk calculation.
            audit_service: Optional AuditService for audit logging.
        """
        self._db_pool = db_pool
        self._config = config or VulnerabilityServiceConfig()
        self._risk_scorer = risk_scorer
        self._audit_service = audit_service
        self._sla_cache: Dict[str, int] = {}

    # -------------------------------------------------------------------------
    # Finding Ingestion
    # -------------------------------------------------------------------------

    async def ingest_findings(
        self,
        findings: List[ScanFinding],
        scan_run_id: Optional[UUID] = None,
    ) -> List[Vulnerability]:
        """Ingest findings from scanners and create/update vulnerabilities.

        This is the main entry point for processing scan results. Findings
        are deduplicated by CVE or fingerprint, risk scores are calculated,
        and SLA due dates are set automatically.

        Args:
            findings: List of scanner findings to ingest.
            scan_run_id: Optional scan run ID for linking.

        Returns:
            List of created or updated Vulnerability records.
        """
        if not findings:
            return []

        logger.info(
            "Ingesting %d findings from scan_run_id=%s",
            len(findings), scan_run_id
        )

        vulnerabilities: List[Vulnerability] = []
        processed_cves: set = set()

        for finding in findings:
            try:
                # Calculate fingerprint for deduplication
                fingerprint = self._calculate_fingerprint(finding)

                # Check for existing vulnerability
                existing_vuln = await self._find_existing_vulnerability(
                    finding, fingerprint
                )

                if existing_vuln:
                    # Update existing vulnerability with new finding
                    await self._add_finding_to_vulnerability(
                        existing_vuln.id, finding, fingerprint, scan_run_id
                    )
                    vulnerabilities.append(existing_vuln)
                else:
                    # Create new vulnerability
                    vuln = await self._create_vulnerability(
                        finding, fingerprint, scan_run_id
                    )
                    vulnerabilities.append(vuln)

                # Track processed CVEs
                if finding.cve and finding.cve not in processed_cves:
                    processed_cves.add(finding.cve)

            except Exception as e:
                logger.error(
                    "Failed to ingest finding: scanner=%s, cve=%s, error=%s",
                    finding.scanner, finding.cve, str(e)
                )
                continue

        logger.info(
            "Ingested %d findings -> %d vulnerabilities (%d unique CVEs)",
            len(findings), len(vulnerabilities), len(processed_cves)
        )

        # Audit log
        if self._config.enable_audit_logging and self._audit_service:
            await self._log_audit_event(
                "vulnerability.ingestion",
                metadata={
                    "findings_count": len(findings),
                    "vulnerabilities_count": len(vulnerabilities),
                    "scan_run_id": str(scan_run_id) if scan_run_id else None,
                }
            )

        return vulnerabilities

    # -------------------------------------------------------------------------
    # Vulnerability Queries
    # -------------------------------------------------------------------------

    async def get_vulnerabilities(
        self,
        filters: Optional[VulnerabilityFilter] = None,
    ) -> List[Vulnerability]:
        """Query vulnerabilities with optional filters.

        Args:
            filters: Filter criteria for the query.

        Returns:
            List of matching Vulnerability records.
        """
        filters = filters or VulnerabilityFilter()

        if self._db_pool is None:
            logger.warning("Database pool not configured, returning empty list")
            return []

        # Build query
        query = """
            SELECT
                v.id, v.cve, v.title, v.description, v.severity, v.status,
                v.cvss_score, v.epss_score, v.risk_score, v.is_exploited,
                v.is_kev, v.discovered_at, v.sla_due_at, v.resolved_at,
                v.package_name, v.package_version, v.fixed_version,
                v.remediation_guidance, v.tenant_id,
                COUNT(f.id) AS findings_count
            FROM security.vulnerabilities v
            LEFT JOIN security.findings f ON f.vulnerability_id = v.id
            WHERE 1=1
        """
        params: List[Any] = []
        param_idx = 1

        if filters.severities:
            query += f" AND v.severity = ANY(${param_idx})"
            params.append([s.value for s in filters.severities])
            param_idx += 1

        if filters.statuses:
            query += f" AND v.status = ANY(${param_idx})"
            params.append([s.value for s in filters.statuses])
            param_idx += 1

        if filters.cve:
            query += f" AND v.cve = ${param_idx}"
            params.append(filters.cve)
            param_idx += 1

        if filters.package_name:
            query += f" AND v.package_name ILIKE ${param_idx}"
            params.append(f"%{filters.package_name}%")
            param_idx += 1

        if filters.is_kev is not None:
            query += f" AND v.is_kev = ${param_idx}"
            params.append(filters.is_kev)
            param_idx += 1

        if filters.sla_breached is not None:
            if filters.sla_breached:
                query += " AND v.sla_due_at < NOW() AND v.status = 'open'"
            else:
                query += " AND (v.sla_due_at >= NOW() OR v.status != 'open')"

        if filters.since:
            query += f" AND v.discovered_at >= ${param_idx}"
            params.append(filters.since)
            param_idx += 1

        if filters.until:
            query += f" AND v.discovered_at <= ${param_idx}"
            params.append(filters.until)
            param_idx += 1

        if filters.tenant_id:
            query += f" AND v.tenant_id = ${param_idx}"
            params.append(filters.tenant_id)
            param_idx += 1

        query += """
            GROUP BY v.id
            ORDER BY
                CASE v.severity
                    WHEN 'critical' THEN 1
                    WHEN 'high' THEN 2
                    WHEN 'medium' THEN 3
                    WHEN 'low' THEN 4
                    ELSE 5
                END,
                v.risk_score DESC,
                v.discovered_at DESC
        """

        query += f" LIMIT ${param_idx} OFFSET ${param_idx + 1}"
        params.extend([filters.limit, filters.offset])

        try:
            async with self._db_pool.acquire() as conn:
                rows = await conn.fetch(query, *params)
                return [self._row_to_vulnerability(row) for row in rows]
        except Exception as e:
            logger.error("Failed to query vulnerabilities: %s", e)
            raise

    async def get_vulnerability(
        self,
        vulnerability_id: UUID,
    ) -> Optional[Vulnerability]:
        """Get a single vulnerability by ID.

        Args:
            vulnerability_id: The vulnerability UUID.

        Returns:
            Vulnerability record or None if not found.
        """
        if self._db_pool is None:
            return None

        query = """
            SELECT
                v.id, v.cve, v.title, v.description, v.severity, v.status,
                v.cvss_score, v.epss_score, v.risk_score, v.is_exploited,
                v.is_kev, v.discovered_at, v.sla_due_at, v.resolved_at,
                v.package_name, v.package_version, v.fixed_version,
                v.remediation_guidance, v.tenant_id,
                COUNT(f.id) AS findings_count
            FROM security.vulnerabilities v
            LEFT JOIN security.findings f ON f.vulnerability_id = v.id
            WHERE v.id = $1
            GROUP BY v.id
        """

        try:
            async with self._db_pool.acquire() as conn:
                row = await conn.fetchrow(query, vulnerability_id)
                return self._row_to_vulnerability(row) if row else None
        except Exception as e:
            logger.error("Failed to get vulnerability %s: %s", vulnerability_id, e)
            raise

    # -------------------------------------------------------------------------
    # Risk Acceptance
    # -------------------------------------------------------------------------

    async def accept_risk(
        self,
        acceptance: RiskAcceptance,
    ) -> bool:
        """Accept risk for a vulnerability (create exception).

        Args:
            acceptance: Risk acceptance details.

        Returns:
            True if acceptance was recorded successfully.

        Raises:
            ValueError: If vulnerability not found or already resolved.
        """
        # Verify vulnerability exists and is open
        vuln = await self.get_vulnerability(acceptance.vulnerability_id)
        if not vuln:
            raise ValueError(f"Vulnerability {acceptance.vulnerability_id} not found")
        if vuln.status == VulnerabilityStatus.RESOLVED:
            raise ValueError("Cannot accept risk for resolved vulnerability")

        if self._db_pool is None:
            logger.warning("Database pool not configured")
            return False

        # Create exception record
        exception_query = """
            INSERT INTO security.exceptions (
                vulnerability_id, exception_type, reason, business_justification,
                compensating_controls, approved_by, expires_at, is_permanent
            ) VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
            RETURNING id
        """

        # Update vulnerability status
        vuln_query = """
            UPDATE security.vulnerabilities
            SET status = 'accepted', updated_at = NOW()
            WHERE id = $1
        """

        try:
            async with self._db_pool.acquire() as conn:
                async with conn.transaction():
                    await conn.execute(
                        exception_query,
                        acceptance.vulnerability_id,
                        acceptance.exception_type.value,
                        acceptance.reason,
                        acceptance.business_justification,
                        acceptance.compensating_controls,
                        acceptance.approved_by,
                        acceptance.expires_at,
                        acceptance.is_permanent,
                    )
                    await conn.execute(vuln_query, acceptance.vulnerability_id)

            logger.info(
                "Risk accepted for vulnerability %s by %s",
                acceptance.vulnerability_id, acceptance.approved_by
            )

            # Audit log
            if self._config.enable_audit_logging and self._audit_service:
                await self._log_audit_event(
                    "vulnerability.risk_accepted",
                    metadata={
                        "vulnerability_id": str(acceptance.vulnerability_id),
                        "exception_type": acceptance.exception_type.value,
                        "approved_by": acceptance.approved_by,
                        "is_permanent": acceptance.is_permanent,
                    }
                )

            return True

        except Exception as e:
            logger.error(
                "Failed to accept risk for %s: %s",
                acceptance.vulnerability_id, e
            )
            raise

    # -------------------------------------------------------------------------
    # Remediation
    # -------------------------------------------------------------------------

    async def mark_remediated(
        self,
        vulnerability_id: UUID,
        remediated_by: Optional[str] = None,
        notes: Optional[str] = None,
    ) -> bool:
        """Mark a vulnerability as remediated.

        Args:
            vulnerability_id: The vulnerability UUID.
            remediated_by: User who performed remediation.
            notes: Optional remediation notes.

        Returns:
            True if marked successfully.
        """
        if self._db_pool is None:
            logger.warning("Database pool not configured")
            return False

        query = """
            UPDATE security.vulnerabilities
            SET
                status = 'resolved',
                resolved_at = NOW(),
                updated_at = NOW()
            WHERE id = $1 AND status != 'resolved'
            RETURNING id
        """

        try:
            async with self._db_pool.acquire() as conn:
                result = await conn.fetchrow(query, vulnerability_id)

            if result:
                logger.info(
                    "Vulnerability %s marked as remediated by %s",
                    vulnerability_id, remediated_by
                )

                # Audit log
                if self._config.enable_audit_logging and self._audit_service:
                    await self._log_audit_event(
                        "vulnerability.remediated",
                        metadata={
                            "vulnerability_id": str(vulnerability_id),
                            "remediated_by": remediated_by,
                            "notes": notes,
                        }
                    )

                return True
            else:
                logger.warning(
                    "Vulnerability %s not found or already resolved",
                    vulnerability_id
                )
                return False

        except Exception as e:
            logger.error(
                "Failed to mark %s as remediated: %s",
                vulnerability_id, e
            )
            raise

    # -------------------------------------------------------------------------
    # SLA Reporting
    # -------------------------------------------------------------------------

    async def get_sla_status(
        self,
        tenant_id: Optional[UUID] = None,
    ) -> SLAReport:
        """Get SLA compliance status report.

        Args:
            tenant_id: Optional tenant filter.

        Returns:
            SLAReport with compliance metrics.
        """
        if self._db_pool is None:
            return SLAReport(
                total_open=0,
                within_sla=0,
                approaching_sla=0,
                breached_sla=0,
                by_severity={},
                oldest_breach=None,
                average_age_days=0.0,
            )

        query = """
            WITH sla_data AS (
                SELECT
                    v.id,
                    v.severity,
                    v.discovered_at,
                    v.sla_due_at,
                    CASE
                        WHEN v.sla_due_at < NOW() THEN 'breached'
                        WHEN v.sla_due_at < NOW() + INTERVAL '2 days' THEN 'approaching'
                        ELSE 'within'
                    END AS sla_status,
                    EXTRACT(EPOCH FROM (NOW() - v.discovered_at)) / 86400 AS age_days
                FROM security.vulnerabilities v
                WHERE v.status = 'open'
        """

        params: List[Any] = []
        if tenant_id:
            query += " AND v.tenant_id = $1"
            params.append(tenant_id)

        query += """
            )
            SELECT
                COUNT(*) AS total_open,
                COUNT(*) FILTER (WHERE sla_status = 'within') AS within_sla,
                COUNT(*) FILTER (WHERE sla_status = 'approaching') AS approaching_sla,
                COUNT(*) FILTER (WHERE sla_status = 'breached') AS breached_sla,
                MIN(CASE WHEN sla_status = 'breached' THEN sla_due_at END) AS oldest_breach,
                AVG(age_days) AS average_age_days,
                severity,
                COUNT(*) FILTER (WHERE sla_status = 'within') AS sev_within,
                COUNT(*) FILTER (WHERE sla_status = 'breached') AS sev_breached
            FROM sla_data
            GROUP BY severity
        """

        try:
            async with self._db_pool.acquire() as conn:
                rows = await conn.fetch(query, *params)

            if not rows:
                return SLAReport(
                    total_open=0,
                    within_sla=0,
                    approaching_sla=0,
                    breached_sla=0,
                    by_severity={},
                    oldest_breach=None,
                    average_age_days=0.0,
                )

            # Aggregate results
            total_open = 0
            within_sla = 0
            approaching_sla = 0
            breached_sla = 0
            oldest_breach = None
            age_sum = 0.0
            by_severity: Dict[str, Dict[str, int]] = {}

            for row in rows:
                total_open += row["total_open"] or 0
                within_sla += row["within_sla"] or 0
                approaching_sla += row["approaching_sla"] or 0
                breached_sla += row["breached_sla"] or 0

                if row["oldest_breach"]:
                    if oldest_breach is None or row["oldest_breach"] < oldest_breach:
                        oldest_breach = row["oldest_breach"]

                age_sum += (row["average_age_days"] or 0) * (row["total_open"] or 0)

                severity = row["severity"]
                by_severity[severity] = {
                    "within": row["sev_within"] or 0,
                    "breached": row["sev_breached"] or 0,
                }

            return SLAReport(
                total_open=total_open,
                within_sla=within_sla,
                approaching_sla=approaching_sla,
                breached_sla=breached_sla,
                by_severity=by_severity,
                oldest_breach=oldest_breach,
                average_age_days=age_sum / total_open if total_open > 0 else 0.0,
            )

        except Exception as e:
            logger.error("Failed to get SLA status: %s", e)
            raise

    # -------------------------------------------------------------------------
    # Statistics
    # -------------------------------------------------------------------------

    async def get_statistics(
        self,
        since: Optional[datetime] = None,
        until: Optional[datetime] = None,
        tenant_id: Optional[UUID] = None,
    ) -> Dict[str, Any]:
        """Get vulnerability statistics for dashboard.

        Args:
            since: Start of time range.
            until: End of time range.
            tenant_id: Optional tenant filter.

        Returns:
            Dictionary with various statistics.
        """
        if self._db_pool is None:
            return {}

        query = """
            SELECT
                COUNT(*) AS total,
                COUNT(*) FILTER (WHERE status = 'open') AS open_count,
                COUNT(*) FILTER (WHERE status = 'resolved') AS resolved_count,
                COUNT(*) FILTER (WHERE status = 'accepted') AS accepted_count,
                COUNT(*) FILTER (WHERE severity = 'critical') AS critical_count,
                COUNT(*) FILTER (WHERE severity = 'high') AS high_count,
                COUNT(*) FILTER (WHERE severity = 'medium') AS medium_count,
                COUNT(*) FILTER (WHERE severity = 'low') AS low_count,
                COUNT(*) FILTER (WHERE is_kev = TRUE) AS kev_count,
                COUNT(*) FILTER (WHERE sla_due_at < NOW() AND status = 'open') AS sla_breached,
                AVG(risk_score) FILTER (WHERE status = 'open') AS avg_risk_score,
                AVG(EXTRACT(EPOCH FROM (resolved_at - discovered_at)) / 86400)
                    FILTER (WHERE resolved_at IS NOT NULL) AS avg_mttr_days
            FROM security.vulnerabilities
            WHERE 1=1
        """

        params: List[Any] = []
        param_idx = 1

        if since:
            query += f" AND discovered_at >= ${param_idx}"
            params.append(since)
            param_idx += 1

        if until:
            query += f" AND discovered_at <= ${param_idx}"
            params.append(until)
            param_idx += 1

        if tenant_id:
            query += f" AND tenant_id = ${param_idx}"
            params.append(tenant_id)

        try:
            async with self._db_pool.acquire() as conn:
                row = await conn.fetchrow(query, *params)

            if not row:
                return {}

            return {
                "total": row["total"] or 0,
                "open": row["open_count"] or 0,
                "resolved": row["resolved_count"] or 0,
                "accepted": row["accepted_count"] or 0,
                "by_severity": {
                    "critical": row["critical_count"] or 0,
                    "high": row["high_count"] or 0,
                    "medium": row["medium_count"] or 0,
                    "low": row["low_count"] or 0,
                },
                "kev_count": row["kev_count"] or 0,
                "sla_breached": row["sla_breached"] or 0,
                "avg_risk_score": round(row["avg_risk_score"] or 0, 2),
                "avg_mttr_days": round(row["avg_mttr_days"] or 0, 1),
            }

        except Exception as e:
            logger.error("Failed to get statistics: %s", e)
            raise

    # -------------------------------------------------------------------------
    # Internal Methods
    # -------------------------------------------------------------------------

    def _calculate_fingerprint(self, finding: ScanFinding) -> str:
        """Calculate a unique fingerprint for deduplication.

        Args:
            finding: The scanner finding.

        Returns:
            SHA-256 fingerprint string.
        """
        components = [
            finding.scanner,
            finding.finding_type,
            finding.cve or "",
            finding.cwe or "",
            finding.rule_id or "",
            finding.file_path or "",
            finding.package_name or "",
            finding.package_version or "",
            finding.message[:200] if finding.message else "",
        ]

        fingerprint_str = "|".join(str(c) for c in components)
        return hashlib.sha256(fingerprint_str.encode()).hexdigest()[:64]

    async def _find_existing_vulnerability(
        self,
        finding: ScanFinding,
        fingerprint: str,
    ) -> Optional[Vulnerability]:
        """Find existing vulnerability by CVE or fingerprint.

        Args:
            finding: The scanner finding.
            fingerprint: Calculated fingerprint.

        Returns:
            Existing Vulnerability or None.
        """
        if self._db_pool is None:
            return None

        # First try by CVE (most reliable)
        if finding.cve:
            query = """
                SELECT v.id FROM security.vulnerabilities v
                WHERE v.cve = $1
                LIMIT 1
            """
            async with self._db_pool.acquire() as conn:
                row = await conn.fetchrow(query, finding.cve)
                if row:
                    return await self.get_vulnerability(row["id"])

        # Then try by fingerprint
        query = """
            SELECT f.vulnerability_id FROM security.findings f
            WHERE f.fingerprint = $1 AND f.vulnerability_id IS NOT NULL
            LIMIT 1
        """
        async with self._db_pool.acquire() as conn:
            row = await conn.fetchrow(query, fingerprint)
            if row:
                return await self.get_vulnerability(row["vulnerability_id"])

        return None

    async def _create_vulnerability(
        self,
        finding: ScanFinding,
        fingerprint: str,
        scan_run_id: Optional[UUID],
    ) -> Vulnerability:
        """Create a new vulnerability from a finding.

        Args:
            finding: The scanner finding.
            fingerprint: Calculated fingerprint.
            scan_run_id: Optional scan run ID.

        Returns:
            Created Vulnerability record.
        """
        vuln_id = uuid4()
        severity = VulnerabilitySeverity(finding.severity.lower())

        # Calculate risk score
        risk_score = 0.0
        if self._risk_scorer and self._config.auto_risk_score:
            risk_score = await self._risk_scorer.calculate_risk_score(
                cvss_score=None,
                epss_score=None,
                is_kev=False,
                asset_criticality="medium",
            )
        else:
            # Default risk score based on severity
            risk_score = {
                VulnerabilitySeverity.CRITICAL: 9.0,
                VulnerabilitySeverity.HIGH: 7.0,
                VulnerabilitySeverity.MEDIUM: 5.0,
                VulnerabilitySeverity.LOW: 3.0,
                VulnerabilitySeverity.INFO: 1.0,
            }.get(severity, 5.0)

        # Calculate SLA due date
        sla_days = self._config.default_sla_days.get(severity.value, 30)
        sla_due_at = datetime.utcnow() + timedelta(days=sla_days)

        title = finding.cve or finding.message[:100] if finding.message else "Unknown"

        if self._db_pool:
            query = """
                INSERT INTO security.vulnerabilities (
                    id, cve, cwe, title, description, severity, status,
                    risk_score, discovered_at, sla_due_at,
                    package_name, package_version, fixed_version,
                    tenant_id
                ) VALUES (
                    $1, $2, $3, $4, $5, $6, 'open',
                    $7, NOW(), $8,
                    $9, $10, $11,
                    $12
                )
            """

            async with self._db_pool.acquire() as conn:
                await conn.execute(
                    query,
                    vuln_id,
                    finding.cve,
                    finding.cwe,
                    title,
                    finding.message,
                    severity.value,
                    risk_score,
                    sla_due_at,
                    finding.package_name,
                    finding.package_version,
                    finding.fixed_version,
                    finding.tenant_id,
                )

            # Add the finding
            await self._add_finding_to_vulnerability(
                vuln_id, finding, fingerprint, scan_run_id
            )

        return Vulnerability(
            id=vuln_id,
            cve=finding.cve,
            title=title,
            description=finding.message,
            severity=severity,
            status=VulnerabilityStatus.OPEN,
            cvss_score=None,
            epss_score=None,
            risk_score=risk_score,
            is_exploited=False,
            is_kev=False,
            discovered_at=datetime.utcnow(),
            sla_due_at=sla_due_at,
            resolved_at=None,
            package_name=finding.package_name,
            package_version=finding.package_version,
            fixed_version=finding.fixed_version,
            remediation_guidance=None,
            findings_count=1,
            tenant_id=finding.tenant_id,
        )

    async def _add_finding_to_vulnerability(
        self,
        vulnerability_id: UUID,
        finding: ScanFinding,
        fingerprint: str,
        scan_run_id: Optional[UUID],
    ) -> None:
        """Add a finding record linked to a vulnerability.

        Args:
            vulnerability_id: The vulnerability UUID.
            finding: The scanner finding.
            fingerprint: Calculated fingerprint.
            scan_run_id: Optional scan run ID.
        """
        if self._db_pool is None:
            return

        query = """
            INSERT INTO security.findings (
                vulnerability_id, scanner, scan_run_id, finding_type,
                severity, confidence, file_path, line_start, line_end,
                code_snippet, fingerprint, rule_id, cve, cwe, message,
                raw_data, tenant_id
            ) VALUES (
                $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17
            )
            ON CONFLICT (fingerprint) DO UPDATE SET
                updated_at = NOW()
        """

        try:
            async with self._db_pool.acquire() as conn:
                await conn.execute(
                    query,
                    vulnerability_id,
                    finding.scanner,
                    scan_run_id or finding.scan_run_id,
                    finding.finding_type,
                    finding.severity.lower(),
                    finding.confidence.lower(),
                    finding.file_path,
                    finding.line_start,
                    finding.line_end,
                    finding.code_snippet,
                    fingerprint,
                    finding.rule_id,
                    finding.cve,
                    finding.cwe,
                    finding.message,
                    finding.raw_data,
                    finding.tenant_id,
                )
        except Exception as e:
            logger.error("Failed to add finding: %s", e)

    def _row_to_vulnerability(self, row: Any) -> Vulnerability:
        """Convert database row to Vulnerability object.

        Args:
            row: Database row record.

        Returns:
            Vulnerability instance.
        """
        return Vulnerability(
            id=row["id"],
            cve=row["cve"],
            title=row["title"],
            description=row["description"],
            severity=VulnerabilitySeverity(row["severity"]),
            status=VulnerabilityStatus(row["status"]),
            cvss_score=float(row["cvss_score"]) if row["cvss_score"] else None,
            epss_score=float(row["epss_score"]) if row["epss_score"] else None,
            risk_score=float(row["risk_score"]),
            is_exploited=row["is_exploited"],
            is_kev=row["is_kev"],
            discovered_at=row["discovered_at"],
            sla_due_at=row["sla_due_at"],
            resolved_at=row["resolved_at"],
            package_name=row["package_name"],
            package_version=row["package_version"],
            fixed_version=row["fixed_version"],
            remediation_guidance=row["remediation_guidance"],
            findings_count=row["findings_count"] if "findings_count" in row.keys() else 0,
            tenant_id=row["tenant_id"],
        )

    async def _log_audit_event(
        self,
        event_type: str,
        metadata: Dict[str, Any],
    ) -> None:
        """Log an audit event.

        Args:
            event_type: Event type identifier.
            metadata: Event metadata.
        """
        if self._audit_service:
            try:
                await self._audit_service.log_data_event(
                    event_type=event_type,
                    resource_type="vulnerability",
                    metadata=metadata,
                )
            except Exception as e:
                logger.warning("Failed to log audit event: %s", e)


# ---------------------------------------------------------------------------
# Global Instance
# ---------------------------------------------------------------------------

_global_vulnerability_service: Optional[VulnerabilityService] = None


def get_vulnerability_service() -> Optional[VulnerabilityService]:
    """Get the global vulnerability service instance.

    Returns:
        The global VulnerabilityService or None if not configured.
    """
    return _global_vulnerability_service


async def configure_vulnerability_service(
    db_pool: Optional[Any] = None,
    config: Optional[VulnerabilityServiceConfig] = None,
    risk_scorer: Optional[Any] = None,
    audit_service: Optional[Any] = None,
) -> VulnerabilityService:
    """Configure the global vulnerability service.

    Args:
        db_pool: Async PostgreSQL connection pool.
        config: Service configuration.
        risk_scorer: Optional RiskScorer instance.
        audit_service: Optional AuditService instance.

    Returns:
        The configured VulnerabilityService.
    """
    global _global_vulnerability_service

    _global_vulnerability_service = VulnerabilityService(
        db_pool=db_pool,
        config=config,
        risk_scorer=risk_scorer,
        audit_service=audit_service,
    )

    logger.info("VulnerabilityService configured")
    return _global_vulnerability_service


__all__ = [
    "VulnerabilityService",
    "VulnerabilityServiceConfig",
    "VulnerabilitySeverity",
    "VulnerabilityStatus",
    "ExceptionType",
    "ScanFinding",
    "Vulnerability",
    "VulnerabilityFilter",
    "SLAReport",
    "RiskAcceptance",
    "get_vulnerability_service",
    "configure_vulnerability_service",
]
