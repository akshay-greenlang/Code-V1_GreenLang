# -*- coding: utf-8 -*-
"""
VDP API Routes - SEC-010

FastAPI routes for the Vulnerability Disclosure Program.
Provides endpoints for vulnerability submission, status tracking,
triage workflow, bounty management, and the public hall of fame.

Routes:
    Public (No Auth):
        POST /submit - Submit vulnerability report
        GET /status/{submission_id} - Check submission status
        GET /hall-of-fame - Public hall of fame

    Internal (Auth Required):
        GET /submissions - List all submissions
        GET /submissions/{id} - Get full submission details
        PUT /submissions/{id}/triage - Begin triage
        PUT /submissions/{id}/confirm - Confirm vulnerability
        PUT /submissions/{id}/reject - Reject submission
        PUT /submissions/{id}/close - Close submission
        POST /submissions/{id}/bounty - Award bounty
        GET /metrics - VDP metrics
"""

from __future__ import annotations

import logging
from datetime import datetime, timezone
from typing import Any, Dict, List, Optional

from fastapi import APIRouter, Depends, HTTPException, Query, status
from pydantic import BaseModel, EmailStr, Field

from greenlang.infrastructure.vulnerability_disclosure.bounty_processor import (
    BountyProcessor,
)
from greenlang.infrastructure.vulnerability_disclosure.config import get_config
from greenlang.infrastructure.vulnerability_disclosure.disclosure_tracker import (
    DisclosureTracker,
)
from greenlang.infrastructure.vulnerability_disclosure.models import (
    Severity,
    Submission,
    SubmissionStatus,
    VulnerabilityReport,
)
from greenlang.infrastructure.vulnerability_disclosure.researcher_manager import (
    ResearcherManager,
)
from greenlang.infrastructure.vulnerability_disclosure.submission_handler import (
    DuplicateSubmissionError,
    RateLimitError,
    ValidationError,
    VulnerabilitySubmissionHandler,
)
from greenlang.infrastructure.vulnerability_disclosure.triage_workflow import (
    InvalidTransitionError,
    SubmissionNotFoundError,
    TriageWorkflow,
)

logger = logging.getLogger(__name__)

router = APIRouter(tags=["VDP - Vulnerability Disclosure Program"])


# ---------------------------------------------------------------------------
# Request/Response Models
# ---------------------------------------------------------------------------


class SubmitVulnerabilityRequest(BaseModel):
    """Request model for submitting a vulnerability report."""

    title: str = Field(
        ...,
        min_length=5,
        max_length=200,
        description="Brief summary of the vulnerability.",
    )
    description: str = Field(
        ...,
        min_length=20,
        max_length=50000,
        description="Detailed description of the security issue.",
    )
    steps_to_reproduce: List[str] = Field(
        ...,
        min_length=1,
        max_length=50,
        description="Ordered steps to reproduce the vulnerability.",
    )
    impact: str = Field(
        ...,
        min_length=10,
        max_length=5000,
        description="Description of security impact if exploited.",
    )
    affected_component: str = Field(
        ...,
        min_length=1,
        max_length=200,
        description="Service, module, or feature affected.",
    )
    proof_of_concept: Optional[str] = Field(
        default=None,
        max_length=100000,
        description="Code, screenshots, or video links.",
    )
    suggested_fix: Optional[str] = Field(
        default=None,
        max_length=10000,
        description="Suggested remediation approach.",
    )
    references: List[str] = Field(
        default_factory=list,
        max_length=20,
        description="Related CVEs or security advisories.",
    )
    researcher_email: EmailStr = Field(
        ...,
        description="Contact email for the researcher.",
    )
    researcher_name: Optional[str] = Field(
        default=None,
        max_length=200,
        description="Display name for hall of fame.",
    )
    pgp_key: Optional[str] = Field(
        default=None,
        max_length=10000,
        description="PGP public key for encrypted communications.",
    )


class SubmitVulnerabilityResponse(BaseModel):
    """Response model for successful vulnerability submission."""

    submission_id: str = Field(..., description="Unique submission ID.")
    status: str = Field(..., description="Initial submission status.")
    submitted_at: str = Field(..., description="Submission timestamp (ISO 8601).")
    acknowledgment_expected_by: str = Field(
        ...,
        description="Expected acknowledgment deadline (ISO 8601).",
    )
    message: str = Field(..., description="Confirmation message.")


class SubmissionStatusResponse(BaseModel):
    """Public status response for a submission."""

    submission_id: str = Field(..., description="Unique submission ID.")
    status: str = Field(..., description="Current status.")
    submitted_at: str = Field(..., description="Submission timestamp.")
    acknowledged_at: Optional[str] = Field(
        default=None,
        description="Acknowledgment timestamp.",
    )
    severity: Optional[str] = Field(
        default=None,
        description="Assessed severity (after triage).",
    )
    disclosure_deadline: Optional[str] = Field(
        default=None,
        description="Disclosure deadline (after confirmation).",
    )


class SubmissionDetailResponse(BaseModel):
    """Full submission details for internal use."""

    id: str
    submission_id: str
    title: str
    description: str
    affected_component: str
    status: str
    severity: Optional[str]
    cvss_score: Optional[float]
    cvss_vector: Optional[str]
    researcher_email: str
    bounty_amount: int
    bounty_currency: str
    submitted_at: str
    acknowledged_at: Optional[str]
    triaged_at: Optional[str]
    confirmed_at: Optional[str]
    fixed_at: Optional[str]
    disclosed_at: Optional[str]
    closed_at: Optional[str]
    disclosure_deadline: Optional[str]
    notes: List[str]


class TriageRequest(BaseModel):
    """Request model for beginning triage."""

    assessor_id: str = Field(..., description="Security analyst user ID.")


class ConfirmRequest(BaseModel):
    """Request model for confirming a vulnerability."""

    severity: str = Field(
        ...,
        description="Severity level (critical, high, medium, low, informational).",
    )
    cvss_score: float = Field(..., ge=0.0, le=10.0, description="CVSS 3.1 score.")
    cvss_vector: Optional[str] = Field(default=None, description="CVSS vector string.")


class RejectRequest(BaseModel):
    """Request model for rejecting a submission."""

    reason: str = Field(
        ...,
        min_length=10,
        max_length=2000,
        description="Reason for rejection.",
    )


class AwardBountyRequest(BaseModel):
    """Request model for awarding a bounty."""

    amount_cents: Optional[int] = Field(
        default=None,
        ge=0,
        description="Bounty amount in cents. If not provided, auto-calculated.",
    )
    quality_factors: List[str] = Field(
        default_factory=list,
        description="Quality factors for bonus calculation.",
    )
    impact_factors: List[str] = Field(
        default_factory=list,
        description="Impact factors for bonus calculation.",
    )
    notes: str = Field(default="", description="Payment notes.")


class AwardBountyResponse(BaseModel):
    """Response model for bounty award."""

    payment_id: str
    submission_id: str
    amount_usd: float
    status: str
    message: str


class HallOfFameEntry(BaseModel):
    """Hall of fame entry."""

    rank: int
    name: str
    reputation_score: int
    valid_submissions: int
    member_since: str
    bounties_earned_usd: Optional[float] = None


class HallOfFameResponse(BaseModel):
    """Hall of fame response."""

    researchers: List[HallOfFameEntry]
    total_count: int
    last_updated: str


class VDPMetricsResponse(BaseModel):
    """VDP metrics response."""

    total_submissions: int
    by_status: Dict[str, int]
    by_severity: Dict[str, int]
    pending_triage: int
    upcoming_disclosures: int
    total_bounties_paid_usd: float
    average_triage_time_hours: float
    average_fix_time_days: float


class SubmissionListResponse(BaseModel):
    """Paginated list of submissions."""

    items: List[SubmissionDetailResponse]
    total: int
    page: int
    page_size: int
    total_pages: int


# ---------------------------------------------------------------------------
# Service Dependencies
# ---------------------------------------------------------------------------

# Shared service instances (would be replaced with proper DI in production)
_handler: Optional[VulnerabilitySubmissionHandler] = None
_workflow: Optional[TriageWorkflow] = None
_tracker: Optional[DisclosureTracker] = None
_researcher_mgr: Optional[ResearcherManager] = None
_bounty_proc: Optional[BountyProcessor] = None


def get_services() -> tuple:
    """Get or create shared service instances."""
    global _handler, _workflow, _tracker, _researcher_mgr, _bounty_proc

    if _handler is None:
        _handler = VulnerabilitySubmissionHandler()
        _workflow = TriageWorkflow()
        _tracker = DisclosureTracker()
        _researcher_mgr = ResearcherManager()
        _bounty_proc = BountyProcessor()

        # Wire up shared storage
        _workflow.set_submissions(_handler._submissions)
        _tracker.set_submissions(_handler._submissions)
        _researcher_mgr.set_submissions(_handler._submissions)
        _researcher_mgr.set_researchers(_handler._researchers)
        _bounty_proc.set_submissions(_handler._submissions)
        _bounty_proc.set_researchers(_handler._researchers)

    return _handler, _workflow, _tracker, _researcher_mgr, _bounty_proc


# ---------------------------------------------------------------------------
# Public Endpoints (No Authentication Required)
# ---------------------------------------------------------------------------


@router.post(
    "/submit",
    response_model=SubmitVulnerabilityResponse,
    status_code=status.HTTP_201_CREATED,
    summary="Submit Vulnerability Report",
    description="Submit a new vulnerability report. This is a public endpoint.",
)
async def submit_vulnerability(
    request: SubmitVulnerabilityRequest,
) -> SubmitVulnerabilityResponse:
    """Submit a new vulnerability report.

    This endpoint is PUBLIC and does not require authentication.
    Rate limited to 5 submissions per hour, 20 per day per email.
    """
    handler, _, _, _, _ = get_services()
    config = get_config()

    try:
        # Build vulnerability report
        report = VulnerabilityReport(
            title=request.title,
            description=request.description,
            steps_to_reproduce=request.steps_to_reproduce,
            impact=request.impact,
            affected_component=request.affected_component,
            proof_of_concept=request.proof_of_concept,
            suggested_fix=request.suggested_fix,
            references=request.references,
        )

        # Submit
        submission = await handler.submit(
            report=report,
            researcher_email=request.researcher_email,
            researcher_name=request.researcher_name,
            pgp_key=request.pgp_key,
        )

        # Calculate expected acknowledgment deadline
        ack_deadline = submission.submitted_at.replace(
            hour=submission.submitted_at.hour + config.auto_acknowledge_hours
        )

        return SubmitVulnerabilityResponse(
            submission_id=submission.submission_id,
            status=submission.status.value,
            submitted_at=submission.submitted_at.isoformat(),
            acknowledgment_expected_by=ack_deadline.isoformat(),
            message=(
                f"Thank you for your submission. You will receive acknowledgment "
                f"within {config.auto_acknowledge_hours} hours."
            ),
        )

    except RateLimitError as e:
        raise HTTPException(
            status_code=status.HTTP_429_TOO_MANY_REQUESTS,
            detail=str(e),
        )
    except DuplicateSubmissionError as e:
        raise HTTPException(
            status_code=status.HTTP_409_CONFLICT,
            detail=f"Duplicate submission detected: {e.original_id}",
        )
    except ValidationError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e),
        )
    except Exception as e:
        logger.error("Failed to process submission: %s", str(e), exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to process submission",
        )


@router.get(
    "/status/{submission_id}",
    response_model=SubmissionStatusResponse,
    summary="Check Submission Status",
    description="Check the status of a vulnerability submission. Public endpoint.",
)
async def get_submission_status(
    submission_id: str,
) -> SubmissionStatusResponse:
    """Get the public status of a submission.

    This endpoint is PUBLIC and returns limited information.
    """
    handler, _, _, _, _ = get_services()

    try:
        status_info = await handler.get_submission_status(submission_id)
        return SubmissionStatusResponse(**status_info)
    except Exception as e:
        if "not found" in str(e).lower():
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Submission not found: {submission_id}",
            )
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve status",
        )


@router.get(
    "/hall-of-fame",
    response_model=HallOfFameResponse,
    summary="Public Hall of Fame",
    description="Get the public hall of fame leaderboard.",
)
async def get_hall_of_fame(
    limit: int = Query(default=20, ge=1, le=100, description="Number of entries"),
    include_bounties: bool = Query(
        default=True, description="Include bounty totals"
    ),
) -> HallOfFameResponse:
    """Get the public hall of fame.

    This endpoint is PUBLIC.
    """
    _, _, _, researcher_mgr, _ = get_services()

    try:
        entries = await researcher_mgr.get_hall_of_fame(
            limit=limit,
            include_bounty_totals=include_bounties,
        )

        return HallOfFameResponse(
            researchers=[HallOfFameEntry(**entry) for entry in entries],
            total_count=len(entries),
            last_updated=datetime.now(timezone.utc).isoformat(),
        )
    except Exception as e:
        logger.error("Failed to get hall of fame: %s", str(e), exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve hall of fame",
        )


# ---------------------------------------------------------------------------
# Internal Endpoints (Authentication Required)
# ---------------------------------------------------------------------------


@router.get(
    "/submissions",
    response_model=SubmissionListResponse,
    summary="List Submissions",
    description="List all vulnerability submissions. Requires authentication.",
)
async def list_submissions(
    status_filter: Optional[str] = Query(
        default=None,
        alias="status",
        description="Filter by status",
    ),
    severity_filter: Optional[str] = Query(
        default=None,
        alias="severity",
        description="Filter by severity",
    ),
    page: int = Query(default=1, ge=1, description="Page number"),
    page_size: int = Query(default=20, ge=1, le=100, description="Items per page"),
) -> SubmissionListResponse:
    """List all submissions with filtering.

    Requires secops:vdp:read permission.
    """
    handler, _, _, _, _ = get_services()

    try:
        # Parse filters
        status_enum = None
        if status_filter:
            try:
                status_enum = SubmissionStatus(status_filter.lower())
            except ValueError:
                pass

        severity_enum = None
        if severity_filter:
            try:
                severity_enum = Severity(severity_filter.lower())
            except ValueError:
                pass

        # Get submissions
        offset = (page - 1) * page_size
        submissions = await handler.list_submissions(
            status=status_enum,
            severity=severity_enum,
            limit=page_size,
            offset=offset,
        )

        # Build response
        items = [
            _submission_to_detail(sub)
            for sub in submissions
        ]

        # Get total count (simplified - would be a separate count query in prod)
        all_subs = await handler.list_submissions(
            status=status_enum,
            severity=severity_enum,
            limit=10000,
            offset=0,
        )
        total = len(all_subs)
        total_pages = (total + page_size - 1) // page_size

        return SubmissionListResponse(
            items=items,
            total=total,
            page=page,
            page_size=page_size,
            total_pages=total_pages,
        )
    except Exception as e:
        logger.error("Failed to list submissions: %s", str(e), exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to list submissions",
        )


@router.get(
    "/submissions/{submission_id}",
    response_model=SubmissionDetailResponse,
    summary="Get Submission Details",
    description="Get full details for a submission. Requires authentication.",
)
async def get_submission_details(
    submission_id: str,
) -> SubmissionDetailResponse:
    """Get full submission details.

    Requires secops:vdp:read permission.
    """
    handler, _, _, _, _ = get_services()

    try:
        submission = await handler.get_submission(submission_id)
        if not submission:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Submission not found: {submission_id}",
            )
        return _submission_to_detail(submission)
    except HTTPException:
        raise
    except Exception as e:
        logger.error("Failed to get submission: %s", str(e), exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve submission",
        )


@router.put(
    "/submissions/{submission_id}/triage",
    response_model=SubmissionDetailResponse,
    summary="Begin Triage",
    description="Begin triaging a submission. Requires authentication.",
)
async def begin_triage(
    submission_id: str,
    request: TriageRequest,
) -> SubmissionDetailResponse:
    """Begin triaging a submission.

    Requires secops:vdp:manage permission.
    """
    _, workflow, _, _, _ = get_services()

    try:
        submission = await workflow.triage(submission_id, request.assessor_id)
        return _submission_to_detail(submission)
    except SubmissionNotFoundError:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Submission not found: {submission_id}",
        )
    except InvalidTransitionError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e),
        )
    except Exception as e:
        logger.error("Failed to begin triage: %s", str(e), exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to begin triage",
        )


@router.put(
    "/submissions/{submission_id}/confirm",
    response_model=SubmissionDetailResponse,
    summary="Confirm Vulnerability",
    description="Confirm a vulnerability as valid. Requires authentication.",
)
async def confirm_vulnerability(
    submission_id: str,
    request: ConfirmRequest,
) -> SubmissionDetailResponse:
    """Confirm a vulnerability as valid.

    Requires secops:vdp:manage permission.
    """
    _, workflow, _, _, _ = get_services()

    try:
        severity = Severity(request.severity.lower())
    except ValueError:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=f"Invalid severity: {request.severity}",
        )

    try:
        submission = await workflow.confirm_vulnerability(
            submission_id=submission_id,
            severity=severity,
            cvss_score=request.cvss_score,
            cvss_vector=request.cvss_vector,
        )
        return _submission_to_detail(submission)
    except SubmissionNotFoundError:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Submission not found: {submission_id}",
        )
    except InvalidTransitionError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e),
        )
    except Exception as e:
        logger.error("Failed to confirm vulnerability: %s", str(e), exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to confirm vulnerability",
        )


@router.put(
    "/submissions/{submission_id}/reject",
    response_model=SubmissionDetailResponse,
    summary="Reject Submission",
    description="Reject a submission as invalid. Requires authentication.",
)
async def reject_submission(
    submission_id: str,
    request: RejectRequest,
) -> SubmissionDetailResponse:
    """Reject a submission as invalid.

    Requires secops:vdp:manage permission.
    """
    _, workflow, _, _, _ = get_services()

    try:
        submission = await workflow.mark_invalid(submission_id, request.reason)
        return _submission_to_detail(submission)
    except SubmissionNotFoundError:
        raise HTTPException(
            status_code=status.HTTP_404_NOT_FOUND,
            detail=f"Submission not found: {submission_id}",
        )
    except InvalidTransitionError as e:
        raise HTTPException(
            status_code=status.HTTP_400_BAD_REQUEST,
            detail=str(e),
        )
    except Exception as e:
        logger.error("Failed to reject submission: %s", str(e), exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to reject submission",
        )


@router.put(
    "/submissions/{submission_id}/close",
    response_model=SubmissionDetailResponse,
    summary="Close Submission",
    description="Close a submission. Requires authentication.",
)
async def close_submission(
    submission_id: str,
) -> SubmissionDetailResponse:
    """Close a submission.

    Requires secops:vdp:manage permission.
    """
    handler, _, _, _, _ = get_services()

    try:
        submission = await handler.get_submission(submission_id)
        if not submission:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Submission not found: {submission_id}",
            )

        submission.status = SubmissionStatus.CLOSED
        submission.closed_at = datetime.now(timezone.utc)

        return _submission_to_detail(submission)
    except HTTPException:
        raise
    except Exception as e:
        logger.error("Failed to close submission: %s", str(e), exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to close submission",
        )


@router.post(
    "/submissions/{submission_id}/bounty",
    response_model=AwardBountyResponse,
    summary="Award Bounty",
    description="Award a bounty for a confirmed vulnerability. Requires auth.",
)
async def award_bounty(
    submission_id: str,
    request: AwardBountyRequest,
) -> AwardBountyResponse:
    """Award a bounty for a vulnerability.

    Requires secops:vdp:manage permission.
    """
    handler, _, _, _, bounty_proc = get_services()

    try:
        submission = await handler.get_submission(submission_id)
        if not submission:
            raise HTTPException(
                status_code=status.HTTP_404_NOT_FOUND,
                detail=f"Submission not found: {submission_id}",
            )

        # Calculate amount if not provided
        if request.amount_cents is None:
            amount = await bounty_proc.calculate_bounty(
                submission,
                quality_factors=request.quality_factors,
                impact_factors=request.impact_factors,
            )
        else:
            amount = request.amount_cents

        # Initiate payment
        payment = await bounty_proc.initiate_payment(
            submission_id=submission_id,
            amount=amount,
            notes=request.notes,
        )

        return AwardBountyResponse(
            payment_id=payment.id,
            submission_id=submission_id,
            amount_usd=amount / 100,
            status=payment.status.value,
            message=f"Bounty of ${amount/100:.2f} initiated for {submission_id}",
        )
    except HTTPException:
        raise
    except Exception as e:
        logger.error("Failed to award bounty: %s", str(e), exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to award bounty",
        )


@router.get(
    "/metrics",
    response_model=VDPMetricsResponse,
    summary="VDP Metrics",
    description="Get VDP program metrics. Requires authentication.",
)
async def get_vdp_metrics() -> VDPMetricsResponse:
    """Get VDP program metrics.

    Requires secops:vdp:read permission.
    """
    handler, _, tracker, _, bounty_proc = get_services()

    try:
        all_subs = await handler.list_submissions(limit=10000)

        # Count by status
        by_status: Dict[str, int] = {}
        for sub in all_subs:
            status_val = sub.status.value
            by_status[status_val] = by_status.get(status_val, 0) + 1

        # Count by severity
        by_severity: Dict[str, int] = {}
        for sub in all_subs:
            if sub.severity:
                sev = sub.severity.value
                by_severity[sev] = by_severity.get(sev, 0) + 1

        # Pending triage
        pending_triage = by_status.get("triaging", 0) + by_status.get("acknowledged", 0)

        # Upcoming disclosures
        upcoming = await tracker.get_upcoming_disclosures(days=14)

        # Total bounties paid
        total_bounties = sum(
            p.amount for p in bounty_proc._payments.values()
            if p.status.value == "paid"
        )

        return VDPMetricsResponse(
            total_submissions=len(all_subs),
            by_status=by_status,
            by_severity=by_severity,
            pending_triage=pending_triage,
            upcoming_disclosures=len(upcoming),
            total_bounties_paid_usd=total_bounties / 100,
            average_triage_time_hours=24.0,  # Placeholder
            average_fix_time_days=14.0,  # Placeholder
        )
    except Exception as e:
        logger.error("Failed to get metrics: %s", str(e), exc_info=True)
        raise HTTPException(
            status_code=status.HTTP_500_INTERNAL_SERVER_ERROR,
            detail="Failed to retrieve metrics",
        )


# ---------------------------------------------------------------------------
# Helper Functions
# ---------------------------------------------------------------------------


def _submission_to_detail(submission: Submission) -> SubmissionDetailResponse:
    """Convert a Submission to SubmissionDetailResponse."""
    return SubmissionDetailResponse(
        id=submission.id,
        submission_id=submission.submission_id,
        title=submission.report.title,
        description=submission.report.description,
        affected_component=submission.report.affected_component,
        status=submission.status.value,
        severity=submission.severity.value if submission.severity else None,
        cvss_score=submission.cvss_score,
        cvss_vector=submission.cvss_vector,
        researcher_email=submission.researcher_email,
        bounty_amount=submission.bounty_amount,
        bounty_currency=submission.bounty_currency,
        submitted_at=submission.submitted_at.isoformat(),
        acknowledged_at=(
            submission.acknowledged_at.isoformat()
            if submission.acknowledged_at
            else None
        ),
        triaged_at=(
            submission.triaged_at.isoformat() if submission.triaged_at else None
        ),
        confirmed_at=(
            submission.confirmed_at.isoformat() if submission.confirmed_at else None
        ),
        fixed_at=submission.fixed_at.isoformat() if submission.fixed_at else None,
        disclosed_at=(
            submission.disclosed_at.isoformat() if submission.disclosed_at else None
        ),
        closed_at=submission.closed_at.isoformat() if submission.closed_at else None,
        disclosure_deadline=(
            submission.disclosure_deadline.isoformat()
            if submission.disclosure_deadline
            else None
        ),
        notes=submission.notes,
    )
