# -*- coding: utf-8 -*-
"""
Vulnerability Triage Workflow - SEC-010

Manages the triage workflow for vulnerability submissions including
severity assessment, CVSS scoring, duplicate marking, and engineering escalation.

Classes:
    - TriageWorkflow: State machine for vulnerability triage.

Example:
    >>> from greenlang.infrastructure.vulnerability_disclosure.triage_workflow import (
    ...     TriageWorkflow
    ... )
    >>> workflow = TriageWorkflow()
    >>> await workflow.triage("VDP-2026-0001", "assessor-123")
    >>> await workflow.confirm_vulnerability("VDP-2026-0001", Severity.HIGH, 7.5)
"""

from __future__ import annotations

import logging
import re
from datetime import datetime, timedelta, timezone
from typing import Any, Dict, List, Optional, Set, Tuple

from greenlang.infrastructure.vulnerability_disclosure.config import (
    VDPConfig,
    get_config,
)
from greenlang.infrastructure.vulnerability_disclosure.models import (
    Severity,
    Submission,
    SubmissionStatus,
)

logger = logging.getLogger(__name__)


# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------

# Valid state transitions
STATE_TRANSITIONS: Dict[SubmissionStatus, Set[SubmissionStatus]] = {
    SubmissionStatus.SUBMITTED: {
        SubmissionStatus.ACKNOWLEDGED,
    },
    SubmissionStatus.ACKNOWLEDGED: {
        SubmissionStatus.TRIAGING,
    },
    SubmissionStatus.TRIAGING: {
        SubmissionStatus.CONFIRMED,
        SubmissionStatus.DUPLICATE,
        SubmissionStatus.INVALID,
    },
    SubmissionStatus.CONFIRMED: {
        SubmissionStatus.REMEDIATION,
        SubmissionStatus.CLOSED,  # Won't fix
    },
    SubmissionStatus.DUPLICATE: {
        SubmissionStatus.CLOSED,
    },
    SubmissionStatus.INVALID: {
        SubmissionStatus.CLOSED,
    },
    SubmissionStatus.REMEDIATION: {
        SubmissionStatus.FIXED,
    },
    SubmissionStatus.FIXED: {
        SubmissionStatus.DISCLOSED,
        SubmissionStatus.CLOSED,  # Skip disclosure for internal findings
    },
    SubmissionStatus.DISCLOSED: {
        SubmissionStatus.CLOSED,
    },
    SubmissionStatus.CLOSED: set(),  # Terminal state
}

# CVSS 3.1 Severity Rating Ranges
CVSS_SEVERITY_RANGES: List[Tuple[float, float, Severity]] = [
    (9.0, 10.0, Severity.CRITICAL),
    (7.0, 8.9, Severity.HIGH),
    (4.0, 6.9, Severity.MEDIUM),
    (0.1, 3.9, Severity.LOW),
    (0.0, 0.0, Severity.INFORMATIONAL),
]


# ---------------------------------------------------------------------------
# Exceptions
# ---------------------------------------------------------------------------


class TriageError(Exception):
    """Base exception for triage errors."""

    pass


class InvalidTransitionError(TriageError):
    """Raised when an invalid state transition is attempted."""

    def __init__(self, current: SubmissionStatus, target: SubmissionStatus):
        self.current = current
        self.target = target
        super().__init__(
            f"Invalid state transition: {current.value} -> {target.value}"
        )


class SubmissionNotFoundError(TriageError):
    """Raised when a submission is not found."""

    pass


# ---------------------------------------------------------------------------
# CVSS Calculator
# ---------------------------------------------------------------------------


class CVSSCalculator:
    """CVSS 3.1 Base Score Calculator.

    Implements CVSS 3.1 base metric scoring according to FIRST specification.
    https://www.first.org/cvss/v3.1/specification-document

    Note: This is a simplified implementation for common cases.
    For full CVSS vector support, consider using a dedicated library.
    """

    # Attack Vector (AV)
    AV_VALUES = {"N": 0.85, "A": 0.62, "L": 0.55, "P": 0.2}  # Network  # Adjacent  # Local  # Physical

    # Attack Complexity (AC)
    AC_VALUES = {"L": 0.77, "H": 0.44}  # Low  # High

    # Privileges Required (PR) - Scope Unchanged
    PR_VALUES_UNCHANGED = {"N": 0.85, "L": 0.62, "H": 0.27}  # None  # Low  # High

    # Privileges Required (PR) - Scope Changed
    PR_VALUES_CHANGED = {"N": 0.85, "L": 0.68, "H": 0.5}

    # User Interaction (UI)
    UI_VALUES = {"N": 0.85, "R": 0.62}  # None  # Required

    # CIA Impact (same for C, I, A)
    IMPACT_VALUES = {"H": 0.56, "L": 0.22, "N": 0.0}  # High  # Low  # None

    @classmethod
    def calculate_base_score(
        cls,
        attack_vector: str,
        attack_complexity: str,
        privileges_required: str,
        user_interaction: str,
        scope: str,
        confidentiality: str,
        integrity: str,
        availability: str,
    ) -> Tuple[float, str]:
        """Calculate CVSS 3.1 base score from metrics.

        Args:
            attack_vector: N (Network), A (Adjacent), L (Local), P (Physical)
            attack_complexity: L (Low), H (High)
            privileges_required: N (None), L (Low), H (High)
            user_interaction: N (None), R (Required)
            scope: U (Unchanged), C (Changed)
            confidentiality: N (None), L (Low), H (High)
            integrity: N (None), L (Low), H (High)
            availability: N (None), L (Low), H (High)

        Returns:
            Tuple of (score, vector_string)
        """
        # Validate inputs
        av = cls.AV_VALUES.get(attack_vector.upper())
        ac = cls.AC_VALUES.get(attack_complexity.upper())
        ui = cls.UI_VALUES.get(user_interaction.upper())
        c = cls.IMPACT_VALUES.get(confidentiality.upper())
        i = cls.IMPACT_VALUES.get(integrity.upper())
        a = cls.IMPACT_VALUES.get(availability.upper())

        if any(v is None for v in [av, ac, ui, c, i, a]):
            raise ValueError("Invalid CVSS metric value")

        scope_changed = scope.upper() == "C"
        pr = (
            cls.PR_VALUES_CHANGED if scope_changed else cls.PR_VALUES_UNCHANGED
        ).get(privileges_required.upper())

        if pr is None:
            raise ValueError(f"Invalid PR value: {privileges_required}")

        # Calculate Impact Sub Score (ISS)
        iss = 1 - ((1 - c) * (1 - i) * (1 - a))

        # Calculate Impact
        if scope_changed:
            impact = 7.52 * (iss - 0.029) - 3.25 * pow(iss - 0.02, 15)
        else:
            impact = 6.42 * iss

        # Calculate Exploitability
        exploitability = 8.22 * av * ac * pr * ui

        # Calculate Base Score
        if impact <= 0:
            base_score = 0.0
        elif scope_changed:
            base_score = min(
                1.08 * (impact + exploitability), 10.0
            )
        else:
            base_score = min(impact + exploitability, 10.0)

        # Round up to one decimal place
        base_score = round(base_score * 10) / 10

        # Build vector string
        vector = (
            f"CVSS:3.1/AV:{attack_vector.upper()}/AC:{attack_complexity.upper()}/"
            f"PR:{privileges_required.upper()}/UI:{user_interaction.upper()}/"
            f"S:{scope.upper()}/C:{confidentiality.upper()}/"
            f"I:{integrity.upper()}/A:{availability.upper()}"
        )

        return (base_score, vector)

    @classmethod
    def score_to_severity(cls, score: float) -> Severity:
        """Convert CVSS score to severity level.

        Args:
            score: CVSS base score (0.0-10.0)

        Returns:
            Corresponding Severity level.
        """
        for min_score, max_score, severity in CVSS_SEVERITY_RANGES:
            if min_score <= score <= max_score:
                return severity
        return Severity.INFORMATIONAL


# ---------------------------------------------------------------------------
# Triage Workflow
# ---------------------------------------------------------------------------


class TriageWorkflow:
    """Manages the vulnerability triage workflow.

    Implements a state machine for vulnerability assessment with support for:
    - CVSS 3.1 scoring
    - Severity classification
    - Duplicate detection and marking
    - Invalid submission handling
    - Engineering escalation

    Attributes:
        config: VDP configuration settings.
        _submissions: Reference to submission storage.
        cvss_calculator: CVSS score calculator.

    Example:
        >>> workflow = TriageWorkflow()
        >>> await workflow.triage("VDP-2026-0001", "assessor-123")
        >>> score, vector = workflow.calculate_cvss(
        ...     attack_vector="N",
        ...     attack_complexity="L",
        ...     privileges_required="N",
        ...     user_interaction="N",
        ...     scope="U",
        ...     confidentiality="H",
        ...     integrity="H",
        ...     availability="H",
        ... )
        >>> await workflow.confirm_vulnerability("VDP-2026-0001", Severity.CRITICAL, score)
    """

    # Class-level reference to valid state transitions
    STATES = list(SubmissionStatus)
    TRANSITIONS = STATE_TRANSITIONS

    def __init__(
        self,
        config: Optional[VDPConfig] = None,
        submissions: Optional[Dict[str, Submission]] = None,
    ):
        """Initialize the triage workflow.

        Args:
            config: Optional VDP configuration.
            submissions: Optional reference to submission storage.
        """
        self.config = config or get_config()
        self._submissions = submissions or {}
        self.cvss_calculator = CVSSCalculator()
        logger.info("TriageWorkflow initialized")

    def set_submissions(self, submissions: Dict[str, Submission]) -> None:
        """Set the submissions storage reference.

        Args:
            submissions: Reference to submission storage.
        """
        self._submissions = submissions

    async def triage(
        self,
        submission_id: str,
        assessor_id: str,
    ) -> Submission:
        """Begin triage of a submission.

        Transitions submission from ACKNOWLEDGED to TRIAGING and assigns
        the security analyst.

        Args:
            submission_id: The submission to triage.
            assessor_id: User ID of the security analyst.

        Returns:
            Updated Submission record.

        Raises:
            SubmissionNotFoundError: If submission not found.
            InvalidTransitionError: If transition is not valid.
        """
        submission = self._get_submission(submission_id)

        # Validate we can transition to TRIAGING
        self._validate_transition(submission.status, SubmissionStatus.TRIAGING)

        # Update submission
        submission.status = SubmissionStatus.TRIAGING
        submission.assessor_id = assessor_id
        submission.triaged_at = datetime.now(timezone.utc)

        logger.info(
            "Triage started for %s by %s",
            submission_id,
            assessor_id,
        )

        return submission

    def calculate_cvss(
        self,
        attack_vector: str = "N",
        attack_complexity: str = "L",
        privileges_required: str = "N",
        user_interaction: str = "N",
        scope: str = "U",
        confidentiality: str = "N",
        integrity: str = "N",
        availability: str = "N",
    ) -> Tuple[float, str]:
        """Calculate CVSS 3.1 base score.

        Args:
            attack_vector: N/A/L/P
            attack_complexity: L/H
            privileges_required: N/L/H
            user_interaction: N/R
            scope: U/C
            confidentiality: N/L/H
            integrity: N/L/H
            availability: N/L/H

        Returns:
            Tuple of (score, vector_string)
        """
        return self.cvss_calculator.calculate_base_score(
            attack_vector=attack_vector,
            attack_complexity=attack_complexity,
            privileges_required=privileges_required,
            user_interaction=user_interaction,
            scope=scope,
            confidentiality=confidentiality,
            integrity=integrity,
            availability=availability,
        )

    async def confirm_vulnerability(
        self,
        submission_id: str,
        severity: Severity,
        cvss_score: float,
        cvss_vector: Optional[str] = None,
    ) -> Submission:
        """Confirm a submission as a valid vulnerability.

        Transitions to CONFIRMED state, sets severity and CVSS score,
        and calculates disclosure deadline.

        Args:
            submission_id: The submission to confirm.
            severity: Assessed severity level.
            cvss_score: CVSS 3.1 base score.
            cvss_vector: Optional CVSS vector string.

        Returns:
            Updated Submission record.

        Raises:
            SubmissionNotFoundError: If submission not found.
            InvalidTransitionError: If transition is not valid.
        """
        submission = self._get_submission(submission_id)

        # Validate transition
        self._validate_transition(submission.status, SubmissionStatus.CONFIRMED)

        # Calculate disclosure deadline based on severity
        timeline_days = self.config.disclosure_timeline_days.get(
            severity.value, 90
        )
        disclosure_deadline = datetime.now(timezone.utc) + timedelta(
            days=timeline_days
        )

        # Update submission
        submission.status = SubmissionStatus.CONFIRMED
        submission.severity = severity
        submission.cvss_score = cvss_score
        submission.cvss_vector = cvss_vector
        submission.disclosure_deadline = disclosure_deadline
        submission.confirmed_at = datetime.now(timezone.utc)

        logger.info(
            "Vulnerability confirmed: %s, severity=%s, CVSS=%.1f, deadline=%s",
            submission_id,
            severity.value,
            cvss_score,
            disclosure_deadline.date().isoformat(),
        )

        return submission

    async def mark_duplicate(
        self,
        submission_id: str,
        original_id: str,
    ) -> Submission:
        """Mark a submission as a duplicate of another.

        Args:
            submission_id: The duplicate submission.
            original_id: The original submission ID.

        Returns:
            Updated Submission record.

        Raises:
            SubmissionNotFoundError: If submission not found.
            InvalidTransitionError: If transition is not valid.
            TriageError: If original_id is invalid.
        """
        submission = self._get_submission(submission_id)

        # Validate original exists
        if original_id not in self._submissions:
            raise TriageError(f"Original submission not found: {original_id}")

        # Validate transition
        self._validate_transition(submission.status, SubmissionStatus.DUPLICATE)

        # Update submission
        submission.status = SubmissionStatus.DUPLICATE
        submission.duplicate_of = original_id
        submission.notes.append(
            f"Marked as duplicate of {original_id} at "
            f"{datetime.now(timezone.utc).isoformat()}"
        )

        logger.info(
            "Submission %s marked as duplicate of %s",
            submission_id,
            original_id,
        )

        return submission

    async def mark_invalid(
        self,
        submission_id: str,
        reason: str,
    ) -> Submission:
        """Mark a submission as invalid (not a security vulnerability).

        Args:
            submission_id: The submission to reject.
            reason: Explanation for rejection.

        Returns:
            Updated Submission record.

        Raises:
            SubmissionNotFoundError: If submission not found.
            InvalidTransitionError: If transition is not valid.
        """
        submission = self._get_submission(submission_id)

        # Validate transition
        self._validate_transition(submission.status, SubmissionStatus.INVALID)

        # Update submission
        submission.status = SubmissionStatus.INVALID
        submission.rejection_reason = reason
        submission.notes.append(
            f"Marked as invalid at {datetime.now(timezone.utc).isoformat()}: {reason}"
        )

        logger.info(
            "Submission %s marked as invalid: %s",
            submission_id,
            reason[:100],
        )

        return submission

    async def escalate_to_engineering(
        self,
        submission_id: str,
        priority: str = "P2",
        team: Optional[str] = None,
    ) -> Dict[str, Any]:
        """Escalate a confirmed vulnerability to engineering for remediation.

        Transitions to REMEDIATION state and creates a ticket in the
        issue tracking system (Jira/Linear).

        Args:
            submission_id: The confirmed submission to escalate.
            priority: Issue priority (P0-P4).
            team: Optional team assignment.

        Returns:
            Dictionary with ticket information.

        Raises:
            SubmissionNotFoundError: If submission not found.
            InvalidTransitionError: If transition is not valid.
        """
        submission = self._get_submission(submission_id)

        # Validate transition
        self._validate_transition(submission.status, SubmissionStatus.REMEDIATION)

        # Update submission
        submission.status = SubmissionStatus.REMEDIATION

        # Create ticket (placeholder - implement actual integration)
        ticket = {
            "submission_id": submission_id,
            "ticket_id": f"SEC-{submission_id.split('-')[-1]}",
            "priority": priority,
            "team": team or submission.report.affected_component,
            "title": f"[VDP] {submission.report.title}",
            "severity": submission.severity.value if submission.severity else "unknown",
            "deadline": (
                submission.disclosure_deadline.isoformat()
                if submission.disclosure_deadline
                else None
            ),
            "created_at": datetime.now(timezone.utc).isoformat(),
        }

        submission.metadata["engineering_ticket"] = ticket

        logger.info(
            "Escalated %s to engineering: ticket=%s, priority=%s",
            submission_id,
            ticket["ticket_id"],
            priority,
        )

        return ticket

    async def request_more_info(
        self,
        submission_id: str,
        questions: List[str],
    ) -> None:
        """Request additional information from the researcher.

        Adds questions to submission notes and triggers email to researcher.

        Args:
            submission_id: The submission needing clarification.
            questions: List of questions for the researcher.

        Raises:
            SubmissionNotFoundError: If submission not found.
        """
        submission = self._get_submission(submission_id)

        note = (
            f"Requested more info at {datetime.now(timezone.utc).isoformat()}:\n"
            + "\n".join(f"- {q}" for q in questions)
        )
        submission.notes.append(note)

        logger.info(
            "Requested more info for %s: %d questions",
            submission_id,
            len(questions),
        )

        # TODO: Send email to researcher with questions

    def _get_submission(self, submission_id: str) -> Submission:
        """Get a submission by ID.

        Args:
            submission_id: The submission ID to look up.

        Returns:
            The Submission record.

        Raises:
            SubmissionNotFoundError: If not found.
        """
        submission = self._submissions.get(submission_id)
        if not submission:
            raise SubmissionNotFoundError(f"Submission not found: {submission_id}")
        return submission

    def _validate_transition(
        self,
        current: SubmissionStatus,
        target: SubmissionStatus,
    ) -> None:
        """Validate a state transition is allowed.

        Args:
            current: Current submission status.
            target: Desired target status.

        Raises:
            InvalidTransitionError: If transition is not valid.
        """
        allowed = self.TRANSITIONS.get(current, set())
        if target not in allowed:
            raise InvalidTransitionError(current, target)


# ---------------------------------------------------------------------------
# Exports
# ---------------------------------------------------------------------------

__all__ = [
    "CVSSCalculator",
    "InvalidTransitionError",
    "SubmissionNotFoundError",
    "TriageError",
    "TriageWorkflow",
]
