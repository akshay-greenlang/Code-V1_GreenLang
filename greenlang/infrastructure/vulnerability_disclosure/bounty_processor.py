# -*- coding: utf-8 -*-
"""
Bounty Processor - SEC-010

Handles bug bounty calculation, payment initiation, approval workflow,
and payment reporting for the Vulnerability Disclosure Program.

Classes:
    - BountyProcessor: Manages bounty calculations and payments.

Example:
    >>> from greenlang.infrastructure.vulnerability_disclosure.bounty_processor import (
    ...     BountyProcessor
    ... )
    >>> processor = BountyProcessor()
    >>> amount = await processor.calculate_bounty(submission)
    >>> payment = await processor.initiate_payment("VDP-2026-0001", amount)
    >>> await processor.approve_payment(payment.id, "approver-123")
"""

from __future__ import annotations

import logging
from datetime import datetime, timedelta, timezone
from decimal import Decimal
from typing import Any, Dict, List, Optional, Tuple
from uuid import uuid4

from greenlang.infrastructure.vulnerability_disclosure.config import (
    VDPConfig,
    get_config,
)
from greenlang.infrastructure.vulnerability_disclosure.models import (
    BountyPayment,
    PaymentStatus,
    Researcher,
    Severity,
    Submission,
    SubmissionStatus,
)

logger = logging.getLogger(__name__)


# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------

# Default bounty tiers in USD
BOUNTY_TIERS: Dict[str, int] = {
    "critical": 5000,
    "high": 2500,
    "medium": 1000,
    "low": 250,
    "informational": 0,
}

# Quality bonus factors
QUALITY_FACTORS = {
    "detailed_poc": {
        "description": "Detailed proof of concept provided",
        "bonus_percent": 20,
    },
    "suggested_fix": {
        "description": "Suggested fix or remediation provided",
        "bonus_percent": 15,
    },
    "clear_steps": {
        "description": "Clear reproduction steps (5+ steps)",
        "bonus_percent": 10,
    },
    "first_reporter": {
        "description": "First to report this type of vulnerability",
        "bonus_percent": 25,
    },
}

# Impact bonus factors
IMPACT_FACTORS = {
    "data_exposure": {
        "description": "Potential for sensitive data exposure",
        "bonus_percent": 50,
    },
    "rce": {
        "description": "Remote code execution possible",
        "bonus_percent": 100,
    },
    "authentication_bypass": {
        "description": "Authentication or authorization bypass",
        "bonus_percent": 75,
    },
    "supply_chain": {
        "description": "Supply chain impact",
        "bonus_percent": 50,
    },
}


# ---------------------------------------------------------------------------
# Exceptions
# ---------------------------------------------------------------------------


class BountyError(Exception):
    """Base exception for bounty processing errors."""

    pass


class PaymentNotFoundError(BountyError):
    """Raised when a payment record is not found."""

    pass


class InvalidPaymentStateError(BountyError):
    """Raised when payment operation is invalid for current state."""

    pass


class ApprovalError(BountyError):
    """Raised when payment approval fails."""

    pass


class PaymentProcessingError(BountyError):
    """Raised when payment processing fails."""

    pass


# ---------------------------------------------------------------------------
# Bounty Processor
# ---------------------------------------------------------------------------


class BountyProcessor:
    """Handles bug bounty calculations and payment processing.

    Responsible for:
    - Calculating bounty amounts based on severity and quality
    - Applying quality and impact bonuses
    - Creating payment records
    - Managing approval workflow
    - Processing payments (placeholder for payment provider integration)
    - Generating payment reports

    Attributes:
        config: VDP configuration settings.
        BOUNTY_TIERS: Base bounty amounts by severity.

    Example:
        >>> processor = BountyProcessor()
        >>> amount = await processor.calculate_bounty(submission)
        >>> print(f"Calculated bounty: ${amount/100:.2f}")
    """

    # Class-level bounty tiers reference
    BOUNTY_TIERS = BOUNTY_TIERS

    def __init__(
        self,
        config: Optional[VDPConfig] = None,
        submissions: Optional[Dict[str, Submission]] = None,
        researchers: Optional[Dict[str, Researcher]] = None,
        payments: Optional[Dict[str, BountyPayment]] = None,
    ):
        """Initialize the bounty processor.

        Args:
            config: Optional VDP configuration.
            submissions: Optional reference to submission storage.
            researchers: Optional reference to researcher storage.
            payments: Optional reference to payment storage.
        """
        self.config = config or get_config()
        self._submissions = submissions or {}
        self._researchers = researchers or {}
        self._payments: Dict[str, BountyPayment] = payments or {}
        logger.info("BountyProcessor initialized")

    def set_submissions(self, submissions: Dict[str, Submission]) -> None:
        """Set the submissions storage reference."""
        self._submissions = submissions

    def set_researchers(self, researchers: Dict[str, Researcher]) -> None:
        """Set the researchers storage reference."""
        self._researchers = researchers

    async def calculate_bounty(
        self,
        submission: Submission,
        quality_factors: Optional[List[str]] = None,
        impact_factors: Optional[List[str]] = None,
    ) -> int:
        """Calculate the bounty amount for a submission.

        Args:
            submission: The submission to calculate bounty for.
            quality_factors: List of applicable quality factor keys.
            impact_factors: List of applicable impact factor keys.

        Returns:
            Bounty amount in cents.
        """
        if not submission.severity:
            logger.warning(
                "Cannot calculate bounty for %s: no severity set",
                submission.submission_id,
            )
            return 0

        # Get base amount from config or defaults
        base_amount_usd = self.config.bounty_tiers.get(
            submission.severity.value,
            self.BOUNTY_TIERS.get(submission.severity.value, 0),
        )

        # Convert to cents
        base_amount = base_amount_usd * 100

        # Calculate quality bonus
        quality_bonus = 0
        quality_factors = quality_factors or self._detect_quality_factors(submission)
        for factor in quality_factors:
            if factor in QUALITY_FACTORS:
                bonus_percent = QUALITY_FACTORS[factor]["bonus_percent"]
                quality_bonus += int(base_amount * bonus_percent / 100)

        # Cap quality bonus
        max_quality_bonus = int(
            base_amount * self.config.quality_bonus_max_percent / 100
        )
        quality_bonus = min(quality_bonus, max_quality_bonus)

        # Calculate impact bonus
        impact_bonus = 0
        impact_factors = impact_factors or []
        for factor in impact_factors:
            if factor in IMPACT_FACTORS:
                bonus_percent = IMPACT_FACTORS[factor]["bonus_percent"]
                impact_bonus += int(base_amount * bonus_percent / 100)

        # Cap impact bonus
        max_impact_bonus = int(
            base_amount * self.config.impact_bonus_max_percent / 100
        )
        impact_bonus = min(impact_bonus, max_impact_bonus)

        # Total bounty
        total_amount = base_amount + quality_bonus + impact_bonus

        logger.info(
            "Calculated bounty for %s: base=$%.2f + quality=$%.2f + impact=$%.2f = $%.2f",
            submission.submission_id,
            base_amount / 100,
            quality_bonus / 100,
            impact_bonus / 100,
            total_amount / 100,
        )

        return total_amount

    def _detect_quality_factors(self, submission: Submission) -> List[str]:
        """Auto-detect quality factors from submission content.

        Args:
            submission: The submission to analyze.

        Returns:
            List of detected quality factor keys.
        """
        factors = []

        # Check for detailed PoC
        if submission.report.proof_of_concept:
            if len(submission.report.proof_of_concept) > 100:
                factors.append("detailed_poc")

        # Check for suggested fix
        if submission.report.suggested_fix:
            factors.append("suggested_fix")

        # Check for clear reproduction steps
        if len(submission.report.steps_to_reproduce) >= 5:
            factors.append("clear_steps")

        return factors

    async def apply_bonus(
        self,
        base_amount: int,
        factors: Dict[str, float],
    ) -> int:
        """Apply bonus multipliers to a base amount.

        Args:
            base_amount: Base bounty amount in cents.
            factors: Dictionary of factor names to multiplier values.

        Returns:
            Adjusted amount in cents.
        """
        total_multiplier = 1.0
        for factor_name, multiplier in factors.items():
            total_multiplier += (multiplier - 1.0)

        adjusted_amount = int(base_amount * total_multiplier)
        return adjusted_amount

    async def initiate_payment(
        self,
        submission_id: str,
        amount: int,
        notes: str = "",
    ) -> BountyPayment:
        """Create a bounty payment record.

        Args:
            submission_id: The submission to pay bounty for.
            amount: Payment amount in cents.
            notes: Optional notes about the payment.

        Returns:
            The created BountyPayment record.

        Raises:
            BountyError: If submission not found or not eligible.
        """
        submission = self._submissions.get(submission_id)
        if not submission:
            raise BountyError(f"Submission not found: {submission_id}")

        if submission.status not in (
            SubmissionStatus.CONFIRMED,
            SubmissionStatus.REMEDIATION,
            SubmissionStatus.FIXED,
            SubmissionStatus.DISCLOSED,
            SubmissionStatus.CLOSED,
        ):
            raise BountyError(
                f"Submission not eligible for bounty: {submission.status.value}"
            )

        if not submission.researcher_id:
            raise BountyError("No researcher associated with submission")

        # Check for existing payment
        existing = self._find_payment_for_submission(submission_id)
        if existing:
            raise BountyError(
                f"Payment already exists for {submission_id}: {existing.id}"
            )

        # Create payment record
        payment = BountyPayment(
            submission_id=submission_id,
            researcher_id=submission.researcher_id,
            amount=amount,
            currency=self.config.bounty_currency,
            status=PaymentStatus.PENDING,
            notes=notes,
        )

        self._payments[payment.id] = payment

        # Update submission
        submission.bounty_amount = amount
        submission.bounty_currency = self.config.bounty_currency

        logger.info(
            "Payment initiated for %s: $%.2f (%s)",
            submission_id,
            amount / 100,
            payment.id,
        )

        return payment

    async def approve_payment(
        self,
        payment_id: str,
        approver_id: str,
    ) -> BountyPayment:
        """Approve a pending payment.

        Args:
            payment_id: The payment to approve.
            approver_id: User ID of the approver.

        Returns:
            The updated BountyPayment record.

        Raises:
            PaymentNotFoundError: If payment not found.
            InvalidPaymentStateError: If payment not in pending state.
        """
        payment = self._payments.get(payment_id)
        if not payment:
            raise PaymentNotFoundError(f"Payment not found: {payment_id}")

        if payment.status != PaymentStatus.PENDING:
            raise InvalidPaymentStateError(
                f"Cannot approve payment in {payment.status.value} state"
            )

        payment.status = PaymentStatus.APPROVED
        payment.approved_by = approver_id
        payment.approved_at = datetime.now(timezone.utc)

        logger.info(
            "Payment %s approved by %s",
            payment_id,
            approver_id,
        )

        return payment

    async def reject_payment(
        self,
        payment_id: str,
        rejector_id: str,
        reason: str,
    ) -> BountyPayment:
        """Reject a pending payment.

        Args:
            payment_id: The payment to reject.
            rejector_id: User ID of the rejector.
            reason: Reason for rejection.

        Returns:
            The updated BountyPayment record.

        Raises:
            PaymentNotFoundError: If payment not found.
            InvalidPaymentStateError: If payment not in pending state.
        """
        payment = self._payments.get(payment_id)
        if not payment:
            raise PaymentNotFoundError(f"Payment not found: {payment_id}")

        if payment.status != PaymentStatus.PENDING:
            raise InvalidPaymentStateError(
                f"Cannot reject payment in {payment.status.value} state"
            )

        payment.status = PaymentStatus.REJECTED
        payment.notes += f"\nRejected by {rejector_id}: {reason}"

        logger.info(
            "Payment %s rejected: %s",
            payment_id,
            reason,
        )

        return payment

    async def process_payment(
        self,
        payment_id: str,
    ) -> BountyPayment:
        """Process an approved payment.

        Integrates with payment provider to send funds.
        This is a placeholder for actual payment processing.

        Args:
            payment_id: The payment to process.

        Returns:
            The updated BountyPayment record.

        Raises:
            PaymentNotFoundError: If payment not found.
            InvalidPaymentStateError: If payment not approved.
            PaymentProcessingError: If processing fails.
        """
        payment = self._payments.get(payment_id)
        if not payment:
            raise PaymentNotFoundError(f"Payment not found: {payment_id}")

        if payment.status != PaymentStatus.APPROVED:
            raise InvalidPaymentStateError(
                f"Cannot process payment in {payment.status.value} state"
            )

        # Update to processing state
        payment.status = PaymentStatus.PROCESSING

        try:
            # TODO: Integrate with actual payment provider
            # For now, simulate successful processing

            # Get researcher for payment details
            researcher = None
            for r in self._researchers.values():
                if r.id == payment.researcher_id:
                    researcher = r
                    break

            if not researcher:
                raise PaymentProcessingError(
                    f"Researcher not found: {payment.researcher_id}"
                )

            # Simulate payment reference
            payment.payment_reference = f"PAY-{uuid4().hex[:8].upper()}"
            payment.payment_method = researcher.payment_method or "paypal"
            payment.status = PaymentStatus.PAID
            payment.paid_at = datetime.now(timezone.utc)

            # Update researcher earnings
            researcher.bounties_earned += payment.amount

            logger.info(
                "Payment %s processed: $%.2f to %s via %s",
                payment_id,
                payment.amount / 100,
                researcher.email,
                payment.payment_method,
            )

            return payment

        except Exception as e:
            payment.status = PaymentStatus.FAILED
            payment.notes += f"\nProcessing failed: {str(e)}"
            logger.error("Payment processing failed: %s", str(e), exc_info=True)
            raise PaymentProcessingError(f"Payment processing failed: {str(e)}") from e

    async def get_payment_status(
        self,
        payment_id: str,
    ) -> Dict[str, Any]:
        """Get the current status of a payment.

        Args:
            payment_id: The payment to check.

        Returns:
            Dictionary with payment status information.

        Raises:
            PaymentNotFoundError: If payment not found.
        """
        payment = self._payments.get(payment_id)
        if not payment:
            raise PaymentNotFoundError(f"Payment not found: {payment_id}")

        return {
            "payment_id": payment.id,
            "submission_id": payment.submission_id,
            "amount": payment.amount / 100,
            "currency": payment.currency,
            "status": payment.status.value,
            "payment_method": payment.payment_method,
            "payment_reference": payment.payment_reference,
            "approved_at": (
                payment.approved_at.isoformat() if payment.approved_at else None
            ),
            "paid_at": payment.paid_at.isoformat() if payment.paid_at else None,
            "created_at": payment.created_at.isoformat(),
        }

    async def generate_payment_report(
        self,
        start_date: datetime,
        end_date: datetime,
    ) -> Dict[str, Any]:
        """Generate a bounty payment report for a date range.

        Args:
            start_date: Report start date.
            end_date: Report end date.

        Returns:
            Dictionary with payment report data.
        """
        payments_in_range = [
            p for p in self._payments.values()
            if start_date <= p.created_at <= end_date
        ]

        # Calculate totals by status
        by_status: Dict[str, List[BountyPayment]] = {}
        for payment in payments_in_range:
            status = payment.status.value
            if status not in by_status:
                by_status[status] = []
            by_status[status].append(payment)

        # Calculate totals by severity
        by_severity: Dict[str, int] = {}
        for payment in payments_in_range:
            if payment.status == PaymentStatus.PAID:
                submission = self._submissions.get(payment.submission_id)
                if submission and submission.severity:
                    severity = submission.severity.value
                    by_severity[severity] = (
                        by_severity.get(severity, 0) + payment.amount
                    )

        # Calculate aggregate stats
        paid_payments = by_status.get("paid", [])
        total_paid = sum(p.amount for p in paid_payments)
        avg_payment = total_paid / len(paid_payments) if paid_payments else 0

        pending_payments = by_status.get("pending", []) + by_status.get("approved", [])
        total_pending = sum(p.amount for p in pending_payments)

        return {
            "report_period": {
                "start": start_date.isoformat(),
                "end": end_date.isoformat(),
            },
            "summary": {
                "total_payments": len(payments_in_range),
                "total_paid_usd": total_paid / 100,
                "total_pending_usd": total_pending / 100,
                "average_payment_usd": avg_payment / 100,
                "unique_researchers": len(
                    set(p.researcher_id for p in paid_payments)
                ),
            },
            "by_status": {
                status: {
                    "count": len(payments),
                    "total_usd": sum(p.amount for p in payments) / 100,
                }
                for status, payments in by_status.items()
            },
            "by_severity": {
                severity: amount / 100
                for severity, amount in by_severity.items()
            },
            "generated_at": datetime.now(timezone.utc).isoformat(),
        }

    def _find_payment_for_submission(
        self,
        submission_id: str,
    ) -> Optional[BountyPayment]:
        """Find an existing payment for a submission.

        Args:
            submission_id: The submission ID to look up.

        Returns:
            The BountyPayment if found, None otherwise.
        """
        for payment in self._payments.values():
            if payment.submission_id == submission_id:
                return payment
        return None


# ---------------------------------------------------------------------------
# Exports
# ---------------------------------------------------------------------------

__all__ = [
    "ApprovalError",
    "BOUNTY_TIERS",
    "BountyError",
    "BountyProcessor",
    "IMPACT_FACTORS",
    "InvalidPaymentStateError",
    "PaymentNotFoundError",
    "PaymentProcessingError",
    "QUALITY_FACTORS",
]
