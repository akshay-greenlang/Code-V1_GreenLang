# -*- coding: utf-8 -*-
"""
Researcher Manager - SEC-010

Manages security researcher profiles, reputation scoring, hall of fame,
identity verification, and tax documentation for bounty payments.

Classes:
    - ResearcherManager: Manages researcher profiles and reputation.

Example:
    >>> from greenlang.infrastructure.vulnerability_disclosure.researcher_manager import (
    ...     ResearcherManager
    ... )
    >>> manager = ResearcherManager()
    >>> researcher = await manager.register_researcher(
    ...     name="Jane Hacker",
    ...     email="jane@example.com",
    ...     pgp_key="-----BEGIN PGP PUBLIC KEY BLOCK-----..."
    ... )
    >>> hall_of_fame = await manager.get_hall_of_fame(limit=20)
"""

from __future__ import annotations

import hashlib
import logging
from datetime import datetime, timezone
from typing import Any, Dict, List, Optional

from greenlang.infrastructure.vulnerability_disclosure.config import (
    VDPConfig,
    get_config,
)
from greenlang.infrastructure.vulnerability_disclosure.models import (
    IdentityVerificationMethod,
    Researcher,
    Severity,
    Submission,
    SubmissionStatus,
)

logger = logging.getLogger(__name__)


# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------

# Reputation score weights by severity
SEVERITY_REPUTATION_POINTS: Dict[str, int] = {
    "critical": 500,
    "high": 300,
    "medium": 150,
    "low": 50,
    "informational": 10,
}

# Bonus multipliers for quality
QUALITY_BONUS_MULTIPLIERS = {
    "detailed_poc": 1.2,
    "suggested_fix": 1.1,
    "clear_reproduction": 1.15,
    "fast_response": 1.1,
}

# Tax form thresholds (USD)
TAX_FORM_THRESHOLD_USD = 600  # US IRS reporting threshold


# ---------------------------------------------------------------------------
# Exceptions
# ---------------------------------------------------------------------------


class ResearcherError(Exception):
    """Base exception for researcher management errors."""

    pass


class ResearcherNotFoundError(ResearcherError):
    """Raised when a researcher is not found."""

    pass


class VerificationError(ResearcherError):
    """Raised when identity verification fails."""

    pass


class DuplicateResearcherError(ResearcherError):
    """Raised when attempting to register a duplicate researcher."""

    pass


# ---------------------------------------------------------------------------
# Researcher Manager
# ---------------------------------------------------------------------------


class ResearcherManager:
    """Manages security researcher profiles and reputation.

    Responsible for:
    - Registering new researchers
    - Looking up researcher profiles
    - Calculating reputation scores
    - Updating submission statistics
    - Managing the hall of fame
    - Identity verification for bounty payments
    - Tax document generation

    Attributes:
        config: VDP configuration settings.

    Example:
        >>> manager = ResearcherManager()
        >>> researcher = await manager.register_researcher(
        ...     name="Security Researcher",
        ...     email="researcher@example.com"
        ... )
        >>> score = await manager.calculate_reputation(researcher.id)
    """

    def __init__(
        self,
        config: Optional[VDPConfig] = None,
        researchers: Optional[Dict[str, Researcher]] = None,
        submissions: Optional[Dict[str, Submission]] = None,
    ):
        """Initialize the researcher manager.

        Args:
            config: Optional VDP configuration.
            researchers: Optional reference to researcher storage.
            submissions: Optional reference to submission storage.
        """
        self.config = config or get_config()
        self._researchers: Dict[str, Researcher] = researchers or {}
        self._submissions: Dict[str, Submission] = submissions or {}
        logger.info("ResearcherManager initialized")

    def set_researchers(self, researchers: Dict[str, Researcher]) -> None:
        """Set the researchers storage reference.

        Args:
            researchers: Reference to researcher storage.
        """
        self._researchers = researchers

    def set_submissions(self, submissions: Dict[str, Submission]) -> None:
        """Set the submissions storage reference.

        Args:
            submissions: Reference to submission storage.
        """
        self._submissions = submissions

    async def register_researcher(
        self,
        name: str,
        email: str,
        pgp_key: Optional[str] = None,
        country_code: Optional[str] = None,
        opt_into_hall_of_fame: bool = True,
    ) -> Researcher:
        """Register a new security researcher.

        Args:
            name: Display name for the researcher.
            email: Contact email address.
            pgp_key: Optional PGP public key.
            country_code: Optional ISO 3166-1 alpha-2 country code.
            opt_into_hall_of_fame: Whether to appear in hall of fame.

        Returns:
            The created Researcher profile.

        Raises:
            DuplicateResearcherError: If email already registered.
        """
        # Check for existing researcher
        if email.lower() in self._researchers:
            raise DuplicateResearcherError(f"Email already registered: {email}")

        researcher = Researcher(
            name=name or "Anonymous",
            email=email.lower(),
            pgp_key=pgp_key,
            country_code=country_code,
            hall_of_fame=opt_into_hall_of_fame,
            registered_at=datetime.now(timezone.utc),
        )

        self._researchers[email.lower()] = researcher

        logger.info(
            "Registered new researcher: %s (%s)",
            researcher.name,
            researcher.email,
        )

        return researcher

    async def get_researcher(
        self,
        email: str,
    ) -> Optional[Researcher]:
        """Look up a researcher by email.

        Args:
            email: The researcher's email address.

        Returns:
            The Researcher profile or None if not found.
        """
        return self._researchers.get(email.lower())

    async def get_researcher_by_id(
        self,
        researcher_id: str,
    ) -> Optional[Researcher]:
        """Look up a researcher by ID.

        Args:
            researcher_id: The researcher's UUID.

        Returns:
            The Researcher profile or None if not found.
        """
        for researcher in self._researchers.values():
            if researcher.id == researcher_id:
                return researcher
        return None

    async def calculate_reputation(
        self,
        researcher_id: str,
    ) -> int:
        """Calculate a researcher's reputation score.

        Reputation is based on:
        - Number of valid submissions (weighted by severity)
        - Quality of submissions (PoC, suggested fix, clarity)
        - Response time and communication quality
        - Time since first submission

        Args:
            researcher_id: The researcher's UUID.

        Returns:
            Calculated reputation score (0-10000).

        Raises:
            ResearcherNotFoundError: If researcher not found.
        """
        researcher = await self.get_researcher_by_id(researcher_id)
        if not researcher:
            raise ResearcherNotFoundError(f"Researcher not found: {researcher_id}")

        total_score = 0

        # Get all submissions from this researcher
        researcher_submissions = [
            sub for sub in self._submissions.values()
            if sub.researcher_id == researcher_id
        ]

        for submission in researcher_submissions:
            # Only count valid submissions
            if submission.status in (
                SubmissionStatus.CONFIRMED,
                SubmissionStatus.REMEDIATION,
                SubmissionStatus.FIXED,
                SubmissionStatus.DISCLOSED,
                SubmissionStatus.CLOSED,
            ):
                if submission.status not in (
                    SubmissionStatus.INVALID,
                    SubmissionStatus.DUPLICATE,
                ):
                    # Base points from severity
                    severity_key = (
                        submission.severity.value
                        if submission.severity
                        else "informational"
                    )
                    base_points = SEVERITY_REPUTATION_POINTS.get(severity_key, 10)

                    # Quality bonuses
                    multiplier = 1.0
                    if submission.report.proof_of_concept:
                        multiplier *= QUALITY_BONUS_MULTIPLIERS["detailed_poc"]
                    if submission.report.suggested_fix:
                        multiplier *= QUALITY_BONUS_MULTIPLIERS["suggested_fix"]
                    if len(submission.report.steps_to_reproduce) >= 3:
                        multiplier *= QUALITY_BONUS_MULTIPLIERS["clear_reproduction"]

                    total_score += int(base_points * multiplier)

        # Cap at maximum score
        total_score = min(total_score, 10000)

        # Update researcher profile
        researcher.reputation_score = total_score

        logger.debug(
            "Calculated reputation for %s: %d points",
            researcher.email,
            total_score,
        )

        return total_score

    async def update_statistics(
        self,
        researcher_id: str,
        submission: Submission,
    ) -> None:
        """Update researcher statistics after a submission event.

        Args:
            researcher_id: The researcher's UUID.
            submission: The submission that triggered the update.

        Raises:
            ResearcherNotFoundError: If researcher not found.
        """
        researcher = await self.get_researcher_by_id(researcher_id)
        if not researcher:
            raise ResearcherNotFoundError(f"Researcher not found: {researcher_id}")

        # Update counts based on submission status
        if submission.status == SubmissionStatus.SUBMITTED:
            researcher.submissions_count += 1
            researcher.last_submission_at = submission.submitted_at

        elif submission.status == SubmissionStatus.CONFIRMED:
            researcher.valid_submissions_count += 1

        # Recalculate reputation
        await self.calculate_reputation(researcher_id)

        logger.debug(
            "Updated statistics for %s: %d submissions, %d valid",
            researcher.email,
            researcher.submissions_count,
            researcher.valid_submissions_count,
        )

    async def add_bounty(
        self,
        researcher_id: str,
        amount_cents: int,
    ) -> None:
        """Add bounty earnings to researcher profile.

        Args:
            researcher_id: The researcher's UUID.
            amount_cents: Bounty amount in cents.

        Raises:
            ResearcherNotFoundError: If researcher not found.
        """
        researcher = await self.get_researcher_by_id(researcher_id)
        if not researcher:
            raise ResearcherNotFoundError(f"Researcher not found: {researcher_id}")

        researcher.bounties_earned += amount_cents

        # Check if tax form is now required
        if (
            researcher.bounties_earned >= TAX_FORM_THRESHOLD_USD * 100
            and not researcher.tax_form_on_file
        ):
            logger.warning(
                "Researcher %s has exceeded tax threshold, form required",
                researcher.email,
            )

        logger.info(
            "Added $%.2f bounty for %s (total: $%.2f)",
            amount_cents / 100,
            researcher.email,
            researcher.bounties_earned / 100,
        )

    async def get_hall_of_fame(
        self,
        limit: int = 20,
        include_bounty_totals: bool = True,
    ) -> List[Dict[str, Any]]:
        """Get the public hall of fame leaderboard.

        Returns researchers who have opted in, sorted by reputation
        score and valid submission count.

        Args:
            limit: Maximum number of researchers to return.
            include_bounty_totals: Whether to include bounty totals.

        Returns:
            List of researcher profile summaries.
        """
        hof_config = self.config.get_hall_of_fame_config()

        if not hof_config.enabled:
            return []

        # Filter researchers who opted in and meet minimum requirements
        eligible = [
            r for r in self._researchers.values()
            if r.hall_of_fame
            and r.valid_submissions_count >= hof_config.minimum_valid_submissions
        ]

        # Sort by reputation score (descending), then by valid submissions
        eligible.sort(
            key=lambda r: (r.reputation_score, r.valid_submissions_count),
            reverse=True,
        )

        # Build response
        result = []
        for rank, researcher in enumerate(eligible[:limit], 1):
            entry = {
                "rank": rank,
                "name": researcher.name,
                "reputation_score": researcher.reputation_score,
                "valid_submissions": researcher.valid_submissions_count,
                "member_since": researcher.registered_at.strftime("%Y-%m"),
            }

            if include_bounty_totals and hof_config.include_bounty_totals:
                entry["bounties_earned_usd"] = researcher.bounties_earned / 100

            result.append(entry)

        return result

    async def verify_identity(
        self,
        researcher_id: str,
        method: IdentityVerificationMethod,
        verification_data: Optional[Dict[str, Any]] = None,
    ) -> bool:
        """Verify a researcher's identity for bounty payments.

        Required for large bounty payments (typically >$600 USD).

        Args:
            researcher_id: The researcher's UUID.
            method: Verification method to use.
            verification_data: Method-specific verification data.

        Returns:
            True if verification successful, False otherwise.

        Raises:
            ResearcherNotFoundError: If researcher not found.
            VerificationError: If verification fails.
        """
        researcher = await self.get_researcher_by_id(researcher_id)
        if not researcher:
            raise ResearcherNotFoundError(f"Researcher not found: {researcher_id}")

        verification_data = verification_data or {}

        if method == IdentityVerificationMethod.EMAIL:
            # Email verification (simplified)
            token = verification_data.get("token")
            expected_token = verification_data.get("expected_token")
            if token and token == expected_token:
                researcher.identity_verified = True
                researcher.identity_verification_method = method
                logger.info(
                    "Email verification successful for %s",
                    researcher.email,
                )
                return True
            raise VerificationError("Invalid email verification token")

        elif method == IdentityVerificationMethod.PGP:
            # PGP signature verification
            if not researcher.pgp_key:
                raise VerificationError("No PGP key on file")

            signature = verification_data.get("signature")
            challenge = verification_data.get("challenge")

            if not signature or not challenge:
                raise VerificationError("Missing signature or challenge")

            # TODO: Implement actual PGP signature verification
            # For now, placeholder that always succeeds if data present
            researcher.identity_verified = True
            researcher.identity_verification_method = method
            logger.info(
                "PGP verification successful for %s",
                researcher.email,
            )
            return True

        elif method == IdentityVerificationMethod.KYC:
            # Full KYC verification (placeholder)
            # Would integrate with identity verification provider
            logger.info(
                "KYC verification initiated for %s",
                researcher.email,
            )
            # Mark as pending, actual verification async
            return False

        else:
            raise VerificationError(f"Unknown verification method: {method}")

    async def send_tax_documents(
        self,
        researcher_id: str,
        document_type: str = "W-9",
    ) -> Dict[str, Any]:
        """Generate and send tax documents for bounty payments.

        For US residents: W-9
        For non-US residents: W-8BEN

        Args:
            researcher_id: The researcher's UUID.
            document_type: Type of tax document (W-9 or W-8BEN).

        Returns:
            Dictionary with document generation status.

        Raises:
            ResearcherNotFoundError: If researcher not found.
        """
        researcher = await self.get_researcher_by_id(researcher_id)
        if not researcher:
            raise ResearcherNotFoundError(f"Researcher not found: {researcher_id}")

        # Determine document type based on country
        if researcher.country_code == "US":
            doc_type = "W-9"
        else:
            doc_type = "W-8BEN"

        # TODO: Integrate with actual tax document generation service
        # For now, placeholder response

        result = {
            "researcher_id": researcher_id,
            "document_type": doc_type,
            "status": "generated",
            "expires_at": (
                datetime.now(timezone.utc).replace(year=datetime.now().year + 3)
            ).isoformat(),
            "download_url": f"https://greenlang.io/vdp/tax-forms/{researcher_id}/{doc_type}",
            "sent_to": researcher.email,
        }

        logger.info(
            "Generated %s for %s (%s)",
            doc_type,
            researcher.email,
            researcher.country_code or "unknown",
        )

        return result

    async def update_payment_method(
        self,
        researcher_id: str,
        payment_method: str,
        payment_details: str,
    ) -> None:
        """Update a researcher's preferred payment method.

        Args:
            researcher_id: The researcher's UUID.
            payment_method: Payment method (paypal, wire, crypto).
            payment_details: Encrypted payment details.

        Raises:
            ResearcherNotFoundError: If researcher not found.
        """
        researcher = await self.get_researcher_by_id(researcher_id)
        if not researcher:
            raise ResearcherNotFoundError(f"Researcher not found: {researcher_id}")

        valid_methods = {"paypal", "wire", "crypto", "check"}
        if payment_method not in valid_methods:
            raise ResearcherError(
                f"Invalid payment method: {payment_method}. "
                f"Valid: {valid_methods}"
            )

        researcher.payment_method = payment_method
        researcher.payment_details = payment_details

        logger.info(
            "Updated payment method for %s: %s",
            researcher.email,
            payment_method,
        )


# ---------------------------------------------------------------------------
# Exports
# ---------------------------------------------------------------------------

__all__ = [
    "DuplicateResearcherError",
    "ResearcherError",
    "ResearcherManager",
    "ResearcherNotFoundError",
    "SEVERITY_REPUTATION_POINTS",
    "TAX_FORM_THRESHOLD_USD",
    "VerificationError",
]
