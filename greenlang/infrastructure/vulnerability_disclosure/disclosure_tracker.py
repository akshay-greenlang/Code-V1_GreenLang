# -*- coding: utf-8 -*-
"""
Disclosure Tracker - SEC-010

Manages vulnerability disclosure timelines, deadline tracking, security
advisory preparation, and public disclosure publishing.

Classes:
    - DisclosureTracker: Manages disclosure lifecycle.

Example:
    >>> from greenlang.infrastructure.vulnerability_disclosure.disclosure_tracker import (
    ...     DisclosureTracker
    ... )
    >>> tracker = DisclosureTracker()
    >>> deadline = tracker.calculate_disclosure_date(Severity.CRITICAL, submitted_at)
    >>> await tracker.prepare_disclosure("VDP-2026-0001")
    >>> await tracker.publish_disclosure("VDP-2026-0001")
"""

from __future__ import annotations

import logging
from datetime import datetime, timedelta, timezone
from typing import Any, Dict, List, Optional

from greenlang.infrastructure.vulnerability_disclosure.config import (
    VDPConfig,
    get_config,
)
from greenlang.infrastructure.vulnerability_disclosure.models import (
    DisclosureAdvisory,
    Severity,
    Submission,
    SubmissionStatus,
)

logger = logging.getLogger(__name__)


# ---------------------------------------------------------------------------
# Constants
# ---------------------------------------------------------------------------

# Disclosure timeline policies by severity (days)
DISCLOSURE_POLICIES: Dict[str, int] = {
    "critical": 7,
    "high": 30,
    "medium": 60,
    "low": 90,
    "informational": 90,
}


# ---------------------------------------------------------------------------
# Exceptions
# ---------------------------------------------------------------------------


class DisclosureError(Exception):
    """Base exception for disclosure errors."""

    pass


class DisclosureNotReadyError(DisclosureError):
    """Raised when disclosure cannot proceed because fix is not deployed."""

    pass


class DeadlineExtensionError(DisclosureError):
    """Raised when deadline extension is not allowed."""

    pass


# ---------------------------------------------------------------------------
# Disclosure Tracker
# ---------------------------------------------------------------------------


class DisclosureTracker:
    """Manages vulnerability disclosure timelines and advisories.

    Responsible for:
    - Calculating disclosure deadlines based on severity
    - Checking fix deployment readiness
    - Preparing security advisories
    - Publishing public disclosures
    - Extending deadlines with justification
    - Tracking upcoming disclosure deadlines
    - Notifying researchers when fixes are deployed

    Attributes:
        config: VDP configuration settings.
        DISCLOSURE_POLICIES: Days to disclosure by severity level.

    Example:
        >>> tracker = DisclosureTracker()
        >>> deadline = tracker.calculate_disclosure_date(
        ...     Severity.HIGH,
        ...     datetime.now(timezone.utc)
        ... )
        >>> print(f"Disclosure deadline: {deadline}")
    """

    # Class-level reference to disclosure policies
    DISCLOSURE_POLICIES = DISCLOSURE_POLICIES

    def __init__(
        self,
        config: Optional[VDPConfig] = None,
        submissions: Optional[Dict[str, Submission]] = None,
        advisories: Optional[Dict[str, DisclosureAdvisory]] = None,
    ):
        """Initialize the disclosure tracker.

        Args:
            config: Optional VDP configuration.
            submissions: Optional reference to submission storage.
            advisories: Optional reference to advisory storage.
        """
        self.config = config or get_config()
        self._submissions = submissions or {}
        self._advisories = advisories or {}
        self._advisory_counter = 0
        logger.info("DisclosureTracker initialized")

    def set_submissions(self, submissions: Dict[str, Submission]) -> None:
        """Set the submissions storage reference.

        Args:
            submissions: Reference to submission storage.
        """
        self._submissions = submissions

    def calculate_disclosure_date(
        self,
        severity: Severity,
        reported_at: datetime,
    ) -> datetime:
        """Calculate the disclosure deadline based on severity.

        Args:
            severity: The vulnerability severity level.
            reported_at: When the vulnerability was reported.

        Returns:
            The calculated disclosure deadline (UTC).
        """
        days = self.config.disclosure_timeline_days.get(
            severity.value,
            self.DISCLOSURE_POLICIES.get(severity.value, 90),
        )
        deadline = reported_at + timedelta(days=days)
        return deadline.replace(tzinfo=timezone.utc)

    async def check_disclosure_readiness(
        self,
        submission_id: str,
    ) -> Dict[str, Any]:
        """Verify that a submission is ready for public disclosure.

        Checks:
        - Vulnerability is confirmed
        - Fix has been deployed
        - Disclosure deadline has not passed (warn if so)
        - Advisory has been prepared

        Args:
            submission_id: The submission to check.

        Returns:
            Dictionary with readiness status and any blockers.

        Raises:
            DisclosureError: If submission not found.
        """
        submission = self._get_submission(submission_id)

        blockers = []
        warnings = []

        # Check status
        if submission.status not in (
            SubmissionStatus.FIXED,
            SubmissionStatus.DISCLOSED,
        ):
            blockers.append(f"Status must be FIXED, currently: {submission.status.value}")

        # Check fix deployment
        if not submission.fix_deployed_at:
            blockers.append("Fix has not been deployed to production")

        # Check deadline
        now = datetime.now(timezone.utc)
        if submission.disclosure_deadline:
            if now > submission.disclosure_deadline:
                warnings.append(
                    f"Disclosure deadline passed: "
                    f"{submission.disclosure_deadline.isoformat()}"
                )
            else:
                days_remaining = (submission.disclosure_deadline - now).days
                if days_remaining <= 3:
                    warnings.append(f"Only {days_remaining} days until deadline")

        # Check if advisory exists
        advisory_exists = submission_id in [
            a.submission_id for a in self._advisories.values()
        ]
        if not advisory_exists:
            blockers.append("Security advisory has not been prepared")

        ready = len(blockers) == 0

        return {
            "submission_id": submission_id,
            "ready": ready,
            "blockers": blockers,
            "warnings": warnings,
            "status": submission.status.value,
            "fix_deployed_at": (
                submission.fix_deployed_at.isoformat()
                if submission.fix_deployed_at
                else None
            ),
            "disclosure_deadline": (
                submission.disclosure_deadline.isoformat()
                if submission.disclosure_deadline
                else None
            ),
        }

    async def prepare_disclosure(
        self,
        submission_id: str,
        include_researcher_credit: bool = True,
        cve_id: Optional[str] = None,
        affected_versions: Optional[List[str]] = None,
        fixed_versions: Optional[List[str]] = None,
        workaround: Optional[str] = None,
    ) -> DisclosureAdvisory:
        """Prepare a security advisory for public disclosure.

        Generates a DisclosureAdvisory with all required information
        for public disclosure.

        Args:
            submission_id: The submission to prepare disclosure for.
            include_researcher_credit: Whether to credit the researcher.
            cve_id: Optional assigned CVE ID.
            affected_versions: List of affected versions.
            fixed_versions: List of versions containing the fix.
            workaround: Optional temporary workaround.

        Returns:
            The prepared DisclosureAdvisory.

        Raises:
            DisclosureError: If submission not found or not confirmed.
        """
        submission = self._get_submission(submission_id)

        if submission.status not in (
            SubmissionStatus.CONFIRMED,
            SubmissionStatus.REMEDIATION,
            SubmissionStatus.FIXED,
        ):
            raise DisclosureError(
                f"Cannot prepare disclosure for status: {submission.status.value}"
            )

        if not submission.severity:
            raise DisclosureError("Severity must be set before preparing disclosure")

        if not submission.cvss_score:
            raise DisclosureError("CVSS score must be set before preparing disclosure")

        # Generate advisory ID
        self._advisory_counter += 1
        year = datetime.now(timezone.utc).year
        advisory_id = f"GLSA-{year}-{self._advisory_counter:03d}"

        # Build credits
        credits = None
        if include_researcher_credit:
            # TODO: Look up researcher name from researcher_id
            credits = f"Reported by security researcher ({submission.researcher_email})"

        # Build advisory
        advisory = DisclosureAdvisory(
            submission_id=submission_id,
            advisory_id=advisory_id,
            title=submission.report.title,
            summary=self._generate_summary(submission),
            severity=submission.severity,
            cvss_score=submission.cvss_score,
            cvss_vector=submission.cvss_vector or "",
            affected_versions=affected_versions or ["< Latest"],
            fixed_versions=fixed_versions or ["Latest"],
            description=self._generate_description(submission),
            impact=submission.report.impact,
            remediation=self._generate_remediation(submission, fixed_versions),
            workaround=workaround,
            credits=credits,
            references=submission.report.references,
            cve_id=cve_id,
        )

        # Store advisory
        self._advisories[advisory_id] = advisory

        logger.info(
            "Prepared disclosure advisory: %s for %s",
            advisory_id,
            submission_id,
        )

        return advisory

    async def publish_disclosure(
        self,
        submission_id: str,
    ) -> Dict[str, Any]:
        """Publish a vulnerability disclosure.

        Updates the submission status to DISCLOSED and returns
        the advisory URL.

        Args:
            submission_id: The submission to disclose.

        Returns:
            Dictionary with disclosure information.

        Raises:
            DisclosureNotReadyError: If not ready for disclosure.
            DisclosureError: If submission not found.
        """
        # Check readiness
        readiness = await self.check_disclosure_readiness(submission_id)
        if not readiness["ready"]:
            raise DisclosureNotReadyError(
                f"Disclosure not ready: {', '.join(readiness['blockers'])}"
            )

        submission = self._get_submission(submission_id)

        # Find the advisory
        advisory = None
        for a in self._advisories.values():
            if a.submission_id == submission_id:
                advisory = a
                break

        if not advisory:
            raise DisclosureError("Advisory not found for submission")

        # Update submission
        now = datetime.now(timezone.utc)
        submission.status = SubmissionStatus.DISCLOSED
        submission.disclosed_at = now
        submission.advisory_url = (
            f"https://greenlang.io/security/advisories/{advisory.advisory_id}"
        )

        # Update advisory
        advisory.published_at = now

        logger.info(
            "Published disclosure for %s: %s",
            submission_id,
            advisory.advisory_id,
        )

        return {
            "submission_id": submission_id,
            "advisory_id": advisory.advisory_id,
            "advisory_url": submission.advisory_url,
            "published_at": now.isoformat(),
            "severity": submission.severity.value if submission.severity else None,
            "cve_id": advisory.cve_id,
        }

    async def extend_deadline(
        self,
        submission_id: str,
        days: int,
        justification: str,
    ) -> datetime:
        """Extend the disclosure deadline.

        Args:
            submission_id: The submission to extend.
            days: Number of days to extend.
            justification: Reason for the extension.

        Returns:
            The new disclosure deadline.

        Raises:
            DeadlineExtensionError: If extension not allowed.
            DisclosureError: If submission not found.
        """
        submission = self._get_submission(submission_id)

        if not submission.disclosure_deadline:
            raise DeadlineExtensionError("No disclosure deadline set")

        max_extension = self.config.max_deadline_extension_days
        if days > max_extension:
            raise DeadlineExtensionError(
                f"Extension exceeds maximum of {max_extension} days"
            )

        if days <= 0:
            raise DeadlineExtensionError("Extension must be positive number of days")

        if len(justification) < 10:
            raise DeadlineExtensionError("Justification must be at least 10 characters")

        # Calculate new deadline
        old_deadline = submission.disclosure_deadline
        new_deadline = old_deadline + timedelta(days=days)

        # Update submission
        submission.disclosure_deadline = new_deadline
        submission.notes.append(
            f"Deadline extended by {days} days at "
            f"{datetime.now(timezone.utc).isoformat()}: {justification}"
        )
        submission.metadata["deadline_extensions"] = (
            submission.metadata.get("deadline_extensions", 0) + 1
        )

        logger.info(
            "Extended deadline for %s by %d days: %s -> %s",
            submission_id,
            days,
            old_deadline.date().isoformat(),
            new_deadline.date().isoformat(),
        )

        # TODO: Notify researcher of extension

        return new_deadline

    async def get_upcoming_disclosures(
        self,
        days: int = 14,
    ) -> List[Dict[str, Any]]:
        """List submissions with disclosure deadlines approaching.

        Args:
            days: Number of days to look ahead.

        Returns:
            List of submissions with approaching deadlines.
        """
        now = datetime.now(timezone.utc)
        cutoff = now + timedelta(days=days)

        upcoming = []
        for submission in self._submissions.values():
            if submission.status in (
                SubmissionStatus.CLOSED,
                SubmissionStatus.DISCLOSED,
                SubmissionStatus.INVALID,
                SubmissionStatus.DUPLICATE,
            ):
                continue

            if submission.disclosure_deadline:
                if submission.disclosure_deadline <= cutoff:
                    days_remaining = (submission.disclosure_deadline - now).days
                    upcoming.append({
                        "submission_id": submission.submission_id,
                        "title": submission.report.title,
                        "severity": (
                            submission.severity.value
                            if submission.severity
                            else "unknown"
                        ),
                        "status": submission.status.value,
                        "disclosure_deadline": (
                            submission.disclosure_deadline.isoformat()
                        ),
                        "days_remaining": max(0, days_remaining),
                        "overdue": days_remaining < 0,
                    })

        # Sort by days remaining (most urgent first)
        upcoming.sort(key=lambda x: x["days_remaining"])

        return upcoming

    async def notify_researcher_of_fix(
        self,
        submission_id: str,
        fix_details: Optional[str] = None,
    ) -> None:
        """Notify the researcher that a fix has been deployed.

        Args:
            submission_id: The submission that was fixed.
            fix_details: Optional details about the fix.

        Raises:
            DisclosureError: If submission not found.
        """
        submission = self._get_submission(submission_id)

        logger.info(
            "Notifying researcher %s that %s is fixed",
            submission.researcher_email,
            submission_id,
        )

        # TODO: Send email to researcher with fix details
        # Include:
        # - Fix version
        # - Expected disclosure date
        # - Thank you message
        # - Bounty status if applicable

    def _get_submission(self, submission_id: str) -> Submission:
        """Get a submission by ID.

        Args:
            submission_id: The submission ID to look up.

        Returns:
            The Submission record.

        Raises:
            DisclosureError: If not found.
        """
        submission = self._submissions.get(submission_id)
        if not submission:
            raise DisclosureError(f"Submission not found: {submission_id}")
        return submission

    def _generate_summary(self, submission: Submission) -> str:
        """Generate a brief summary for the advisory.

        Args:
            submission: The submission to summarize.

        Returns:
            Summary text.
        """
        severity_text = submission.severity.value if submission.severity else "unknown"
        return (
            f"A {severity_text} severity vulnerability was discovered in "
            f"{submission.report.affected_component}. "
            f"{submission.report.impact[:200]}"
        )

    def _generate_description(self, submission: Submission) -> str:
        """Generate the full description for the advisory.

        Args:
            submission: The submission to describe.

        Returns:
            Full description text.
        """
        # Sanitize description for public disclosure
        # Remove any internal details or researcher-specific information
        description = submission.report.description

        # Truncate if too long
        if len(description) > 5000:
            description = description[:5000] + "..."

        return description

    def _generate_remediation(
        self,
        submission: Submission,
        fixed_versions: Optional[List[str]],
    ) -> str:
        """Generate remediation guidance for the advisory.

        Args:
            submission: The submission.
            fixed_versions: List of fixed versions.

        Returns:
            Remediation text.
        """
        if fixed_versions:
            versions = ", ".join(fixed_versions)
            return f"Upgrade to version {versions} or later to address this vulnerability."
        elif submission.report.suggested_fix:
            return submission.report.suggested_fix
        else:
            return "Apply the latest security patches and updates."


# ---------------------------------------------------------------------------
# Exports
# ---------------------------------------------------------------------------

__all__ = [
    "DeadlineExtensionError",
    "DisclosureError",
    "DisclosureNotReadyError",
    "DisclosureTracker",
    "DISCLOSURE_POLICIES",
]
