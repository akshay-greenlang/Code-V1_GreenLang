# -*- coding: utf-8 -*-
"""
Vulnerability Submission Handler - SEC-010

Handles incoming vulnerability reports from security researchers.
Manages submission creation, auto-acknowledgment, duplicate detection,
triage queue assignment, and security team notifications.

Classes:
    - VulnerabilitySubmissionHandler: Main handler for vulnerability submissions.

Example:
    >>> from greenlang.infrastructure.vulnerability_disclosure.submission_handler import (
    ...     VulnerabilitySubmissionHandler
    ... )
    >>> handler = VulnerabilitySubmissionHandler()
    >>> submission = await handler.submit(report, "researcher@example.com")
    >>> print(submission.submission_id)
    VDP-2026-0001
"""

from __future__ import annotations

import hashlib
import logging
import re
from datetime import datetime, timedelta, timezone
from difflib import SequenceMatcher
from typing import Any, Dict, List, Optional, Tuple

from greenlang.infrastructure.vulnerability_disclosure.config import (
    VDPConfig,
    get_config,
)
from greenlang.infrastructure.vulnerability_disclosure.models import (
    Researcher,
    Severity,
    Submission,
    SubmissionStatus,
    VulnerabilityReport,
)

logger = logging.getLogger(__name__)


# ---------------------------------------------------------------------------
# Exceptions
# ---------------------------------------------------------------------------


class SubmissionError(Exception):
    """Base exception for submission errors."""

    pass


class DuplicateSubmissionError(SubmissionError):
    """Raised when a submission is a duplicate of an existing one."""

    def __init__(self, message: str, original_id: str):
        super().__init__(message)
        self.original_id = original_id


class RateLimitError(SubmissionError):
    """Raised when researcher has exceeded submission rate limit."""

    pass


class ValidationError(SubmissionError):
    """Raised when submission validation fails."""

    pass


# ---------------------------------------------------------------------------
# Submission Handler
# ---------------------------------------------------------------------------


class VulnerabilitySubmissionHandler:
    """Handles vulnerability report submissions.

    Responsible for:
    - Validating and creating new submissions
    - Generating unique submission IDs (VDP-YYYY-NNNN)
    - Auto-acknowledgment within 24 hours
    - Duplicate detection via title/component similarity
    - Assigning submissions to triage queue
    - Notifying security team via Slack/email

    Attributes:
        config: VDP configuration settings.
        _submission_counter: In-memory counter for submission IDs.
        _submissions: In-memory storage for submissions (replaced by DB in prod).
        _researchers: In-memory storage for researchers (replaced by DB in prod).

    Example:
        >>> handler = VulnerabilitySubmissionHandler()
        >>> report = VulnerabilityReport(
        ...     title="SQL Injection in Search API",
        ...     description="The search endpoint is vulnerable...",
        ...     steps_to_reproduce=["Step 1...", "Step 2..."],
        ...     impact="Full database access",
        ...     affected_component="search-service",
        ... )
        >>> submission = await handler.submit(report, "researcher@example.com")
    """

    def __init__(self, config: Optional[VDPConfig] = None):
        """Initialize the submission handler.

        Args:
            config: Optional VDP configuration. If not provided, loads from env.
        """
        self.config = config or get_config()
        self._submission_counter: int = 0
        self._submissions: Dict[str, Submission] = {}
        self._researchers: Dict[str, Researcher] = {}
        self._rate_limit_cache: Dict[str, List[datetime]] = {}
        logger.info("VulnerabilitySubmissionHandler initialized")

    async def submit(
        self,
        report: VulnerabilityReport,
        researcher_email: str,
        researcher_name: Optional[str] = None,
        pgp_key: Optional[str] = None,
    ) -> Submission:
        """Submit a new vulnerability report.

        Creates a new submission record, generates a unique ID, checks for
        duplicates, sends auto-acknowledgment, and notifies the security team.

        Args:
            report: The vulnerability report content.
            researcher_email: Contact email for the researcher.
            researcher_name: Optional display name for the researcher.
            pgp_key: Optional PGP public key for encrypted communications.

        Returns:
            The created Submission record.

        Raises:
            ValidationError: If the report fails validation.
            RateLimitError: If the researcher has exceeded rate limits.
            DuplicateSubmissionError: If this is a clear duplicate.
        """
        start_time = datetime.now(timezone.utc)
        logger.info(
            "Processing vulnerability submission from %s: %s",
            researcher_email,
            report.title[:50],
        )

        try:
            # Step 1: Rate limiting check
            self._check_rate_limit(researcher_email)

            # Step 2: Validate the report
            self._validate_report(report)

            # Step 3: Check for duplicates
            duplicate_result = await self.detect_duplicates(report)
            if duplicate_result is not None:
                original_id, similarity = duplicate_result
                if similarity >= 0.95:
                    logger.warning(
                        "Duplicate submission detected: %.2f similarity with %s",
                        similarity,
                        original_id,
                    )
                    raise DuplicateSubmissionError(
                        f"This appears to be a duplicate of {original_id}",
                        original_id,
                    )

            # Step 4: Get or create researcher profile
            researcher = await self._get_or_create_researcher(
                email=researcher_email,
                name=researcher_name,
                pgp_key=pgp_key,
            )

            # Step 5: Generate submission ID
            submission_id = self._generate_submission_id()

            # Step 6: Create submission record
            submission = Submission(
                submission_id=submission_id,
                report=report,
                researcher_email=researcher_email,
                researcher_id=researcher.id,
                status=SubmissionStatus.SUBMITTED,
                submitted_at=start_time,
            )

            # Step 7: Store submission
            self._submissions[submission_id] = submission

            # Step 8: Update researcher stats
            researcher.submissions_count += 1
            researcher.last_submission_at = start_time
            self._researchers[researcher.email] = researcher

            # Step 9: Send auto-acknowledgment
            await self.auto_acknowledge(submission_id)

            # Step 10: Notify security team
            await self.notify_security_team(submission)

            # Step 11: Assign to triage queue
            await self.assign_to_triage(submission_id)

            processing_time = (
                datetime.now(timezone.utc) - start_time
            ).total_seconds() * 1000

            logger.info(
                "Submission created: %s (%.2fms)",
                submission_id,
                processing_time,
            )

            return submission

        except (ValidationError, RateLimitError, DuplicateSubmissionError):
            raise
        except Exception as e:
            logger.error("Failed to process submission: %s", str(e), exc_info=True)
            raise SubmissionError(f"Failed to process submission: {str(e)}") from e

    def _generate_submission_id(self) -> str:
        """Generate a unique submission ID in VDP-YYYY-NNNN format.

        Returns:
            A unique submission ID string.
        """
        year = datetime.now(timezone.utc).year
        self._submission_counter += 1
        return f"VDP-{year}-{self._submission_counter:04d}"

    def _check_rate_limit(self, email: str) -> None:
        """Check if researcher has exceeded submission rate limit.

        Limits: 5 submissions per hour, 20 per day.

        Args:
            email: Researcher email address.

        Raises:
            RateLimitError: If rate limit exceeded.
        """
        now = datetime.now(timezone.utc)
        hour_ago = now - timedelta(hours=1)
        day_ago = now - timedelta(days=1)

        # Get submission timestamps for this email
        timestamps = self._rate_limit_cache.get(email, [])

        # Clean old entries
        timestamps = [ts for ts in timestamps if ts > day_ago]

        # Check hourly limit
        hourly_count = sum(1 for ts in timestamps if ts > hour_ago)
        if hourly_count >= 5:
            raise RateLimitError(
                "Rate limit exceeded: maximum 5 submissions per hour"
            )

        # Check daily limit
        if len(timestamps) >= 20:
            raise RateLimitError(
                "Rate limit exceeded: maximum 20 submissions per day"
            )

        # Update cache
        timestamps.append(now)
        self._rate_limit_cache[email] = timestamps

    def _validate_report(self, report: VulnerabilityReport) -> None:
        """Validate the vulnerability report content.

        Args:
            report: The report to validate.

        Raises:
            ValidationError: If validation fails.
        """
        # Check for spam patterns
        spam_patterns = [
            r"click here",
            r"earn money",
            r"free bitcoin",
            r"winner",
        ]
        combined_text = f"{report.title} {report.description}".lower()
        for pattern in spam_patterns:
            if re.search(pattern, combined_text):
                raise ValidationError(f"Report appears to be spam: {pattern}")

        # Check minimum content quality
        if len(report.description.split()) < 10:
            raise ValidationError(
                "Description too brief. Please provide more detail."
            )

        # Validate component name
        if not re.match(r"^[\w\-\.]+$", report.affected_component):
            raise ValidationError(
                "Invalid component name. Use alphanumeric, hyphens, and dots."
            )

    async def detect_duplicates(
        self,
        report: VulnerabilityReport,
    ) -> Optional[Tuple[str, float]]:
        """Check for similar existing submissions.

        Uses title and component similarity to detect potential duplicates.
        Only checks submissions from the last 90 days.

        Args:
            report: The new report to check.

        Returns:
            Tuple of (original_submission_id, similarity_score) if duplicate found,
            None otherwise.
        """
        threshold = self.config.duplicate_threshold
        cutoff = datetime.now(timezone.utc) - timedelta(days=90)

        best_match: Optional[Tuple[str, float]] = None
        best_similarity = 0.0

        for sub_id, submission in self._submissions.items():
            if submission.submitted_at < cutoff:
                continue

            if submission.status in (
                SubmissionStatus.INVALID,
                SubmissionStatus.CLOSED,
            ):
                continue

            # Calculate title similarity
            title_sim = SequenceMatcher(
                None,
                report.title.lower(),
                submission.report.title.lower(),
            ).ratio()

            # Calculate component similarity
            component_sim = 1.0 if (
                report.affected_component.lower()
                == submission.report.affected_component.lower()
            ) else 0.0

            # Weighted similarity score
            similarity = (title_sim * 0.6) + (component_sim * 0.4)

            if similarity > best_similarity and similarity >= threshold:
                best_similarity = similarity
                best_match = (sub_id, similarity)

        return best_match

    async def _get_or_create_researcher(
        self,
        email: str,
        name: Optional[str] = None,
        pgp_key: Optional[str] = None,
    ) -> Researcher:
        """Get existing researcher or create new profile.

        Args:
            email: Researcher email address.
            name: Optional display name.
            pgp_key: Optional PGP public key.

        Returns:
            Researcher profile.
        """
        if email in self._researchers:
            researcher = self._researchers[email]
            # Update PGP key if provided and not already set
            if pgp_key and not researcher.pgp_key:
                researcher.pgp_key = pgp_key
            return researcher

        researcher = Researcher(
            email=email,
            name=name or "Anonymous",
            pgp_key=pgp_key,
        )
        self._researchers[email] = researcher
        logger.info("Created new researcher profile: %s", email)
        return researcher

    async def auto_acknowledge(self, submission_id: str) -> None:
        """Send auto-acknowledgment for a submission.

        Sends acknowledgment within 24 hours (configurable) and updates
        the submission status to ACKNOWLEDGED.

        Args:
            submission_id: The submission to acknowledge.

        Raises:
            SubmissionError: If submission not found or already acknowledged.
        """
        submission = self._submissions.get(submission_id)
        if not submission:
            raise SubmissionError(f"Submission not found: {submission_id}")

        if submission.acknowledged_at:
            logger.debug("Submission already acknowledged: %s", submission_id)
            return

        now = datetime.now(timezone.utc)
        submission.acknowledged_at = now
        submission.status = SubmissionStatus.ACKNOWLEDGED

        logger.info(
            "Auto-acknowledged submission %s (%.1f hours after submission)",
            submission_id,
            (now - submission.submitted_at).total_seconds() / 3600,
        )

        # TODO: Send acknowledgment email to researcher
        # await self._send_acknowledgment_email(submission)

    async def assign_to_triage(self, submission_id: str) -> None:
        """Assign submission to security team triage queue.

        Updates status to TRIAGING and creates internal tracking ticket.

        Args:
            submission_id: The submission to queue for triage.
        """
        submission = self._submissions.get(submission_id)
        if not submission:
            raise SubmissionError(f"Submission not found: {submission_id}")

        # Update status
        submission.status = SubmissionStatus.TRIAGING

        logger.info(
            "Assigned submission %s to triage queue: %s",
            submission_id,
            submission.report.affected_component,
        )

        # TODO: Create Jira/Linear ticket for triage
        # await self._create_triage_ticket(submission)

    async def notify_security_team(self, submission: Submission) -> None:
        """Send notification to security team about new submission.

        Sends alerts via configured channels (Slack, email).

        Args:
            submission: The submission to notify about.
        """
        notification_config = self.config.get_notification_config()

        if notification_config.slack_enabled:
            await self._notify_slack(submission)

        if notification_config.email_enabled:
            await self._notify_email(submission)

    async def _notify_slack(self, submission: Submission) -> None:
        """Send Slack notification about new submission.

        Args:
            submission: The submission to notify about.
        """
        # TODO: Implement actual Slack webhook integration
        logger.info(
            "Slack notification sent for %s: %s",
            submission.submission_id,
            submission.report.title,
        )

    async def _notify_email(self, submission: Submission) -> None:
        """Send email notification to security team.

        Args:
            submission: The submission to notify about.
        """
        # TODO: Implement actual email sending via SES
        logger.info(
            "Email notification sent for %s to security team",
            submission.submission_id,
        )

    async def get_submission_status(
        self,
        submission_id: str,
    ) -> Dict[str, Any]:
        """Get public status information for a submission.

        Returns limited information suitable for public API.
        Does not include internal notes or full report details.

        Args:
            submission_id: The submission to look up.

        Returns:
            Dictionary with public status information.

        Raises:
            SubmissionError: If submission not found.
        """
        submission = self._submissions.get(submission_id)
        if not submission:
            raise SubmissionError(f"Submission not found: {submission_id}")

        return {
            "submission_id": submission.submission_id,
            "status": submission.status.value,
            "submitted_at": submission.submitted_at.isoformat(),
            "acknowledged_at": (
                submission.acknowledged_at.isoformat()
                if submission.acknowledged_at
                else None
            ),
            "severity": submission.severity.value if submission.severity else None,
            "disclosure_deadline": (
                submission.disclosure_deadline.isoformat()
                if submission.disclosure_deadline
                else None
            ),
        }

    async def get_submission(self, submission_id: str) -> Optional[Submission]:
        """Get full submission details (internal use).

        Args:
            submission_id: The submission to retrieve.

        Returns:
            The Submission record or None if not found.
        """
        return self._submissions.get(submission_id)

    async def list_submissions(
        self,
        status: Optional[SubmissionStatus] = None,
        severity: Optional[Severity] = None,
        limit: int = 50,
        offset: int = 0,
    ) -> List[Submission]:
        """List submissions with optional filtering.

        Args:
            status: Optional status filter.
            severity: Optional severity filter.
            limit: Maximum number of results.
            offset: Number of results to skip.

        Returns:
            List of matching submissions.
        """
        results = list(self._submissions.values())

        if status:
            results = [s for s in results if s.status == status]

        if severity:
            results = [s for s in results if s.severity == severity]

        # Sort by submitted_at descending
        results.sort(key=lambda s: s.submitted_at, reverse=True)

        return results[offset : offset + limit]


# ---------------------------------------------------------------------------
# Exports
# ---------------------------------------------------------------------------

__all__ = [
    "DuplicateSubmissionError",
    "RateLimitError",
    "SubmissionError",
    "ValidationError",
    "VulnerabilitySubmissionHandler",
]
