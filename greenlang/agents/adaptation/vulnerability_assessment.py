# -*- coding: utf-8 -*-
"""
GL-ADAPT-X-003: Vulnerability Assessment Agent
===============================================

Assesses the vulnerability of assets, systems, and operations to climate
hazards based on sensitivity, adaptive capacity, and exposure factors.

Capabilities:
    - Multi-factor vulnerability assessment
    - Sensitivity analysis
    - Adaptive capacity evaluation
    - Vulnerability scoring and categorization
    - Sector-specific vulnerability factors
    - Temporal vulnerability projections
    - Vulnerability gap analysis

Zero-Hallucination Guarantees:
    - All vulnerability scores from deterministic calculations
    - Sensitivity factors from verified standards
    - Complete provenance tracking
    - No LLM-based vulnerability predictions

Author: GreenLang Team
Version: 1.0.0
"""

import hashlib
import json
import logging
import time
from datetime import datetime
from enum import Enum
from typing import Any, Dict, List, Optional

from pydantic import BaseModel, Field, field_validator

from greenlang.agents.base import AgentConfig, AgentResult, BaseAgent
from greenlang.utilities.determinism import DeterministicClock

logger = logging.getLogger(__name__)


# =============================================================================
# Enums and Constants
# =============================================================================

class VulnerabilityLevel(str, Enum):
    """Vulnerability levels."""
    CRITICAL = "critical"
    HIGH = "high"
    MODERATE = "moderate"
    LOW = "low"
    MINIMAL = "minimal"


class SensitivityFactor(str, Enum):
    """Factors affecting sensitivity to climate hazards."""
    PHYSICAL_STRUCTURE = "physical_structure"
    OPERATIONAL_DEPENDENCIES = "operational_dependencies"
    SUPPLY_CHAIN = "supply_chain"
    WORKFORCE = "workforce"
    TECHNOLOGY = "technology"
    REGULATORY = "regulatory"
    FINANCIAL = "financial"
    ENVIRONMENTAL = "environmental"


class AdaptiveCapacityFactor(str, Enum):
    """Factors affecting adaptive capacity."""
    FINANCIAL_RESOURCES = "financial_resources"
    TECHNICAL_CAPACITY = "technical_capacity"
    INSTITUTIONAL_CAPACITY = "institutional_capacity"
    INFORMATION_ACCESS = "information_access"
    FLEXIBILITY = "flexibility"
    SOCIAL_CAPITAL = "social_capital"
    GOVERNANCE = "governance"


class SectorType(str, Enum):
    """Industry sector types for vulnerability assessment."""
    AGRICULTURE = "agriculture"
    MANUFACTURING = "manufacturing"
    ENERGY = "energy"
    TRANSPORTATION = "transportation"
    REAL_ESTATE = "real_estate"
    RETAIL = "retail"
    FINANCIAL_SERVICES = "financial_services"
    HEALTHCARE = "healthcare"
    TECHNOLOGY = "technology"
    MINING = "mining"
    UTILITIES = "utilities"
    CONSTRUCTION = "construction"


# Vulnerability thresholds
VULNERABILITY_THRESHOLDS = {
    VulnerabilityLevel.CRITICAL: 0.8,
    VulnerabilityLevel.HIGH: 0.6,
    VulnerabilityLevel.MODERATE: 0.4,
    VulnerabilityLevel.LOW: 0.2,
    VulnerabilityLevel.MINIMAL: 0.0
}

# Sector baseline sensitivity scores
SECTOR_SENSITIVITY = {
    SectorType.AGRICULTURE: 0.8,
    SectorType.MANUFACTURING: 0.6,
    SectorType.ENERGY: 0.7,
    SectorType.TRANSPORTATION: 0.65,
    SectorType.REAL_ESTATE: 0.5,
    SectorType.RETAIL: 0.45,
    SectorType.FINANCIAL_SERVICES: 0.3,
    SectorType.HEALTHCARE: 0.55,
    SectorType.TECHNOLOGY: 0.4,
    SectorType.MINING: 0.75,
    SectorType.UTILITIES: 0.7,
    SectorType.CONSTRUCTION: 0.6,
}


# =============================================================================
# Pydantic Models
# =============================================================================

class SensitivityScore(BaseModel):
    """Score for a single sensitivity factor."""
    factor: SensitivityFactor = Field(..., description="Sensitivity factor")
    score: float = Field(..., ge=0, le=1, description="Score (0-1)")
    weight: float = Field(default=1.0, ge=0, description="Weight for aggregation")
    rationale: str = Field(default="", description="Assessment rationale")
    data_source: str = Field(default="assessment", description="Data source")


class AdaptiveCapacityScore(BaseModel):
    """Score for a single adaptive capacity factor."""
    factor: AdaptiveCapacityFactor = Field(..., description="Adaptive capacity factor")
    score: float = Field(..., ge=0, le=1, description="Score (0-1, higher=more adaptive)")
    weight: float = Field(default=1.0, ge=0, description="Weight for aggregation")
    rationale: str = Field(default="", description="Assessment rationale")


class VulnerabilityComponent(BaseModel):
    """Detailed breakdown of vulnerability components."""
    sensitivity_score: float = Field(..., ge=0, le=1, description="Overall sensitivity")
    adaptive_capacity_score: float = Field(..., ge=0, le=1, description="Overall adaptive capacity")
    exposure_score: float = Field(..., ge=0, le=1, description="Exposure score from hazards")

    sensitivity_details: List[SensitivityScore] = Field(
        default_factory=list, description="Individual sensitivity scores"
    )
    adaptive_capacity_details: List[AdaptiveCapacityScore] = Field(
        default_factory=list, description="Individual adaptive capacity scores"
    )


class VulnerabilityResult(BaseModel):
    """Complete vulnerability assessment result for an asset."""
    asset_id: str = Field(..., description="Asset identifier")
    asset_name: str = Field(..., description="Asset name")
    sector: SectorType = Field(..., description="Industry sector")

    # Overall scores
    vulnerability_score: float = Field(..., ge=0, le=1, description="Overall vulnerability")
    vulnerability_level: VulnerabilityLevel = Field(..., description="Vulnerability level")

    # Components
    components: VulnerabilityComponent = Field(..., description="Vulnerability components")

    # Hazard-specific vulnerability
    hazard_vulnerabilities: Dict[str, float] = Field(
        default_factory=dict,
        description="Vulnerability by hazard type"
    )

    # Gaps and recommendations
    vulnerability_gaps: List[str] = Field(
        default_factory=list,
        description="Identified vulnerability gaps"
    )
    priority_factors: List[str] = Field(
        default_factory=list,
        description="Priority factors to address"
    )

    # Metadata
    assessed_at: datetime = Field(default_factory=DeterministicClock.now)
    assessment_version: str = Field(default="1.0.0")
    confidence: float = Field(default=0.8, ge=0, le=1)

    # Provenance
    calculation_trace: List[str] = Field(default_factory=list)
    provenance_hash: str = Field(default="")


class AssetVulnerabilityInput(BaseModel):
    """Input for a single asset vulnerability assessment."""
    asset_id: str = Field(..., description="Asset identifier")
    asset_name: str = Field(..., description="Asset name")
    sector: SectorType = Field(..., description="Industry sector")
    exposure_score: float = Field(default=0.5, ge=0, le=1, description="Exposure from hazard mapping")

    # Optional detailed sensitivity inputs
    sensitivity_inputs: Dict[str, float] = Field(
        default_factory=dict,
        description="Sensitivity scores by factor (0-1)"
    )

    # Optional adaptive capacity inputs
    adaptive_capacity_inputs: Dict[str, float] = Field(
        default_factory=dict,
        description="Adaptive capacity scores by factor (0-1)"
    )

    # Custom weights
    sensitivity_weights: Dict[str, float] = Field(
        default_factory=dict,
        description="Custom weights for sensitivity factors"
    )
    adaptive_capacity_weights: Dict[str, float] = Field(
        default_factory=dict,
        description="Custom weights for adaptive capacity factors"
    )

    # Asset attributes
    age_years: Optional[int] = Field(None, ge=0, description="Asset age")
    value_usd: Optional[float] = Field(None, ge=0, description="Asset value")
    employee_count: Optional[int] = Field(None, ge=0, description="Employees")
    has_insurance: bool = Field(default=False, description="Has climate insurance")
    has_adaptation_plan: bool = Field(default=False, description="Has adaptation plan")


class VulnerabilityAssessmentInput(BaseModel):
    """Input model for Vulnerability Assessment Agent."""
    assessment_id: str = Field(..., description="Unique assessment identifier")
    assets: List[AssetVulnerabilityInput] = Field(..., min_length=1, description="Assets to assess")
    hazard_types: List[str] = Field(
        default_factory=list,
        description="Hazard types for hazard-specific vulnerability"
    )
    time_horizon: str = Field(default="current", description="Time horizon")
    include_gaps_analysis: bool = Field(default=True, description="Include gap analysis")


class VulnerabilityAssessmentOutput(BaseModel):
    """Output model for Vulnerability Assessment Agent."""
    assessment_id: str = Field(..., description="Assessment identifier")
    completed_at: datetime = Field(default_factory=DeterministicClock.now)

    # Results
    vulnerability_results: List[VulnerabilityResult] = Field(
        default_factory=list,
        description="Vulnerability results for each asset"
    )

    # Summary
    total_assets_assessed: int = Field(default=0)
    critical_vulnerability_count: int = Field(default=0)
    high_vulnerability_count: int = Field(default=0)
    average_vulnerability: float = Field(default=0.0, ge=0, le=1)

    # Portfolio view
    portfolio_vulnerability_score: float = Field(default=0.0, ge=0, le=1)
    most_vulnerable_sectors: List[Dict[str, Any]] = Field(default_factory=list)
    common_gaps: List[str] = Field(default_factory=list)

    # Processing info
    processing_time_ms: float = Field(default=0.0)
    provenance_hash: str = Field(default="")


# =============================================================================
# Vulnerability Assessment Agent Implementation
# =============================================================================

class VulnerabilityAssessmentAgent(BaseAgent):
    """
    GL-ADAPT-X-003: Vulnerability Assessment Agent

    Assesses vulnerability of assets to climate hazards using deterministic
    scoring based on sensitivity, adaptive capacity, and exposure.

    Zero-Hallucination Implementation:
        - All scores from deterministic calculations
        - Sector factors from verified standards
        - Complete audit trail
        - No LLM-based predictions

    Example:
        >>> agent = VulnerabilityAssessmentAgent()
        >>> result = agent.run({
        ...     "assessment_id": "VA001",
        ...     "assets": [{"asset_id": "A1", "asset_name": "Facility", "sector": "manufacturing"}]
        ... })
    """

    AGENT_ID = "GL-ADAPT-X-003"
    AGENT_NAME = "Vulnerability Assessment Agent"
    VERSION = "1.0.0"

    def __init__(self, config: Optional[AgentConfig] = None):
        """Initialize the Vulnerability Assessment Agent."""
        if config is None:
            config = AgentConfig(
                name=self.AGENT_NAME,
                description="Assesses asset vulnerability to climate hazards",
                version=self.VERSION,
                parameters={
                    "sensitivity_weight": 0.4,
                    "adaptive_capacity_weight": 0.3,
                    "exposure_weight": 0.3,
                }
            )

        # Default factors before super().__init__()
        self._default_sensitivity_weights = {
            SensitivityFactor.PHYSICAL_STRUCTURE: 1.2,
            SensitivityFactor.OPERATIONAL_DEPENDENCIES: 1.0,
            SensitivityFactor.SUPPLY_CHAIN: 1.0,
            SensitivityFactor.WORKFORCE: 0.8,
            SensitivityFactor.TECHNOLOGY: 0.9,
            SensitivityFactor.REGULATORY: 0.7,
            SensitivityFactor.FINANCIAL: 0.8,
            SensitivityFactor.ENVIRONMENTAL: 0.9,
        }

        self._default_adaptive_weights = {
            AdaptiveCapacityFactor.FINANCIAL_RESOURCES: 1.2,
            AdaptiveCapacityFactor.TECHNICAL_CAPACITY: 1.1,
            AdaptiveCapacityFactor.INSTITUTIONAL_CAPACITY: 1.0,
            AdaptiveCapacityFactor.INFORMATION_ACCESS: 0.8,
            AdaptiveCapacityFactor.FLEXIBILITY: 1.0,
            AdaptiveCapacityFactor.SOCIAL_CAPITAL: 0.7,
            AdaptiveCapacityFactor.GOVERNANCE: 0.9,
        }

        super().__init__(config)
        logger.info(f"Initialized {self.AGENT_NAME} v{self.VERSION}")

    def initialize(self):
        """Initialize agent resources."""
        logger.info("Vulnerability Assessment Agent initialized")

    def execute(self, input_data: Dict[str, Any]) -> AgentResult:
        """
        Execute vulnerability assessment.

        Args:
            input_data: Input containing assets to assess

        Returns:
            AgentResult with VulnerabilityAssessmentOutput
        """
        start_time = time.time()

        try:
            # Parse input
            assessment_input = VulnerabilityAssessmentInput(**input_data)
            self.logger.info(
                f"Starting vulnerability assessment: {assessment_input.assessment_id}, "
                f"{len(assessment_input.assets)} assets"
            )

            # Assess each asset
            results: List[VulnerabilityResult] = []
            for asset in assessment_input.assets:
                result = self._assess_asset(
                    asset=asset,
                    hazard_types=assessment_input.hazard_types,
                    include_gaps=assessment_input.include_gaps_analysis
                )
                results.append(result)

            # Calculate summary statistics
            critical_count = sum(1 for r in results if r.vulnerability_level == VulnerabilityLevel.CRITICAL)
            high_count = sum(1 for r in results if r.vulnerability_level == VulnerabilityLevel.HIGH)
            avg_vulnerability = sum(r.vulnerability_score for r in results) / len(results) if results else 0

            # Portfolio-level analysis
            portfolio_score = self._calculate_portfolio_vulnerability(results)
            sector_analysis = self._analyze_sectors(results)
            common_gaps = self._identify_common_gaps(results)

            # Build output
            processing_time = (time.time() - start_time) * 1000

            output = VulnerabilityAssessmentOutput(
                assessment_id=assessment_input.assessment_id,
                vulnerability_results=results,
                total_assets_assessed=len(results),
                critical_vulnerability_count=critical_count,
                high_vulnerability_count=high_count,
                average_vulnerability=avg_vulnerability,
                portfolio_vulnerability_score=portfolio_score,
                most_vulnerable_sectors=sector_analysis,
                common_gaps=common_gaps,
                processing_time_ms=processing_time,
            )

            # Calculate provenance
            output.provenance_hash = self._calculate_provenance_hash(assessment_input, output)

            self.logger.info(
                f"Vulnerability assessment complete: {len(results)} assets, "
                f"avg vulnerability: {avg_vulnerability:.2f}"
            )

            return AgentResult(
                success=True,
                data=output.model_dump(),
                metadata={
                    "agent_id": self.AGENT_ID,
                    "version": self.VERSION,
                    "critical_count": critical_count,
                }
            )

        except Exception as e:
            self.logger.error(f"Vulnerability assessment failed: {str(e)}", exc_info=True)
            return AgentResult(
                success=False,
                error=str(e),
                metadata={"agent_id": self.AGENT_ID, "version": self.VERSION}
            )

    def _assess_asset(
        self,
        asset: AssetVulnerabilityInput,
        hazard_types: List[str],
        include_gaps: bool
    ) -> VulnerabilityResult:
        """Assess vulnerability of a single asset."""
        trace = []

        # Calculate sensitivity
        sensitivity_scores = self._calculate_sensitivity(asset)
        sensitivity = self._aggregate_scores(
            [(s.score, s.weight) for s in sensitivity_scores]
        )
        trace.append(f"sensitivity={sensitivity:.4f}")

        # Calculate adaptive capacity
        adaptive_scores = self._calculate_adaptive_capacity(asset)
        adaptive_capacity = self._aggregate_scores(
            [(s.score, s.weight) for s in adaptive_scores]
        )
        trace.append(f"adaptive_capacity={adaptive_capacity:.4f}")

        # Get exposure
        exposure = asset.exposure_score
        trace.append(f"exposure={exposure:.4f}")

        # Calculate overall vulnerability
        # V = (Sensitivity * Exposure) * (1 - Adaptive Capacity)
        vulnerability = (sensitivity * exposure) * (1 - adaptive_capacity * 0.5)
        vulnerability = min(max(vulnerability, 0.0), 1.0)
        trace.append(f"vulnerability=(S*E)*(1-AC*0.5)={vulnerability:.4f}")

        # Classify level
        vuln_level = self._classify_vulnerability(vulnerability)

        # Calculate hazard-specific vulnerabilities
        hazard_vulns = {}
        for hazard in hazard_types:
            hazard_vuln = self._calculate_hazard_vulnerability(
                hazard, sensitivity, adaptive_capacity, exposure
            )
            hazard_vulns[hazard] = hazard_vuln

        # Identify gaps
        gaps = []
        priority_factors = []
        if include_gaps:
            gaps, priority_factors = self._identify_gaps(
                sensitivity_scores, adaptive_scores, asset
            )

        components = VulnerabilityComponent(
            sensitivity_score=sensitivity,
            adaptive_capacity_score=adaptive_capacity,
            exposure_score=exposure,
            sensitivity_details=sensitivity_scores,
            adaptive_capacity_details=adaptive_scores,
        )

        result = VulnerabilityResult(
            asset_id=asset.asset_id,
            asset_name=asset.asset_name,
            sector=asset.sector,
            vulnerability_score=vulnerability,
            vulnerability_level=vuln_level,
            components=components,
            hazard_vulnerabilities=hazard_vulns,
            vulnerability_gaps=gaps,
            priority_factors=priority_factors,
            calculation_trace=trace,
        )

        result.provenance_hash = hashlib.sha256(
            json.dumps({
                "asset_id": asset.asset_id,
                "vulnerability": vulnerability,
            }, sort_keys=True).encode()
        ).hexdigest()[:16]

        return result

    def _calculate_sensitivity(
        self,
        asset: AssetVulnerabilityInput
    ) -> List[SensitivityScore]:
        """Calculate sensitivity scores for each factor."""
        scores = []

        # Get sector baseline
        sector_baseline = SECTOR_SENSITIVITY.get(asset.sector, 0.5)

        for factor in SensitivityFactor:
            # Check for user-provided score
            if factor.value in asset.sensitivity_inputs:
                score = asset.sensitivity_inputs[factor.value]
            else:
                # Calculate from asset attributes
                score = self._estimate_sensitivity_factor(factor, asset, sector_baseline)

            weight = asset.sensitivity_weights.get(
                factor.value,
                self._default_sensitivity_weights.get(factor, 1.0)
            )

            scores.append(SensitivityScore(
                factor=factor,
                score=score,
                weight=weight,
                rationale=f"Sector baseline: {sector_baseline:.2f}, adjusted for asset attributes"
            ))

        return scores

    def _estimate_sensitivity_factor(
        self,
        factor: SensitivityFactor,
        asset: AssetVulnerabilityInput,
        baseline: float
    ) -> float:
        """Estimate sensitivity factor from asset attributes."""
        score = baseline

        if factor == SensitivityFactor.PHYSICAL_STRUCTURE:
            # Older assets more sensitive
            if asset.age_years:
                if asset.age_years > 30:
                    score *= 1.2
                elif asset.age_years < 5:
                    score *= 0.8

        elif factor == SensitivityFactor.FINANCIAL:
            # Larger assets may have more resources
            if asset.value_usd and asset.value_usd > 100_000_000:
                score *= 0.9

        elif factor == SensitivityFactor.WORKFORCE:
            # Larger workforce more complex
            if asset.employee_count and asset.employee_count > 1000:
                score *= 1.1

        return min(max(score, 0.0), 1.0)

    def _calculate_adaptive_capacity(
        self,
        asset: AssetVulnerabilityInput
    ) -> List[AdaptiveCapacityScore]:
        """Calculate adaptive capacity scores for each factor."""
        scores = []

        for factor in AdaptiveCapacityFactor:
            # Check for user-provided score
            if factor.value in asset.adaptive_capacity_inputs:
                score = asset.adaptive_capacity_inputs[factor.value]
            else:
                # Estimate from attributes
                score = self._estimate_adaptive_factor(factor, asset)

            weight = asset.adaptive_capacity_weights.get(
                factor.value,
                self._default_adaptive_weights.get(factor, 1.0)
            )

            scores.append(AdaptiveCapacityScore(
                factor=factor,
                score=score,
                weight=weight,
                rationale="Estimated from asset attributes"
            ))

        return scores

    def _estimate_adaptive_factor(
        self,
        factor: AdaptiveCapacityFactor,
        asset: AssetVulnerabilityInput
    ) -> float:
        """Estimate adaptive capacity factor from asset attributes."""
        base_score = 0.5

        if factor == AdaptiveCapacityFactor.FINANCIAL_RESOURCES:
            if asset.value_usd:
                if asset.value_usd > 100_000_000:
                    base_score = 0.7
                elif asset.value_usd > 10_000_000:
                    base_score = 0.6

        elif factor == AdaptiveCapacityFactor.INSTITUTIONAL_CAPACITY:
            if asset.has_adaptation_plan:
                base_score = 0.7
            if asset.has_insurance:
                base_score += 0.1

        elif factor == AdaptiveCapacityFactor.TECHNICAL_CAPACITY:
            if asset.sector == SectorType.TECHNOLOGY:
                base_score = 0.7
            elif asset.sector in [SectorType.FINANCIAL_SERVICES, SectorType.MANUFACTURING]:
                base_score = 0.6

        return min(max(base_score, 0.0), 1.0)

    def _aggregate_scores(self, scores_weights: List[tuple]) -> float:
        """Aggregate scores using weighted average."""
        if not scores_weights:
            return 0.5

        total_weight = sum(w for _, w in scores_weights)
        if total_weight == 0:
            return 0.5

        weighted_sum = sum(s * w for s, w in scores_weights)
        return weighted_sum / total_weight

    def _classify_vulnerability(self, score: float) -> VulnerabilityLevel:
        """Classify vulnerability score into level."""
        if score >= VULNERABILITY_THRESHOLDS[VulnerabilityLevel.CRITICAL]:
            return VulnerabilityLevel.CRITICAL
        elif score >= VULNERABILITY_THRESHOLDS[VulnerabilityLevel.HIGH]:
            return VulnerabilityLevel.HIGH
        elif score >= VULNERABILITY_THRESHOLDS[VulnerabilityLevel.MODERATE]:
            return VulnerabilityLevel.MODERATE
        elif score >= VULNERABILITY_THRESHOLDS[VulnerabilityLevel.LOW]:
            return VulnerabilityLevel.LOW
        else:
            return VulnerabilityLevel.MINIMAL

    def _calculate_hazard_vulnerability(
        self,
        hazard: str,
        sensitivity: float,
        adaptive_capacity: float,
        exposure: float
    ) -> float:
        """Calculate vulnerability for a specific hazard."""
        # Hazard-specific modifiers
        hazard_modifiers = {
            "flood_riverine": 1.1,
            "flood_coastal": 1.15,
            "extreme_heat": 0.9,
            "drought": 0.95,
            "wildfire": 1.2,
            "cyclone": 1.25,
        }
        modifier = hazard_modifiers.get(hazard, 1.0)

        vuln = (sensitivity * exposure * modifier) * (1 - adaptive_capacity * 0.5)
        return min(max(vuln, 0.0), 1.0)

    def _identify_gaps(
        self,
        sensitivity_scores: List[SensitivityScore],
        adaptive_scores: List[AdaptiveCapacityScore],
        asset: AssetVulnerabilityInput
    ) -> tuple:
        """Identify vulnerability gaps and priority factors."""
        gaps = []
        priorities = []

        # High sensitivity factors
        for s in sensitivity_scores:
            if s.score > 0.7:
                gaps.append(f"High sensitivity: {s.factor.value} ({s.score:.2f})")
                priorities.append(s.factor.value)

        # Low adaptive capacity factors
        for a in adaptive_scores:
            if a.score < 0.4:
                gaps.append(f"Low adaptive capacity: {a.factor.value} ({a.score:.2f})")
                if a.factor.value not in priorities:
                    priorities.append(a.factor.value)

        # Missing adaptations
        if not asset.has_adaptation_plan:
            gaps.append("No adaptation plan in place")
        if not asset.has_insurance:
            gaps.append("No climate risk insurance")

        return gaps[:5], priorities[:3]

    def _calculate_portfolio_vulnerability(
        self,
        results: List[VulnerabilityResult]
    ) -> float:
        """Calculate portfolio-level vulnerability."""
        if not results:
            return 0.0
        return sum(r.vulnerability_score for r in results) / len(results)

    def _analyze_sectors(
        self,
        results: List[VulnerabilityResult]
    ) -> List[Dict[str, Any]]:
        """Analyze vulnerability by sector."""
        sector_data: Dict[SectorType, List[float]] = {}
        for r in results:
            if r.sector not in sector_data:
                sector_data[r.sector] = []
            sector_data[r.sector].append(r.vulnerability_score)

        sector_analysis = []
        for sector, scores in sector_data.items():
            avg_score = sum(scores) / len(scores)
            sector_analysis.append({
                "sector": sector.value,
                "asset_count": len(scores),
                "average_vulnerability": avg_score,
            })

        # Sort by vulnerability
        sector_analysis.sort(key=lambda x: x["average_vulnerability"], reverse=True)
        return sector_analysis[:5]

    def _identify_common_gaps(
        self,
        results: List[VulnerabilityResult]
    ) -> List[str]:
        """Identify common gaps across portfolio."""
        gap_counts: Dict[str, int] = {}
        for r in results:
            for gap in r.vulnerability_gaps:
                gap_counts[gap] = gap_counts.get(gap, 0) + 1

        # Sort by frequency
        sorted_gaps = sorted(gap_counts.items(), key=lambda x: x[1], reverse=True)
        return [g[0] for g in sorted_gaps[:5]]

    def _calculate_provenance_hash(
        self,
        input_data: VulnerabilityAssessmentInput,
        output: VulnerabilityAssessmentOutput
    ) -> str:
        """Calculate SHA-256 hash for provenance."""
        provenance_data = {
            "agent_id": self.AGENT_ID,
            "assessment_id": input_data.assessment_id,
            "asset_count": len(input_data.assets),
            "average_vulnerability": output.average_vulnerability,
            "timestamp": output.completed_at.isoformat(),
        }
        return hashlib.sha256(
            json.dumps(provenance_data, sort_keys=True).encode()
        ).hexdigest()


# =============================================================================
# Module Exports
# =============================================================================

__all__ = [
    "VulnerabilityAssessmentAgent",
    "VulnerabilityLevel",
    "SensitivityFactor",
    "AdaptiveCapacityFactor",
    "SectorType",
    "SensitivityScore",
    "AdaptiveCapacityScore",
    "VulnerabilityComponent",
    "VulnerabilityResult",
    "AssetVulnerabilityInput",
    "VulnerabilityAssessmentInput",
    "VulnerabilityAssessmentOutput",
    "VULNERABILITY_THRESHOLDS",
    "SECTOR_SENSITIVITY",
]
