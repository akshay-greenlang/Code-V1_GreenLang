"""
Tool implementations for {{ name }}.

This module provides tool wrapper classes for zero-hallucination calculations.
All tools are DETERMINISTIC and track complete provenance.

Generated from AgentSpec: {{ id }}
Version: {{ version }}

ZERO-HALLUCINATION GUARANTEE:
- All tools produce deterministic, reproducible results
- No LLM calls within tool execution
- Complete parameter validation
- Full provenance tracking with SHA-256 hashes
"""

from abc import ABC, abstractmethod
from typing import Any, Dict, List, Optional, Union
from datetime import datetime
import hashlib
import logging

from pydantic import BaseModel, Field, validator

logger = logging.getLogger(__name__)


# =============================================================================
# Base Tool Class
# =============================================================================

class BaseTool(ABC):
    """
    Base class for all deterministic tools.

    All tools must:
    - Be deterministic (same inputs -> same outputs)
    - Track provenance
    - Validate parameters
    - NOT make any LLM calls
    """

    name: str = "base_tool"
    description: str = "Base tool"
    safe: bool = True  # Safe tools are deterministic

    def __init__(self):
        """Initialize base tool."""
        self._call_count = 0
        self._last_call_time: Optional[datetime] = None

    @abstractmethod
{% if use_async %}
    async def execute(self, params: Dict[str, Any]) -> Dict[str, Any]:
{% else %}
    def execute(self, params: Dict[str, Any]) -> Dict[str, Any]:
{% endif %}
        """
        Execute the tool with given parameters.

        Args:
            params: Tool parameters

        Returns:
            Execution result dictionary

        Raises:
            ValueError: If parameters are invalid
            ToolExecutionError: If execution fails
        """
        pass

    def validate_params(self, params: Dict[str, Any]) -> bool:
        """
        Validate input parameters.

        Args:
            params: Parameters to validate

        Returns:
            True if valid

        Raises:
            ValueError: If validation fails
        """
        return True

    def hash_result(self, result: Dict[str, Any]) -> str:
        """
        Calculate SHA-256 hash of result for provenance.

        Args:
            result: Result dictionary

        Returns:
            SHA-256 hash string
        """
        import json
        json_str = json.dumps(result, sort_keys=True, default=str)
        return hashlib.sha256(json_str.encode()).hexdigest()


# =============================================================================
# Tool Parameter Models
# =============================================================================

{% for tool in tools %}
class {{ tool.class_name }}Params(BaseModel):
    """Input parameters for {{ tool.name }}."""

{% for param in tool.input_parameters %}
    {{ param.name }}: {% if not param.required %}Optional[{% endif %}{{ param.type | json_type_to_python }}{% if not param.required %}]{% endif %} = Field(
        {% if param.required %}...{% elif param.default is not none %}{{ param.default | repr }}{% else %}None{% endif %},
        description="{{ param.description or param.name }}"
    )
{% endfor %}
{% if not tool.input_parameters %}
    # No parameters defined
    pass
{% endif %}


class {{ tool.class_name }}Result(BaseModel):
    """Output result for {{ tool.name }}."""

{% for param in tool.output_parameters %}
    {{ param.name }}: {% if not param.required %}Optional[{% endif %}{{ param.type | json_type_to_python }}{% if not param.required %}]{% endif %} = Field(
        {% if param.required %}...{% else %}None{% endif %},
        description="{{ param.description or param.name }}"
    )
{% endfor %}
{% if not tool.output_parameters %}
    # Standard result fields
    status: str = Field("success", description="Execution status")
    result: Any = Field(None, description="Tool result")
{% endif %}

    # Provenance fields
    result_hash: Optional[str] = Field(None, description="SHA-256 hash of result")
    executed_at: Optional[datetime] = Field(None, description="Execution timestamp")


{% endfor %}

# =============================================================================
# Tool Implementations
# =============================================================================

{% for tool in tools %}
class {{ tool.class_name }}(BaseTool):
    """
    {{ tool.description }}

    Implementation: {{ tool.impl }}
    Safe (Deterministic): {{ tool.safe }}

    This tool follows zero-hallucination principles:
    - Deterministic execution
    - No LLM calls
    - Complete provenance tracking
    """

    name = "{{ tool.name }}"
    description = "{{ tool.description }}"
    safe = {{ tool.safe }}

    def __init__(self):
        """Initialize {{ tool.class_name }}."""
        super().__init__()
        logger.debug(f"Initialized tool: {self.name}")

{% if use_async %}
    async def execute(self, params: Dict[str, Any]) -> Dict[str, Any]:
{% else %}
    def execute(self, params: Dict[str, Any]) -> Dict[str, Any]:
{% endif %}
        """
        Execute {{ tool.name }} tool.

        {{ tool.description }}

        Args:
            params: Tool parameters
{% for param in tool.input_parameters %}
                - {{ param.name }}: {{ param.description or param.type }}{% if param.required %} (required){% endif %}

{% endfor %}

        Returns:
            Dictionary containing:
{% for param in tool.output_parameters %}
                - {{ param.name }}: {{ param.description or param.type }}
{% endfor %}
                - result_hash: SHA-256 hash for provenance

        Raises:
            ValueError: If required parameters are missing
            ToolExecutionError: If execution fails
        """
        self._call_count += 1
        self._last_call_time = datetime.utcnow()

        # Validate parameters
        self._validate_required_params(params)
        validated = {{ tool.class_name }}Params(**params)

        try:
            # Execute deterministic logic
{% if use_async %}
            result_data = await self._execute_internal(validated)
{% else %}
            result_data = self._execute_internal(validated)
{% endif %}

            # Calculate provenance hash
            result_hash = self.hash_result(result_data)

            # Build result
            result = {
                **result_data,
                "result_hash": result_hash,
                "executed_at": self._last_call_time.isoformat(),
            }

            logger.debug(f"Tool {self.name} executed successfully: {result_hash[:16]}...")
            return result

        except Exception as e:
            logger.error(f"Tool {self.name} execution failed: {e}", exc_info=True)
            raise

    def _validate_required_params(self, params: Dict[str, Any]) -> None:
        """Validate required parameters are present."""
{% for param in tool.input_parameters %}
{% if param.required %}
        if "{{ param.name }}" not in params or params["{{ param.name }}"] is None:
            raise ValueError("Missing required parameter: {{ param.name }}")
{% endif %}
{% endfor %}
{% if not tool.input_parameters %}
        pass  # No required parameters
{% endif %}

{% if use_async %}
    async def _execute_internal(self, params: {{ tool.class_name }}Params) -> Dict[str, Any]:
{% else %}
    def _execute_internal(self, params: {{ tool.class_name }}Params) -> Dict[str, Any]:
{% endif %}
        """
        Internal execution logic.

        IMPORTANT: This method must be DETERMINISTIC.
        Same inputs must always produce same outputs.

        TODO: Implement actual tool logic here.
        The implementation should:
        1. Use only deterministic operations
        2. Access external data through caching/lookup
        3. Never call LLMs for calculations
        4. Return results with all output fields

        Args:
            params: Validated parameters

        Returns:
            Dictionary of output values
        """
        # Placeholder implementation
        # TODO: Replace with actual {{ tool.impl }} implementation

        logger.warning(f"Tool {self.name} using placeholder implementation")

        return {
{% for param in tool.output_parameters %}
            "{{ param.name }}": None,  # TODO: Calculate actual value
{% endfor %}
{% if not tool.output_parameters %}
            "status": "success",
            "result": None,
{% endif %}
        }


{% endfor %}

# =============================================================================
# Tool Registry
# =============================================================================

TOOL_REGISTRY: Dict[str, type] = {
{% for tool in tools %}
    "{{ tool.name }}": {{ tool.class_name }},
{% endfor %}
}


def get_tool(name: str) -> Optional[BaseTool]:
    """
    Get tool instance by name.

    Args:
        name: Tool name

    Returns:
        Tool instance or None if not found
    """
    tool_class = TOOL_REGISTRY.get(name)
    if tool_class:
        return tool_class()
    return None


def list_tools() -> List[str]:
    """
    List all available tool names.

    Returns:
        List of tool names
    """
    return list(TOOL_REGISTRY.keys())


def get_tool_info(name: str) -> Optional[Dict[str, Any]]:
    """
    Get tool metadata.

    Args:
        name: Tool name

    Returns:
        Tool info dictionary or None
    """
    tool_class = TOOL_REGISTRY.get(name)
    if tool_class:
        return {
            "name": tool_class.name,
            "description": tool_class.description,
            "safe": tool_class.safe,
        }
    return None


# =============================================================================
# Module Exports
# =============================================================================

__all__ = [
    # Base
    "BaseTool",
{% for tool in tools %}
    # {{ tool.name }}
    "{{ tool.class_name }}",
    "{{ tool.class_name }}Params",
    "{{ tool.class_name }}Result",
{% endfor %}
    # Registry
    "TOOL_REGISTRY",
    "get_tool",
    "list_tools",
    "get_tool_info",
]
