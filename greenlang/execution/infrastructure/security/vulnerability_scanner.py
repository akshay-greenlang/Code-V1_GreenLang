"""
Vulnerability Scanner for GreenLang
====================================

TASK-160: Vulnerability Scanning Implementation

This module provides comprehensive vulnerability scanning capabilities
for dependencies, container images, and code patterns.

Features:
- Dependency vulnerability checking
- Container image scanning interface
- Code security pattern matching
- CVE database integration
- Severity classification
- Remediation recommendations
- Scan scheduling and reporting

Example:
    >>> from greenlang.infrastructure.security import VulnerabilityScanner, ScanConfig
    >>> config = ScanConfig(scan_interval_hours=24)
    >>> scanner = VulnerabilityScanner(config)
    >>> await scanner.start()
    >>> result = await scanner.scan_dependencies("/path/to/project")

Author: GreenLang Security Team
Created: 2025-12-07
"""

import asyncio
import hashlib
import json
import logging
import os
import re
import subprocess
from abc import ABC, abstractmethod
from dataclasses import dataclass, field
from datetime import datetime, timedelta, timezone
from enum import Enum
from pathlib import Path
from typing import Any, Callable, Dict, List, Optional, Set, Tuple, Type
from uuid import uuid4

from pydantic import BaseModel, Field

logger = logging.getLogger(__name__)


# =============================================================================
# Enums and Constants
# =============================================================================


class VulnerabilitySeverity(str, Enum):
    """Vulnerability severity levels (CVSS-based)."""
    CRITICAL = "critical"  # CVSS 9.0-10.0
    HIGH = "high"          # CVSS 7.0-8.9
    MEDIUM = "medium"      # CVSS 4.0-6.9
    LOW = "low"            # CVSS 0.1-3.9
    INFO = "info"          # Informational
    UNKNOWN = "unknown"


class ScanType(str, Enum):
    """Types of vulnerability scans."""
    DEPENDENCY = "dependency"
    CONTAINER = "container"
    CODE = "code"
    SECRET = "secret"
    CONFIGURATION = "configuration"
    LICENSE = "license"


class ScanStatus(str, Enum):
    """Status of a scan operation."""
    PENDING = "pending"
    RUNNING = "running"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"


class RemediationStatus(str, Enum):
    """Status of remediation."""
    AVAILABLE = "available"
    NOT_AVAILABLE = "not_available"
    PENDING = "pending"
    APPLIED = "applied"
    IGNORED = "ignored"


# =============================================================================
# Configuration
# =============================================================================


@dataclass
class ScanConfig:
    """Configuration for vulnerability scanning."""
    # Scheduling
    scan_interval_hours: int = 24
    enable_scheduled_scans: bool = True

    # Dependency scanning
    dependency_scan_enabled: bool = True
    package_managers: List[str] = field(
        default_factory=lambda: ["pip", "npm", "cargo", "go"]
    )

    # Container scanning
    container_scan_enabled: bool = True
    container_registries: List[str] = field(default_factory=list)

    # Code scanning
    code_scan_enabled: bool = True
    code_patterns_path: Optional[str] = None

    # CVE database
    cve_database_url: str = "https://nvd.nist.gov/feeds/json/cve/1.1"
    cve_cache_ttl_hours: int = 6
    cve_api_key: Optional[str] = field(
        default_factory=lambda: os.getenv("NVD_API_KEY")
    )

    # Severity thresholds
    fail_on_severity: VulnerabilitySeverity = VulnerabilitySeverity.HIGH
    ignore_severities: List[VulnerabilitySeverity] = field(default_factory=list)

    # Reporting
    report_format: str = "json"  # json, sarif, html
    report_path: str = "/var/log/greenlang/security-scans"

    # Notifications
    notification_enabled: bool = True
    notification_webhook: Optional[str] = None
    notify_on_severity: VulnerabilitySeverity = VulnerabilitySeverity.HIGH

    # Performance
    max_concurrent_scans: int = 5
    scan_timeout_seconds: int = 3600


# =============================================================================
# Vulnerability Models
# =============================================================================


class CVEInfo(BaseModel):
    """CVE information from vulnerability database."""
    cve_id: str = Field(..., description="CVE identifier (e.g., CVE-2021-44228)")
    description: str = Field(default="", description="Vulnerability description")
    severity: VulnerabilitySeverity = Field(default=VulnerabilitySeverity.UNKNOWN)
    cvss_score: Optional[float] = Field(default=None, ge=0.0, le=10.0)
    cvss_vector: Optional[str] = Field(default=None)
    published_date: Optional[datetime] = Field(default=None)
    last_modified_date: Optional[datetime] = Field(default=None)
    references: List[str] = Field(default_factory=list)
    cwe_ids: List[str] = Field(default_factory=list)


class AffectedPackage(BaseModel):
    """Information about an affected package."""
    name: str = Field(..., description="Package name")
    version: str = Field(..., description="Affected version")
    ecosystem: str = Field(..., description="Package ecosystem (pip, npm, etc.)")
    fixed_in: Optional[str] = Field(default=None, description="Version with fix")
    vulnerable_versions: List[str] = Field(default_factory=list)


class Remediation(BaseModel):
    """Remediation information for a vulnerability."""
    remediation_id: str = Field(default_factory=lambda: str(uuid4()))
    status: RemediationStatus = Field(default=RemediationStatus.AVAILABLE)
    recommendation: str = Field(..., description="Remediation recommendation")
    fixed_version: Optional[str] = Field(default=None)
    upgrade_path: List[str] = Field(default_factory=list)
    workaround: Optional[str] = Field(default=None)
    breaking_changes: bool = Field(default=False)
    estimated_effort: str = Field(default="low")  # low, medium, high
    references: List[str] = Field(default_factory=list)


class Vulnerability(BaseModel):
    """A detected vulnerability."""
    vulnerability_id: str = Field(default_factory=lambda: str(uuid4()))
    scan_id: str = Field(..., description="Parent scan ID")
    scan_type: ScanType = Field(..., description="Type of scan that found this")
    cve: Optional[CVEInfo] = Field(default=None)
    severity: VulnerabilitySeverity = Field(default=VulnerabilitySeverity.UNKNOWN)
    title: str = Field(..., description="Vulnerability title")
    description: str = Field(default="")
    affected_package: Optional[AffectedPackage] = Field(default=None)
    affected_file: Optional[str] = Field(default=None)
    affected_line: Optional[int] = Field(default=None)
    remediation: Optional[Remediation] = Field(default=None)
    detected_at: datetime = Field(default_factory=lambda: datetime.now(timezone.utc))
    false_positive: bool = Field(default=False)
    ignored: bool = Field(default=False)
    ignored_reason: Optional[str] = Field(default=None)
    tags: List[str] = Field(default_factory=list)
    provenance_hash: str = Field(default="")

    def __init__(self, **data):
        super().__init__(**data)
        if not self.provenance_hash:
            self.provenance_hash = self._calculate_hash()

    def _calculate_hash(self) -> str:
        """Calculate provenance hash."""
        data = f"{self.vulnerability_id}:{self.title}:{self.severity.value}"
        return hashlib.sha256(data.encode()).hexdigest()


class ScanResult(BaseModel):
    """Result of a vulnerability scan."""
    scan_id: str = Field(default_factory=lambda: str(uuid4()))
    scan_type: ScanType = Field(..., description="Type of scan")
    status: ScanStatus = Field(default=ScanStatus.PENDING)
    target: str = Field(..., description="Scan target (path, image, etc.)")
    started_at: Optional[datetime] = Field(default=None)
    completed_at: Optional[datetime] = Field(default=None)
    duration_seconds: float = Field(default=0.0)
    vulnerabilities: List[Vulnerability] = Field(default_factory=list)
    critical_count: int = Field(default=0)
    high_count: int = Field(default=0)
    medium_count: int = Field(default=0)
    low_count: int = Field(default=0)
    info_count: int = Field(default=0)
    error_message: Optional[str] = Field(default=None)
    metadata: Dict[str, Any] = Field(default_factory=dict)
    provenance_hash: str = Field(default="")

    @property
    def total_vulnerabilities(self) -> int:
        """Total number of vulnerabilities."""
        return len(self.vulnerabilities)

    @property
    def passed(self) -> bool:
        """Check if scan passed (no critical/high vulnerabilities)."""
        return self.critical_count == 0 and self.high_count == 0

    def calculate_counts(self) -> None:
        """Calculate vulnerability counts by severity."""
        self.critical_count = sum(
            1 for v in self.vulnerabilities
            if v.severity == VulnerabilitySeverity.CRITICAL and not v.ignored
        )
        self.high_count = sum(
            1 for v in self.vulnerabilities
            if v.severity == VulnerabilitySeverity.HIGH and not v.ignored
        )
        self.medium_count = sum(
            1 for v in self.vulnerabilities
            if v.severity == VulnerabilitySeverity.MEDIUM and not v.ignored
        )
        self.low_count = sum(
            1 for v in self.vulnerabilities
            if v.severity == VulnerabilitySeverity.LOW and not v.ignored
        )
        self.info_count = sum(
            1 for v in self.vulnerabilities
            if v.severity == VulnerabilitySeverity.INFO and not v.ignored
        )

    def calculate_provenance_hash(self) -> str:
        """Calculate provenance hash for audit."""
        data = f"{self.scan_id}:{self.target}:{self.total_vulnerabilities}"
        return hashlib.sha256(data.encode()).hexdigest()


# =============================================================================
# CVE Database Client
# =============================================================================


class CVEDatabase:
    """Interface to CVE database for vulnerability lookups."""

    def __init__(self, config: ScanConfig):
        self.config = config
        self._cache: Dict[str, Tuple[CVEInfo, datetime]] = {}
        self._lock = asyncio.Lock()

    async def lookup(self, cve_id: str) -> Optional[CVEInfo]:
        """
        Look up CVE information.

        Args:
            cve_id: CVE identifier

        Returns:
            CVEInfo if found
        """
        # Check cache
        async with self._lock:
            if cve_id in self._cache:
                info, cached_at = self._cache[cve_id]
                cache_age = (datetime.now(timezone.utc) - cached_at).total_seconds() / 3600
                if cache_age < self.config.cve_cache_ttl_hours:
                    return info

        # Fetch from NVD
        try:
            import httpx

            url = f"https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}"
            headers = {}
            if self.config.cve_api_key:
                headers["apiKey"] = self.config.cve_api_key

            async with httpx.AsyncClient() as client:
                response = await client.get(url, headers=headers, timeout=30)

                if response.status_code != 200:
                    return None

                data = response.json()
                vulnerabilities = data.get("vulnerabilities", [])

                if not vulnerabilities:
                    return None

                cve_data = vulnerabilities[0].get("cve", {})

                # Parse CVSS
                metrics = cve_data.get("metrics", {})
                cvss_v31 = metrics.get("cvssMetricV31", [{}])[0] if metrics.get("cvssMetricV31") else None
                cvss_data = cvss_v31.get("cvssData", {}) if cvss_v31 else {}

                severity = self._cvss_to_severity(cvss_data.get("baseScore"))

                info = CVEInfo(
                    cve_id=cve_id,
                    description=self._get_description(cve_data),
                    severity=severity,
                    cvss_score=cvss_data.get("baseScore"),
                    cvss_vector=cvss_data.get("vectorString"),
                    published_date=self._parse_date(cve_data.get("published")),
                    last_modified_date=self._parse_date(cve_data.get("lastModified")),
                    references=self._get_references(cve_data),
                    cwe_ids=self._get_cwes(cve_data)
                )

                # Cache result
                async with self._lock:
                    self._cache[cve_id] = (info, datetime.now(timezone.utc))

                return info

        except Exception as e:
            logger.error(f"CVE lookup failed for {cve_id}: {e}")
            return None

    def _cvss_to_severity(self, score: Optional[float]) -> VulnerabilitySeverity:
        """Convert CVSS score to severity."""
        if score is None:
            return VulnerabilitySeverity.UNKNOWN
        if score >= 9.0:
            return VulnerabilitySeverity.CRITICAL
        if score >= 7.0:
            return VulnerabilitySeverity.HIGH
        if score >= 4.0:
            return VulnerabilitySeverity.MEDIUM
        if score >= 0.1:
            return VulnerabilitySeverity.LOW
        return VulnerabilitySeverity.INFO

    def _get_description(self, cve_data: Dict) -> str:
        """Extract description from CVE data."""
        descriptions = cve_data.get("descriptions", [])
        for desc in descriptions:
            if desc.get("lang") == "en":
                return desc.get("value", "")
        return descriptions[0].get("value", "") if descriptions else ""

    def _get_references(self, cve_data: Dict) -> List[str]:
        """Extract references from CVE data."""
        refs = cve_data.get("references", [])
        return [ref.get("url", "") for ref in refs if ref.get("url")]

    def _get_cwes(self, cve_data: Dict) -> List[str]:
        """Extract CWE IDs from CVE data."""
        weaknesses = cve_data.get("weaknesses", [])
        cwes = []
        for weakness in weaknesses:
            for desc in weakness.get("description", []):
                value = desc.get("value", "")
                if value.startswith("CWE-"):
                    cwes.append(value)
        return cwes

    def _parse_date(self, date_str: Optional[str]) -> Optional[datetime]:
        """Parse date string."""
        if not date_str:
            return None
        try:
            return datetime.fromisoformat(date_str.replace("Z", "+00:00"))
        except Exception:
            return None


# =============================================================================
# Scanners
# =============================================================================


class BaseScanner(ABC):
    """Base class for vulnerability scanners."""

    @abstractmethod
    async def scan(self, target: str) -> ScanResult:
        """Perform a scan on the target."""
        pass

    @abstractmethod
    def supports(self, target: str) -> bool:
        """Check if scanner supports the target."""
        pass


class PipDependencyScanner(BaseScanner):
    """Scanner for Python pip dependencies."""

    def __init__(self, cve_database: CVEDatabase):
        self.cve_database = cve_database

    def supports(self, target: str) -> bool:
        """Check if target is a Python project."""
        path = Path(target)
        return (
            path.is_dir() and
            (path / "requirements.txt").exists() or
            (path / "setup.py").exists() or
            (path / "pyproject.toml").exists()
        )

    async def scan(self, target: str) -> ScanResult:
        """Scan Python dependencies for vulnerabilities."""
        result = ScanResult(
            scan_type=ScanType.DEPENDENCY,
            target=target,
            started_at=datetime.now(timezone.utc),
            status=ScanStatus.RUNNING,
            metadata={"ecosystem": "pip"}
        )

        try:
            # Use pip-audit if available
            vulnerabilities = await self._scan_with_pip_audit(target, result.scan_id)
            result.vulnerabilities = vulnerabilities
            result.calculate_counts()
            result.status = ScanStatus.COMPLETED

        except Exception as e:
            result.status = ScanStatus.FAILED
            result.error_message = str(e)
            logger.error(f"Pip scan failed: {e}")

        result.completed_at = datetime.now(timezone.utc)
        result.duration_seconds = (
            result.completed_at - result.started_at
        ).total_seconds()
        result.provenance_hash = result.calculate_provenance_hash()

        return result

    async def _scan_with_pip_audit(
        self,
        target: str,
        scan_id: str
    ) -> List[Vulnerability]:
        """Run pip-audit and parse results."""
        vulnerabilities = []

        try:
            # Run pip-audit
            process = await asyncio.create_subprocess_exec(
                "pip-audit",
                "--format", "json",
                "--requirement", str(Path(target) / "requirements.txt"),
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )

            stdout, stderr = await process.communicate()

            if process.returncode != 0 and not stdout:
                # pip-audit not available, use fallback
                return await self._scan_fallback(target, scan_id)

            audit_results = json.loads(stdout.decode()) if stdout else []

            for item in audit_results:
                package_name = item.get("name", "")
                installed_version = item.get("version", "")

                for vuln in item.get("vulns", []):
                    cve_id = vuln.get("id", "")

                    # Look up CVE details
                    cve_info = None
                    if cve_id.startswith("CVE-"):
                        cve_info = await self.cve_database.lookup(cve_id)

                    severity = VulnerabilitySeverity.UNKNOWN
                    if cve_info:
                        severity = cve_info.severity

                    remediation = None
                    if vuln.get("fix_versions"):
                        fixed_version = vuln["fix_versions"][0]
                        remediation = Remediation(
                            status=RemediationStatus.AVAILABLE,
                            recommendation=f"Upgrade {package_name} to version {fixed_version}",
                            fixed_version=fixed_version,
                            upgrade_path=[installed_version, fixed_version]
                        )

                    vulnerabilities.append(Vulnerability(
                        scan_id=scan_id,
                        scan_type=ScanType.DEPENDENCY,
                        cve=cve_info,
                        severity=severity,
                        title=f"{cve_id}: {package_name}",
                        description=vuln.get("description", ""),
                        affected_package=AffectedPackage(
                            name=package_name,
                            version=installed_version,
                            ecosystem="pip",
                            fixed_in=vuln.get("fix_versions", [None])[0],
                            vulnerable_versions=[installed_version]
                        ),
                        remediation=remediation,
                        tags=["dependency", "pip"]
                    ))

        except FileNotFoundError:
            return await self._scan_fallback(target, scan_id)
        except Exception as e:
            logger.error(f"pip-audit scan error: {e}")

        return vulnerabilities

    async def _scan_fallback(
        self,
        target: str,
        scan_id: str
    ) -> List[Vulnerability]:
        """Fallback scanning when pip-audit not available."""
        # This is a simplified fallback - in production would use
        # safety or similar tool
        logger.warning("pip-audit not available, using fallback scanner")
        return []


class NpmDependencyScanner(BaseScanner):
    """Scanner for NPM dependencies."""

    def __init__(self, cve_database: CVEDatabase):
        self.cve_database = cve_database

    def supports(self, target: str) -> bool:
        """Check if target is an NPM project."""
        path = Path(target)
        return path.is_dir() and (path / "package.json").exists()

    async def scan(self, target: str) -> ScanResult:
        """Scan NPM dependencies for vulnerabilities."""
        result = ScanResult(
            scan_type=ScanType.DEPENDENCY,
            target=target,
            started_at=datetime.now(timezone.utc),
            status=ScanStatus.RUNNING,
            metadata={"ecosystem": "npm"}
        )

        try:
            vulnerabilities = await self._scan_with_npm_audit(target, result.scan_id)
            result.vulnerabilities = vulnerabilities
            result.calculate_counts()
            result.status = ScanStatus.COMPLETED

        except Exception as e:
            result.status = ScanStatus.FAILED
            result.error_message = str(e)
            logger.error(f"NPM scan failed: {e}")

        result.completed_at = datetime.now(timezone.utc)
        result.duration_seconds = (
            result.completed_at - result.started_at
        ).total_seconds()
        result.provenance_hash = result.calculate_provenance_hash()

        return result

    async def _scan_with_npm_audit(
        self,
        target: str,
        scan_id: str
    ) -> List[Vulnerability]:
        """Run npm audit and parse results."""
        vulnerabilities = []

        try:
            process = await asyncio.create_subprocess_exec(
                "npm", "audit", "--json",
                cwd=target,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )

            stdout, stderr = await process.communicate()
            audit_results = json.loads(stdout.decode()) if stdout else {}

            for advisory_id, advisory in audit_results.get("advisories", {}).items():
                severity_str = advisory.get("severity", "unknown").lower()
                severity = {
                    "critical": VulnerabilitySeverity.CRITICAL,
                    "high": VulnerabilitySeverity.HIGH,
                    "moderate": VulnerabilitySeverity.MEDIUM,
                    "low": VulnerabilitySeverity.LOW
                }.get(severity_str, VulnerabilitySeverity.UNKNOWN)

                cve_ids = advisory.get("cves", [])
                cve_info = None
                if cve_ids:
                    cve_info = await self.cve_database.lookup(cve_ids[0])

                remediation = None
                patched_versions = advisory.get("patched_versions", "")
                if patched_versions and patched_versions != "<0.0.0":
                    remediation = Remediation(
                        status=RemediationStatus.AVAILABLE,
                        recommendation=f"Upgrade to {patched_versions}",
                        fixed_version=patched_versions
                    )

                vulnerabilities.append(Vulnerability(
                    scan_id=scan_id,
                    scan_type=ScanType.DEPENDENCY,
                    cve=cve_info,
                    severity=severity,
                    title=advisory.get("title", f"Advisory {advisory_id}"),
                    description=advisory.get("overview", ""),
                    affected_package=AffectedPackage(
                        name=advisory.get("module_name", ""),
                        version=advisory.get("findings", [{}])[0].get("version", ""),
                        ecosystem="npm",
                        fixed_in=patched_versions if patched_versions else None,
                        vulnerable_versions=advisory.get("vulnerable_versions", "").split(" || ")
                    ),
                    remediation=remediation,
                    tags=["dependency", "npm"]
                ))

        except Exception as e:
            logger.error(f"npm audit error: {e}")

        return vulnerabilities


class CodePatternScanner(BaseScanner):
    """Scanner for code security patterns."""

    # Common security anti-patterns
    DEFAULT_PATTERNS = {
        "hardcoded_password": {
            "pattern": r'(?i)(password|passwd|pwd)\s*=\s*["\'][^"\']+["\']',
            "severity": VulnerabilitySeverity.HIGH,
            "description": "Hardcoded password detected",
            "recommendation": "Use environment variables or secrets manager"
        },
        "hardcoded_api_key": {
            "pattern": r'(?i)(api[_-]?key|apikey|api[_-]?secret)\s*=\s*["\'][A-Za-z0-9]{16,}["\']',
            "severity": VulnerabilitySeverity.HIGH,
            "description": "Hardcoded API key detected",
            "recommendation": "Use environment variables or secrets manager"
        },
        "sql_injection": {
            "pattern": r'(?i)(execute|executemany|cursor\.execute)\s*\([^)]*%s',
            "severity": VulnerabilitySeverity.CRITICAL,
            "description": "Potential SQL injection vulnerability",
            "recommendation": "Use parameterized queries"
        },
        "command_injection": {
            "pattern": r'(?i)(os\.system|subprocess\.call|subprocess\.run)\s*\([^)]*\+',
            "severity": VulnerabilitySeverity.CRITICAL,
            "description": "Potential command injection vulnerability",
            "recommendation": "Avoid string concatenation in shell commands"
        },
        "insecure_random": {
            "pattern": r'(?i)random\.(random|randint|choice)\s*\(',
            "severity": VulnerabilitySeverity.MEDIUM,
            "description": "Insecure random number generator",
            "recommendation": "Use secrets module for cryptographic operations"
        },
        "eval_usage": {
            "pattern": r'(?i)eval\s*\(',
            "severity": VulnerabilitySeverity.HIGH,
            "description": "Use of eval() function",
            "recommendation": "Avoid eval() as it can execute arbitrary code"
        },
        "pickle_usage": {
            "pattern": r'(?i)pickle\.(load|loads)\s*\(',
            "severity": VulnerabilitySeverity.HIGH,
            "description": "Use of pickle with untrusted data",
            "recommendation": "Use safer serialization formats like JSON"
        },
        "debug_enabled": {
            "pattern": r'(?i)DEBUG\s*=\s*True',
            "severity": VulnerabilitySeverity.MEDIUM,
            "description": "Debug mode enabled",
            "recommendation": "Disable debug mode in production"
        },
        "insecure_ssl": {
            "pattern": r'(?i)verify\s*=\s*False',
            "severity": VulnerabilitySeverity.HIGH,
            "description": "SSL verification disabled",
            "recommendation": "Enable SSL certificate verification"
        }
    }

    def __init__(self, custom_patterns: Optional[Dict[str, Dict]] = None):
        self.patterns = {**self.DEFAULT_PATTERNS, **(custom_patterns or {})}

    def supports(self, target: str) -> bool:
        """Check if target is a directory with code."""
        return Path(target).is_dir()

    async def scan(self, target: str) -> ScanResult:
        """Scan code for security patterns."""
        result = ScanResult(
            scan_type=ScanType.CODE,
            target=target,
            started_at=datetime.now(timezone.utc),
            status=ScanStatus.RUNNING,
            metadata={"patterns_checked": len(self.patterns)}
        )

        try:
            vulnerabilities = await self._scan_directory(target, result.scan_id)
            result.vulnerabilities = vulnerabilities
            result.calculate_counts()
            result.status = ScanStatus.COMPLETED

        except Exception as e:
            result.status = ScanStatus.FAILED
            result.error_message = str(e)
            logger.error(f"Code scan failed: {e}")

        result.completed_at = datetime.now(timezone.utc)
        result.duration_seconds = (
            result.completed_at - result.started_at
        ).total_seconds()
        result.provenance_hash = result.calculate_provenance_hash()

        return result

    async def _scan_directory(
        self,
        target: str,
        scan_id: str
    ) -> List[Vulnerability]:
        """Scan directory for code patterns."""
        vulnerabilities = []
        target_path = Path(target)

        # File extensions to scan
        extensions = {".py", ".js", ".ts", ".go", ".java", ".rb", ".php"}

        for file_path in target_path.rglob("*"):
            if not file_path.is_file():
                continue

            if file_path.suffix not in extensions:
                continue

            # Skip common non-code directories
            if any(part in str(file_path) for part in [
                "node_modules", ".git", "__pycache__", "venv", ".venv", "dist", "build"
            ]):
                continue

            try:
                content = file_path.read_text(encoding="utf-8", errors="ignore")

                for pattern_name, pattern_info in self.patterns.items():
                    matches = list(re.finditer(
                        pattern_info["pattern"],
                        content,
                        re.MULTILINE
                    ))

                    for match in matches:
                        # Calculate line number
                        line_number = content[:match.start()].count("\n") + 1

                        vulnerabilities.append(Vulnerability(
                            scan_id=scan_id,
                            scan_type=ScanType.CODE,
                            severity=pattern_info["severity"],
                            title=pattern_name.replace("_", " ").title(),
                            description=pattern_info["description"],
                            affected_file=str(file_path.relative_to(target_path)),
                            affected_line=line_number,
                            remediation=Remediation(
                                status=RemediationStatus.AVAILABLE,
                                recommendation=pattern_info["recommendation"]
                            ),
                            tags=["code", "pattern", pattern_name]
                        ))

            except Exception as e:
                logger.warning(f"Failed to scan file {file_path}: {e}")

        return vulnerabilities


class ContainerImageScanner(BaseScanner):
    """Scanner for container image vulnerabilities."""

    def __init__(self, cve_database: CVEDatabase):
        self.cve_database = cve_database

    def supports(self, target: str) -> bool:
        """Check if target looks like a container image reference."""
        # Simple check for image reference format
        return "/" in target or ":" in target

    async def scan(self, target: str) -> ScanResult:
        """Scan container image for vulnerabilities."""
        result = ScanResult(
            scan_type=ScanType.CONTAINER,
            target=target,
            started_at=datetime.now(timezone.utc),
            status=ScanStatus.RUNNING,
            metadata={"image": target}
        )

        try:
            # Use trivy if available
            vulnerabilities = await self._scan_with_trivy(target, result.scan_id)
            result.vulnerabilities = vulnerabilities
            result.calculate_counts()
            result.status = ScanStatus.COMPLETED

        except Exception as e:
            result.status = ScanStatus.FAILED
            result.error_message = str(e)
            logger.error(f"Container scan failed: {e}")

        result.completed_at = datetime.now(timezone.utc)
        result.duration_seconds = (
            result.completed_at - result.started_at
        ).total_seconds()
        result.provenance_hash = result.calculate_provenance_hash()

        return result

    async def _scan_with_trivy(
        self,
        image: str,
        scan_id: str
    ) -> List[Vulnerability]:
        """Run trivy and parse results."""
        vulnerabilities = []

        try:
            process = await asyncio.create_subprocess_exec(
                "trivy", "image", "--format", "json", image,
                stdout=asyncio.subprocess.PIPE,
                stderr=asyncio.subprocess.PIPE
            )

            stdout, stderr = await process.communicate()
            trivy_results = json.loads(stdout.decode()) if stdout else {}

            for result in trivy_results.get("Results", []):
                target_type = result.get("Type", "")

                for vuln in result.get("Vulnerabilities", []):
                    cve_id = vuln.get("VulnerabilityID", "")

                    severity_str = vuln.get("Severity", "").lower()
                    severity = {
                        "critical": VulnerabilitySeverity.CRITICAL,
                        "high": VulnerabilitySeverity.HIGH,
                        "medium": VulnerabilitySeverity.MEDIUM,
                        "low": VulnerabilitySeverity.LOW
                    }.get(severity_str, VulnerabilitySeverity.UNKNOWN)

                    cve_info = None
                    if cve_id.startswith("CVE-"):
                        cve_info = await self.cve_database.lookup(cve_id)

                    remediation = None
                    if vuln.get("FixedVersion"):
                        remediation = Remediation(
                            status=RemediationStatus.AVAILABLE,
                            recommendation=f"Upgrade to {vuln['FixedVersion']}",
                            fixed_version=vuln["FixedVersion"]
                        )

                    vulnerabilities.append(Vulnerability(
                        scan_id=scan_id,
                        scan_type=ScanType.CONTAINER,
                        cve=cve_info,
                        severity=severity,
                        title=f"{cve_id}: {vuln.get('PkgName', '')}",
                        description=vuln.get("Description", ""),
                        affected_package=AffectedPackage(
                            name=vuln.get("PkgName", ""),
                            version=vuln.get("InstalledVersion", ""),
                            ecosystem=target_type,
                            fixed_in=vuln.get("FixedVersion")
                        ),
                        remediation=remediation,
                        tags=["container", target_type]
                    ))

        except FileNotFoundError:
            logger.warning("trivy not available for container scanning")
        except Exception as e:
            logger.error(f"trivy scan error: {e}")

        return vulnerabilities


# =============================================================================
# Vulnerability Scanner
# =============================================================================


class VulnerabilityScanner:
    """
    Vulnerability Scanner for GreenLang.

    Provides comprehensive vulnerability scanning for dependencies,
    container images, and code patterns.

    Attributes:
        config: Scanner configuration
        cve_database: CVE database client

    Example:
        >>> scanner = VulnerabilityScanner()
        >>> await scanner.start()
        >>>
        >>> # Scan dependencies
        >>> result = await scanner.scan_dependencies("/path/to/project")
        >>>
        >>> # Scan container image
        >>> result = await scanner.scan_container("myimage:latest")
        >>>
        >>> # Generate report
        >>> report = await scanner.generate_report([result])
    """

    def __init__(self, config: Optional[ScanConfig] = None):
        """
        Initialize the vulnerability scanner.

        Args:
            config: Scanner configuration
        """
        self.config = config or ScanConfig()
        self.cve_database = CVEDatabase(self.config)

        # Initialize scanners
        self._scanners: List[BaseScanner] = [
            PipDependencyScanner(self.cve_database),
            NpmDependencyScanner(self.cve_database),
            CodePatternScanner(),
            ContainerImageScanner(self.cve_database),
        ]

        # State
        self._running = False
        self._scheduler_task: Optional[asyncio.Task] = None
        self._scan_history: List[ScanResult] = []
        self._semaphore = asyncio.Semaphore(self.config.max_concurrent_scans)

        logger.info("VulnerabilityScanner initialized")

    def register_scanner(self, scanner: BaseScanner) -> None:
        """Register a custom scanner."""
        self._scanners.append(scanner)

    async def start(self) -> None:
        """Start the scanner with scheduled scans."""
        if self._running:
            return

        self._running = True

        if self.config.enable_scheduled_scans:
            self._scheduler_task = asyncio.create_task(self._scheduler_loop())

        logger.info("VulnerabilityScanner started")

    async def stop(self) -> None:
        """Stop the scanner."""
        self._running = False

        if self._scheduler_task:
            self._scheduler_task.cancel()
            try:
                await self._scheduler_task
            except asyncio.CancelledError:
                pass

        logger.info("VulnerabilityScanner stopped")

    async def scan(self, target: str) -> List[ScanResult]:
        """
        Scan a target with all applicable scanners.

        Args:
            target: Path or reference to scan

        Returns:
            List of scan results
        """
        results = []

        for scanner in self._scanners:
            if scanner.supports(target):
                async with self._semaphore:
                    try:
                        result = await asyncio.wait_for(
                            scanner.scan(target),
                            timeout=self.config.scan_timeout_seconds
                        )
                        results.append(result)
                        self._scan_history.append(result)

                    except asyncio.TimeoutError:
                        logger.error(f"Scan timeout for {type(scanner).__name__}")
                    except Exception as e:
                        logger.error(f"Scan error: {e}")

        return results

    async def scan_dependencies(self, path: str) -> ScanResult:
        """
        Scan project dependencies.

        Args:
            path: Path to project

        Returns:
            Combined scan result
        """
        results = []

        for scanner in self._scanners:
            if (
                isinstance(scanner, (PipDependencyScanner, NpmDependencyScanner))
                and scanner.supports(path)
            ):
                async with self._semaphore:
                    result = await scanner.scan(path)
                    results.append(result)

        # Combine results
        if not results:
            return ScanResult(
                scan_type=ScanType.DEPENDENCY,
                target=path,
                status=ScanStatus.COMPLETED
            )

        combined = ScanResult(
            scan_type=ScanType.DEPENDENCY,
            target=path,
            status=ScanStatus.COMPLETED,
            started_at=min(r.started_at for r in results if r.started_at),
            completed_at=max(r.completed_at for r in results if r.completed_at)
        )

        for result in results:
            combined.vulnerabilities.extend(result.vulnerabilities)

        combined.calculate_counts()
        combined.provenance_hash = combined.calculate_provenance_hash()

        self._scan_history.append(combined)
        return combined

    async def scan_code(self, path: str) -> ScanResult:
        """
        Scan code for security patterns.

        Args:
            path: Path to code

        Returns:
            Scan result
        """
        scanner = CodePatternScanner()
        async with self._semaphore:
            result = await scanner.scan(path)
            self._scan_history.append(result)
            return result

    async def scan_container(self, image: str) -> ScanResult:
        """
        Scan a container image.

        Args:
            image: Container image reference

        Returns:
            Scan result
        """
        scanner = ContainerImageScanner(self.cve_database)
        async with self._semaphore:
            result = await scanner.scan(image)
            self._scan_history.append(result)
            return result

    async def _scheduler_loop(self) -> None:
        """Scheduled scanning loop."""
        while self._running:
            try:
                await asyncio.sleep(self.config.scan_interval_hours * 3600)
                # In production, would scan configured targets
                logger.info("Scheduled scan triggered")

            except asyncio.CancelledError:
                break
            except Exception as e:
                logger.error(f"Scheduler error: {e}")

    async def generate_report(
        self,
        results: List[ScanResult],
        format: str = "json"
    ) -> str:
        """
        Generate a vulnerability report.

        Args:
            results: Scan results to include
            format: Report format (json, sarif, html)

        Returns:
            Report as string
        """
        if format == "json":
            return json.dumps(
                {"results": [r.dict() for r in results]},
                indent=2,
                default=str
            )

        elif format == "sarif":
            return self._generate_sarif_report(results)

        elif format == "html":
            return self._generate_html_report(results)

        else:
            raise ValueError(f"Unsupported format: {format}")

    def _generate_sarif_report(self, results: List[ScanResult]) -> str:
        """Generate SARIF format report."""
        sarif = {
            "$schema": "https://raw.githubusercontent.com/oasis-tcs/sarif-spec/master/Schemata/sarif-schema-2.1.0.json",
            "version": "2.1.0",
            "runs": []
        }

        for result in results:
            run = {
                "tool": {
                    "driver": {
                        "name": "GreenLang Vulnerability Scanner",
                        "version": "1.0.0",
                        "rules": []
                    }
                },
                "results": []
            }

            for vuln in result.vulnerabilities:
                run["results"].append({
                    "ruleId": vuln.cve.cve_id if vuln.cve else vuln.vulnerability_id,
                    "level": self._severity_to_sarif_level(vuln.severity),
                    "message": {"text": vuln.description},
                    "locations": [{
                        "physicalLocation": {
                            "artifactLocation": {"uri": vuln.affected_file or result.target},
                            "region": {"startLine": vuln.affected_line or 1}
                        }
                    }]
                })

            sarif["runs"].append(run)

        return json.dumps(sarif, indent=2)

    def _severity_to_sarif_level(self, severity: VulnerabilitySeverity) -> str:
        """Convert severity to SARIF level."""
        return {
            VulnerabilitySeverity.CRITICAL: "error",
            VulnerabilitySeverity.HIGH: "error",
            VulnerabilitySeverity.MEDIUM: "warning",
            VulnerabilitySeverity.LOW: "note",
            VulnerabilitySeverity.INFO: "note"
        }.get(severity, "none")

    def _generate_html_report(self, results: List[ScanResult]) -> str:
        """Generate HTML format report."""
        html = ["<html><head><title>Vulnerability Report</title></head><body>"]
        html.append("<h1>Vulnerability Scan Report</h1>")

        for result in results:
            html.append(f"<h2>Scan: {result.target}</h2>")
            html.append(f"<p>Status: {result.status.value}</p>")
            html.append(f"<p>Total vulnerabilities: {result.total_vulnerabilities}</p>")

            if result.vulnerabilities:
                html.append("<table border='1'><tr>")
                html.append("<th>Severity</th><th>Title</th><th>Description</th><th>Remediation</th>")
                html.append("</tr>")

                for vuln in result.vulnerabilities:
                    remediation = vuln.remediation.recommendation if vuln.remediation else "N/A"
                    html.append(f"<tr><td>{vuln.severity.value}</td>")
                    html.append(f"<td>{vuln.title}</td>")
                    html.append(f"<td>{vuln.description}</td>")
                    html.append(f"<td>{remediation}</td></tr>")

                html.append("</table>")

        html.append("</body></html>")
        return "".join(html)

    def get_scan_history(
        self,
        limit: int = 100,
        scan_type: Optional[ScanType] = None
    ) -> List[ScanResult]:
        """Get scan history."""
        history = self._scan_history

        if scan_type:
            history = [r for r in history if r.scan_type == scan_type]

        history.sort(key=lambda r: r.started_at or datetime.min, reverse=True)
        return history[:limit]

    def get_metrics(self) -> Dict[str, Any]:
        """Get scanner metrics."""
        total_vulns = sum(r.total_vulnerabilities for r in self._scan_history)
        critical = sum(r.critical_count for r in self._scan_history)
        high = sum(r.high_count for r in self._scan_history)

        return {
            "total_scans": len(self._scan_history),
            "total_vulnerabilities_found": total_vulns,
            "critical_vulnerabilities": critical,
            "high_vulnerabilities": high,
            "running": self._running
        }

    async def health_check(self) -> Dict[str, Any]:
        """Check scanner health."""
        return {
            "healthy": self._running,
            "running": self._running,
            "scanners_available": len(self._scanners),
            "metrics": self.get_metrics()
        }


# =============================================================================
# FastAPI Router
# =============================================================================


def create_scanner_router(scanner: VulnerabilityScanner):
    """
    Create FastAPI router for vulnerability scanning.

    Args:
        scanner: VulnerabilityScanner instance

    Returns:
        FastAPI APIRouter
    """
    try:
        from fastapi import APIRouter, HTTPException, Query, status
        from fastapi.responses import HTMLResponse, PlainTextResponse
    except ImportError:
        logger.warning("FastAPI not available, skipping router creation")
        return None

    router = APIRouter(prefix="/api/v1/security/scan", tags=["Vulnerability Scanning"])

    @router.post("/dependencies")
    async def scan_dependencies(path: str = Query(...)):
        """Scan project dependencies."""
        result = await scanner.scan_dependencies(path)
        return result.dict()

    @router.post("/code")
    async def scan_code(path: str = Query(...)):
        """Scan code for security patterns."""
        result = await scanner.scan_code(path)
        return result.dict()

    @router.post("/container")
    async def scan_container(image: str = Query(...)):
        """Scan container image."""
        result = await scanner.scan_container(image)
        return result.dict()

    @router.get("/history")
    async def get_scan_history(
        limit: int = Query(100, le=1000),
        scan_type: Optional[str] = Query(None)
    ):
        """Get scan history."""
        type_enum = ScanType(scan_type) if scan_type else None
        history = scanner.get_scan_history(limit, type_enum)
        return {"results": [r.dict() for r in history]}

    @router.get("/report")
    async def generate_report(
        scan_ids: List[str] = Query(...),
        format: str = Query("json")
    ):
        """Generate vulnerability report."""
        # Find scans by ID
        results = [
            r for r in scanner._scan_history
            if r.scan_id in scan_ids
        ]

        if not results:
            raise HTTPException(status_code=404, detail="No matching scans found")

        report = await scanner.generate_report(results, format)

        if format == "html":
            return HTMLResponse(content=report)
        return PlainTextResponse(content=report)

    @router.get("/metrics")
    async def get_metrics():
        """Get scanner metrics."""
        return scanner.get_metrics()

    @router.get("/health")
    async def health_check():
        """Check scanner health."""
        return await scanner.health_check()

    return router
