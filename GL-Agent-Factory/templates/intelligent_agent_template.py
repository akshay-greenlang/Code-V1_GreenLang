# -*- coding: utf-8 -*-
"""
{{ AGENT_NAME }} - AI-Native Intelligent Agent

GENERATED BY: GL-Agent-Factory
DATE: {{ GENERATION_DATE }}
TEMPLATE: intelligent_agent_template.py v1.0

This agent is generated with MANDATORY LLM intelligence capabilities.
All agents from the GL-Agent-Factory MUST implement the IntelligentAgent
interface and provide AI-powered explanations and recommendations.

Intelligence Level: {{ INTELLIGENCE_LEVEL }}
Regulatory Context: {{ REGULATORY_CONTEXT }}

CAPABILITIES:
- generate_explanation(): Explain calculation results in natural language
- generate_recommendations(): Provide actionable recommendations
{% if ENABLE_ANOMALY_DETECTION %}
- detect_anomalies(): Detect unusual patterns in data
{% endif %}
{% if ENABLE_REASONING %}
- reason_about(): General-purpose LLM reasoning
{% endif %}

Usage:
    from {{ MODULE_PATH }} import {{ AGENT_CLASS_NAME }}

    config = {{ AGENT_CLASS_NAME }}Config(
        name="{{ AGENT_NAME }}",
        description="{{ AGENT_DESCRIPTION }}",
        intelligence_level=IntelligenceLevel.{{ INTELLIGENCE_LEVEL }},
        regulatory_context="{{ REGULATORY_CONTEXT }}"
    )

    agent = {{ AGENT_CLASS_NAME }}(config)
    result = agent.run(input_data)

    # The result now includes AI-generated content:
    # - result.data["explanation"] - Natural language explanation
    # - result.data["recommendations"] - Actionable recommendations
"""

from __future__ import annotations
import logging
from typing import Any, Dict, List, Optional
from pydantic import Field

from greenlang.agents import (
    IntelligentAgentBase,
    IntelligentAgentConfig,
    IntelligenceLevel,
    IntelligenceCapabilities,
    Recommendation,
    Anomaly,
    require_intelligence,
)
from greenlang.agents.base import AgentResult
from greenlang.determinism import DeterministicClock

logger = logging.getLogger(__name__)


# =============================================================================
# CONFIGURATION
# =============================================================================

class {{ AGENT_CLASS_NAME }}Config(IntelligentAgentConfig):
    """Configuration for {{ AGENT_NAME }}."""

    # Agent-specific parameters
    # {{ CUSTOM_CONFIG_FIELDS }}

    class Config:
        """Pydantic configuration."""
        extra = "allow"  # Allow additional fields


# =============================================================================
# AGENT IMPLEMENTATION
# =============================================================================

@require_intelligence  # MANDATORY: Validates intelligence requirements at class definition
class {{ AGENT_CLASS_NAME }}(IntelligentAgentBase):
    """
    {{ AGENT_DESCRIPTION }}

    This is an AI-native intelligent agent that provides:
    1. DETERMINISTIC CALCULATIONS - Zero-hallucination numerical results
    2. AI-POWERED EXPLANATIONS - Natural language explanations of results
    3. AI-POWERED RECOMMENDATIONS - Actionable suggestions for improvement

    The calculations are separated from intelligence:
    - _calculate_*() methods: Deterministic, reproducible, auditable
    - generate_*() methods: AI-powered, contextual, insightful

    Regulatory Context: {{ REGULATORY_CONTEXT }}
    Intelligence Level: {{ INTELLIGENCE_LEVEL }}
    """

    def __init__(self, config: Optional[{{ AGENT_CLASS_NAME }}Config] = None):
        """Initialize the intelligent agent."""
        if config is None:
            config = {{ AGENT_CLASS_NAME }}Config(
                name="{{ AGENT_NAME }}",
                description="{{ AGENT_DESCRIPTION }}",
                intelligence_level=IntelligenceLevel.{{ INTELLIGENCE_LEVEL }},
                regulatory_context="{{ REGULATORY_CONTEXT }}"
            )
        super().__init__(config)
        self.agent_config = config

        logger.info(f"Initialized {{ AGENT_NAME }} with intelligence level: {config.intelligence_level.value}")

    # =========================================================================
    # MANDATORY: Intelligence Interface Implementation
    # =========================================================================

    def get_intelligence_level(self) -> IntelligenceLevel:
        """Return the agent's intelligence level."""
        return self.intelligent_config.intelligence_level

    def get_intelligence_capabilities(self) -> IntelligenceCapabilities:
        """Return the agent's intelligence capabilities."""
        return IntelligenceCapabilities(
            can_explain=True,  # MANDATORY for all agents
            can_recommend={{ ENABLE_RECOMMENDATIONS }},
            can_detect_anomalies={{ ENABLE_ANOMALY_DETECTION }},
            can_reason={{ ENABLE_REASONING }},
            can_validate=True,
            uses_rag={{ ENABLE_RAG }},
            uses_tools=False
        )

    # =========================================================================
    # CORE EXECUTION
    # =========================================================================

    def execute(self, input_data: Dict[str, Any]) -> AgentResult:
        """
        Execute the agent with deterministic calculation + AI intelligence.

        This method:
        1. Validates input (with optional AI reasoning)
        2. Performs DETERMINISTIC calculations (zero-hallucination)
        3. Generates AI explanations and recommendations
        4. Returns result with both data and intelligence

        Args:
            input_data: Input data for the calculation

        Returns:
            AgentResult with calculation results and AI-generated content
        """
        logger.info(f"Executing {{ AGENT_NAME }}")

        # Step 1: Validate input
        if not self.validate_input(input_data):
            return AgentResult(
                success=False,
                error="Input validation failed",
                timestamp=DeterministicClock.now()
            )

        # Step 2: DETERMINISTIC CALCULATION (Zero-hallucination)
        # This is where all numerical work happens - NO LLM involved
        calculation_result = self._perform_calculation(input_data)

        # Track calculation steps for explainability
        calculation_steps = self._get_calculation_steps(input_data, calculation_result)

        # Step 3: AI-POWERED EXPLANATION
        # This is what makes the agent "intelligent"
        explanation = self.generate_explanation(
            input_data=input_data,
            output_data=calculation_result,
            calculation_steps=calculation_steps
        )

        # Step 4: AI-POWERED RECOMMENDATIONS (if enabled)
        recommendations = []
        if self.intelligent_config.enable_recommendations:
            recommendations = self.generate_recommendations(
                analysis=calculation_result,
                max_recommendations=5,
                focus_areas=self._get_recommendation_focus_areas(calculation_result)
            )

        # Step 5: ANOMALY DETECTION (if enabled)
        anomalies = []
        if self.intelligent_config.enable_anomaly_detection:
            anomalies = self.detect_anomalies(
                data=input_data,
                expected_ranges=self._get_expected_ranges()
            )

        # Build result with both deterministic data and AI intelligence
        result_data = {
            **calculation_result,
            "explanation": explanation,
            "recommendations": [r.dict() if hasattr(r, 'dict') else r for r in recommendations],
            "anomalies": [a.dict() if hasattr(a, 'dict') else a for a in anomalies],
            "intelligence_level": self.get_intelligence_level().value,
        }

        return AgentResult(
            success=True,
            data=result_data,
            metadata={
                "agent": "{{ AGENT_NAME }}",
                "intelligence_metrics": self.get_intelligence_metrics().dict(),
                "regulatory_context": self.intelligent_config.regulatory_context
            },
            timestamp=DeterministicClock.now()
        )

    # =========================================================================
    # DETERMINISTIC CALCULATION METHODS
    # These methods contain ZERO LLM calls - all calculations are reproducible
    # =========================================================================

    def _perform_calculation(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Perform the core deterministic calculation.

        IMPORTANT: This method must be 100% deterministic.
        - No LLM calls
        - No randomness (unless seeded)
        - Fully reproducible

        Args:
            input_data: Validated input data

        Returns:
            Calculation results (all numbers must be deterministic)
        """
        # {{ CALCULATION_IMPLEMENTATION }}
        # TODO: Implement your deterministic calculation here

        # Example placeholder - replace with actual calculation
        result = {
            "calculated_value": 0.0,
            "unit": "unit",
            "source": "{{ DATA_SOURCE }}",
            "methodology": "{{ CALCULATION_METHODOLOGY }}"
        }

        return result

    def _get_calculation_steps(
        self,
        input_data: Dict[str, Any],
        result: Dict[str, Any]
    ) -> List[str]:
        """
        Document the calculation steps for explainability.

        These steps are shown to the LLM to generate better explanations.
        They also serve as an audit trail.

        Args:
            input_data: The input data
            result: The calculation result

        Returns:
            List of calculation steps as strings
        """
        steps = [
            # {{ CALCULATION_STEPS }}
            # TODO: Document your calculation steps
            "Step 1: Retrieved relevant data",
            "Step 2: Applied calculation methodology",
            "Step 3: Computed result"
        ]

        return steps

    def _get_recommendation_focus_areas(
        self,
        result: Dict[str, Any]
    ) -> List[str]:
        """
        Determine focus areas for recommendations based on results.

        Args:
            result: Calculation results

        Returns:
            List of focus areas (e.g., ["efficiency", "compliance"])
        """
        focus_areas = ["efficiency", "compliance"]

        # {{ RECOMMENDATION_FOCUS_LOGIC }}
        # TODO: Add logic to determine focus areas based on results

        return focus_areas

    def _get_expected_ranges(self) -> Dict[str, tuple]:
        """
        Define expected ranges for anomaly detection.

        Returns:
            Dict mapping field names to (min, max) tuples
        """
        return {
            # {{ EXPECTED_RANGES }}
            # TODO: Define expected ranges for your data fields
            # "field_name": (min_value, max_value),
        }

    def validate_input(self, input_data: Dict[str, Any]) -> bool:
        """
        Validate input data.

        Override to add domain-specific validation.

        Args:
            input_data: Input data to validate

        Returns:
            True if valid, False otherwise
        """
        # {{ INPUT_VALIDATION }}
        # TODO: Add your validation logic

        required_fields = []  # Add required fields
        for field in required_fields:
            if field not in input_data:
                logger.error(f"Missing required field: {field}")
                return False

        return True


# =============================================================================
# FACTORY FUNCTION
# =============================================================================

def create_{{ AGENT_NAME_SNAKE }}(
    intelligence_level: IntelligenceLevel = IntelligenceLevel.{{ INTELLIGENCE_LEVEL }},
    regulatory_context: str = "{{ REGULATORY_CONTEXT }}",
    **kwargs
) -> {{ AGENT_CLASS_NAME }}:
    """
    Factory function to create {{ AGENT_NAME }}.

    Args:
        intelligence_level: Level of LLM intelligence
        regulatory_context: Regulatory context for prompts
        **kwargs: Additional configuration parameters

    Returns:
        Configured {{ AGENT_CLASS_NAME }} instance
    """
    config = {{ AGENT_CLASS_NAME }}Config(
        name="{{ AGENT_NAME }}",
        description="{{ AGENT_DESCRIPTION }}",
        intelligence_level=intelligence_level,
        regulatory_context=regulatory_context,
        **kwargs
    )

    return {{ AGENT_CLASS_NAME }}(config)


# =============================================================================
# EXAMPLE USAGE
# =============================================================================

if __name__ == "__main__":
    """Example usage of {{ AGENT_NAME }}."""

    # Create agent
    agent = create_{{ AGENT_NAME_SNAKE }}()

    # Example input
    example_input = {
        # {{ EXAMPLE_INPUT }}
        # TODO: Add example input data
    }

    # Run agent
    result = agent.run(example_input)

    # Print results
    print(f"Success: {result.success}")
    print(f"Data: {result.data}")
    print(f"Explanation: {result.data.get('explanation', 'N/A')}")
    print(f"Recommendations: {result.data.get('recommendations', [])}")
    print(f"Intelligence Metrics: {agent.get_intelligence_metrics()}")
