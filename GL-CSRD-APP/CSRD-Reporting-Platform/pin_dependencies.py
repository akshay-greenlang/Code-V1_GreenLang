"""
Dependency Pinning and Security Audit Script
============================================

Generates fully pinned requirements with SHA256 hashes for maximum security
and reproducibility.

Author: GreenLang Security Team
Date: 2025-10-20
"""

import hashlib
import json
import subprocess
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, List, Tuple
import re


class DependencyPinner:
    """Pin dependencies and generate security audit report."""

    def __init__(self, requirements_file: str = "requirements.txt"):
        self.requirements_file = Path(requirements_file)
        self.output_file = Path("requirements-pinned-hashed.txt")
        self.audit_file = Path("dependency-audit-report.json")
        self.project_root = Path(__file__).parent

    def install_tools(self) -> bool:
        """Install required tools for dependency pinning."""
        print("Installing dependency management tools...")
        try:
            subprocess.run(
                [sys.executable, "-m", "pip", "install", "--upgrade",
                 "pip-tools", "pip-audit", "safety"],
                check=True,
                capture_output=True
            )
            print("✓ Tools installed successfully")
            return True
        except subprocess.CalledProcessError as e:
            print(f"❌ Failed to install tools: {e}")
            return False

    def generate_pinned_requirements(self) -> bool:
        """Generate requirements with exact versions and SHA256 hashes."""
        print(f"\nGenerating pinned requirements from {self.requirements_file}...")

        try:
            # Use pip-compile to generate pinned requirements with hashes
            cmd = [
                "pip-compile",
                "--generate-hashes",
                "--allow-unsafe",
                "--resolver=backtracking",
                "--output-file", str(self.output_file),
                str(self.requirements_file)
            ]

            print(f"Running: {' '.join(cmd)}")

            result = subprocess.run(
                cmd,
                check=True,
                capture_output=True,
                text=True,
                cwd=self.project_root
            )

            print("✓ Pinned requirements generated successfully")
            print(f"  Output: {self.output_file}")

            # Add security header
            self._add_security_header()

            return True

        except subprocess.CalledProcessError as e:
            print(f"❌ Failed to generate pinned requirements: {e}")
            if e.stdout:
                print(f"STDOUT: {e.stdout}")
            if e.stderr:
                print(f"STDERR: {e.stderr}")
            return False
        except FileNotFoundError:
            print("❌ pip-compile not found. Install pip-tools first.")
            return False

    def _add_security_header(self) -> None:
        """Add security audit information to pinned requirements."""
        if not self.output_file.exists():
            return

        header = f"""# ============================================================================
# CSRD REPORTING PLATFORM - SECURITY-PINNED DEPENDENCIES
# ============================================================================
#
# GENERATED: {datetime.now().isoformat()}
# SECURITY: All dependencies pinned with SHA256 hashes
#
# This file was automatically generated by pin_dependencies.py
# DO NOT EDIT MANUALLY - Regenerate using: python pin_dependencies.py
#
# SECURITY GUARANTEE:
# - Exact version pinning prevents supply chain attacks
# - SHA256 hashes ensure package integrity
# - Reproducible builds for compliance and auditing
#
# To install: pip install -r requirements-pinned-hashed.txt
#
# ============================================================================

"""

        # Read current content
        with open(self.output_file, 'r') as f:
            content = f.read()

        # Write header + content
        with open(self.output_file, 'w') as f:
            f.write(header + content)

        print("✓ Security header added")

    def audit_dependencies(self) -> Dict:
        """Run security audit on dependencies."""
        print("\nRunning security audit on dependencies...")

        audit_results = {
            "timestamp": datetime.now().isoformat(),
            "project": "CSRD-Reporting-Platform",
            "audits": {}
        }

        # Run pip-audit
        print("  Running pip-audit...")
        pip_audit_result = self._run_pip_audit()
        audit_results["audits"]["pip_audit"] = pip_audit_result

        # Run safety check
        print("  Running safety check...")
        safety_result = self._run_safety_check()
        audit_results["audits"]["safety"] = safety_result

        # Generate summary
        audit_results["summary"] = self._generate_audit_summary(audit_results)

        # Save audit report
        with open(self.audit_file, 'w') as f:
            json.dump(audit_results, f, indent=2)

        print(f"✓ Audit complete - Report saved to {self.audit_file}")

        return audit_results

    def _run_pip_audit(self) -> Dict:
        """Run pip-audit to check for vulnerabilities."""
        try:
            result = subprocess.run(
                ["pip-audit", "--format=json", "-r", str(self.requirements_file)],
                capture_output=True,
                text=True,
                timeout=300
            )

            if result.returncode == 0:
                audit_data = json.loads(result.stdout) if result.stdout else {}
                return {
                    "status": "completed",
                    "vulnerabilities": audit_data.get("vulnerabilities", []),
                    "total": len(audit_data.get("vulnerabilities", []))
                }
            else:
                return {
                    "status": "completed_with_findings",
                    "output": result.stdout,
                    "errors": result.stderr
                }

        except subprocess.CalledProcessError as e:
            return {
                "status": "error",
                "message": str(e)
            }
        except FileNotFoundError:
            return {
                "status": "not_installed",
                "message": "pip-audit not found"
            }
        except Exception as e:
            return {
                "status": "error",
                "message": str(e)
            }

    def _run_safety_check(self) -> Dict:
        """Run Safety to check for known vulnerabilities."""
        try:
            result = subprocess.run(
                ["safety", "check", "--file", str(self.requirements_file),
                 "--json", "--continue-on-error"],
                capture_output=True,
                text=True,
                timeout=300
            )

            if result.stdout:
                safety_data = json.loads(result.stdout)
                vulnerabilities = safety_data if isinstance(safety_data, list) else []

                return {
                    "status": "completed",
                    "vulnerabilities": vulnerabilities,
                    "total": len(vulnerabilities)
                }
            else:
                return {
                    "status": "completed",
                    "vulnerabilities": [],
                    "total": 0
                }

        except subprocess.CalledProcessError as e:
            return {
                "status": "error",
                "message": str(e),
                "output": e.stdout if hasattr(e, 'stdout') else None
            }
        except FileNotFoundError:
            return {
                "status": "not_installed",
                "message": "safety not found"
            }
        except Exception as e:
            return {
                "status": "error",
                "message": str(e)
            }

    def _generate_audit_summary(self, audit_results: Dict) -> Dict:
        """Generate summary of audit results."""
        total_vulns = 0
        critical = 0
        high = 0
        medium = 0
        low = 0

        # Count vulnerabilities from pip-audit
        pip_audit = audit_results["audits"].get("pip_audit", {})
        if pip_audit.get("status") == "completed":
            for vuln in pip_audit.get("vulnerabilities", []):
                total_vulns += 1
                severity = vuln.get("severity", "").lower()
                if "critical" in severity:
                    critical += 1
                elif "high" in severity:
                    high += 1
                elif "medium" in severity:
                    medium += 1
                else:
                    low += 1

        # Count vulnerabilities from safety
        safety = audit_results["audits"].get("safety", {})
        if safety.get("status") == "completed":
            for vuln in safety.get("vulnerabilities", []):
                total_vulns += 1
                severity = vuln.get("severity", "").lower()
                if "critical" in severity:
                    critical += 1
                elif "high" in severity:
                    high += 1
                elif "medium" in severity:
                    medium += 1
                else:
                    low += 1

        return {
            "total_vulnerabilities": total_vulns,
            "critical": critical,
            "high": high,
            "medium": medium,
            "low": low,
            "status": "FAIL" if (critical > 0 or high > 0) else "PASS"
        }

    def print_summary(self, audit_results: Dict) -> None:
        """Print audit summary to console."""
        print("\n" + "="*80)
        print("DEPENDENCY SECURITY AUDIT SUMMARY")
        print("="*80)

        summary = audit_results.get("summary", {})

        print(f"\n📊 Vulnerability Summary:")
        print(f"  Total: {summary.get('total_vulnerabilities', 0)}")
        print(f"  CRITICAL: {summary.get('critical', 0)}")
        print(f"  HIGH: {summary.get('high', 0)}")
        print(f"  MEDIUM: {summary.get('medium', 0)}")
        print(f"  LOW: {summary.get('low', 0)}")

        print(f"\n  Overall Status: {summary.get('status', 'UNKNOWN')}")

        if summary.get('status') == 'PASS':
            print("\n✅ All dependency security checks passed!")
        else:
            print("\n⚠️  Security vulnerabilities found - review audit report")

        print(f"\n📄 Detailed audit report: {self.audit_file}")
        print("="*80)

    def verify_hashes(self) -> bool:
        """Verify that all packages have SHA256 hashes."""
        print(f"\nVerifying hashes in {self.output_file}...")

        if not self.output_file.exists():
            print(f"❌ File not found: {self.output_file}")
            return False

        with open(self.output_file, 'r') as f:
            content = f.read()

        # Count packages and hashes
        packages = re.findall(r'^[\w\-]+==', content, re.MULTILINE)
        hashes = re.findall(r'--hash=sha256:', content, re.MULTILINE)

        print(f"  Packages: {len(packages)}")
        print(f"  SHA256 hashes: {len(hashes)}")

        if len(hashes) > 0:
            print(f"✓ Hashes verified - {len(hashes)} SHA256 hashes found")
            return True
        else:
            print("⚠️  No hashes found - consider regenerating with --generate-hashes")
            return False

    def run(self) -> bool:
        """Run complete dependency pinning and audit workflow."""
        print("="*80)
        print("DEPENDENCY PINNING AND SECURITY AUDIT")
        print("="*80)
        print(f"Project: CSRD Reporting Platform")
        print(f"Requirements: {self.requirements_file}")
        print("="*80)

        # Step 1: Install tools
        if not self.install_tools():
            print("\n❌ Failed to install required tools")
            return False

        # Step 2: Generate pinned requirements
        if not self.generate_pinned_requirements():
            print("\n❌ Failed to generate pinned requirements")
            return False

        # Step 3: Verify hashes
        self.verify_hashes()

        # Step 4: Run security audit
        audit_results = self.audit_dependencies()

        # Step 5: Print summary
        self.print_summary(audit_results)

        # Determine success
        summary = audit_results.get("summary", {})
        if summary.get("status") == "PASS":
            print("\n✅ DEPENDENCY PINNING AND AUDIT COMPLETE - ALL CHECKS PASSED")
            return True
        else:
            print("\n⚠️  DEPENDENCY PINNING COMPLETE - SECURITY ISSUES FOUND")
            print("    Review the audit report and address vulnerabilities")
            return False


def main():
    """Main entry point."""
    pinner = DependencyPinner()
    success = pinner.run()
    sys.exit(0 if success else 1)


if __name__ == "__main__":
    main()
