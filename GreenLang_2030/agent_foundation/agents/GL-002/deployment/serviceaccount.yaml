# GL-002 BoilerEfficiencyOptimizer - ServiceAccount & RBAC
# Implements least privilege access for GL-002 pods
# Grants only necessary permissions to Kubernetes API

---
# ServiceAccount for GL-002 pods
apiVersion: v1
kind: ServiceAccount
metadata:
  name: gl-002-boiler-efficiency
  namespace: greenlang
  labels:
    app: gl-002-boiler-efficiency
    agent: "GL-002"
    version: "1.0.0"
  annotations:
    description: "ServiceAccount for GL-002 BoilerEfficiencyOptimizer"
    documentation: "https://kubernetes.io/docs/tasks/configure-pod-container/configure-service-account/"

# Disable automatic token mounting (security best practice)
# Pods should explicitly mount tokens only if needed
automountServiceAccountToken: false

---
# Role - Namespace-scoped permissions for GL-002
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: gl-002-boiler-efficiency-role
  namespace: greenlang
  labels:
    app: gl-002-boiler-efficiency
    agent: "GL-002"

rules:
  # Read access to ConfigMaps (for runtime configuration)
  - apiGroups: [""]
    resources: ["configmaps"]
    verbs: ["get", "list", "watch"]
    resourceNames: ["gl-002-config", "gl-002-config-staging"]

  # Read access to Secrets (for credentials)
  - apiGroups: [""]
    resources: ["secrets"]
    verbs: ["get", "list"]
    resourceNames: ["gl-002-secrets"]

  # Read access to own Service endpoints
  - apiGroups: [""]
    resources: ["endpoints", "services"]
    verbs: ["get", "list", "watch"]
    resourceNames: ["gl-002-boiler-efficiency", "gl-002-metrics"]

  # Pod self-inspection (for health checks, metrics)
  - apiGroups: [""]
    resources: ["pods"]
    verbs: ["get", "list"]

  # Events creation (for logging important events)
  - apiGroups: [""]
    resources: ["events"]
    verbs: ["create", "patch"]

  # Read access to own Deployment (for version checking)
  - apiGroups: ["apps"]
    resources: ["deployments"]
    verbs: ["get", "list"]
    resourceNames: ["gl-002-boiler-efficiency"]

  # Read access to HPA (for scaling awareness)
  - apiGroups: ["autoscaling"]
    resources: ["horizontalpodautoscalers"]
    verbs: ["get", "list"]
    resourceNames: ["gl-002-boiler-efficiency-hpa"]

---
# RoleBinding - Bind Role to ServiceAccount
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: gl-002-boiler-efficiency-rolebinding
  namespace: greenlang
  labels:
    app: gl-002-boiler-efficiency
    agent: "GL-002"

subjects:
  - kind: ServiceAccount
    name: gl-002-boiler-efficiency
    namespace: greenlang

roleRef:
  kind: Role
  name: gl-002-boiler-efficiency-role
  apiGroup: rbac.authorization.k8s.io

---
# ClusterRole - Cluster-wide read-only permissions (if needed)
# Only create this if GL-002 needs cluster-level visibility
# For most applications, Role + RoleBinding is sufficient

apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: gl-002-boiler-efficiency-cluster-role
  labels:
    app: gl-002-boiler-efficiency
    agent: "GL-002"

rules:
  # Read-only access to Nodes (for node affinity decisions)
  - apiGroups: [""]
    resources: ["nodes"]
    verbs: ["get", "list", "watch"]

  # Read-only access to Namespaces
  - apiGroups: [""]
    resources: ["namespaces"]
    verbs: ["get", "list", "watch"]

  # Read-only access to StorageClasses (if using PVCs)
  - apiGroups: ["storage.k8s.io"]
    resources: ["storageclasses"]
    verbs: ["get", "list", "watch"]

---
# ClusterRoleBinding - Bind ClusterRole to ServiceAccount
# WARNING: Only enable if GL-002 requires cluster-level permissions
# Comment out if not needed (default: commented out for security)

# apiVersion: rbac.authorization.k8s.io/v1
# kind: ClusterRoleBinding
# metadata:
#   name: gl-002-boiler-efficiency-cluster-rolebinding
#   labels:
#     app: gl-002-boiler-efficiency
#     agent: "GL-002"
#
# subjects:
#   - kind: ServiceAccount
#     name: gl-002-boiler-efficiency
#     namespace: greenlang
#
# roleRef:
#   kind: ClusterRole
#   name: gl-002-boiler-efficiency-cluster-role
#   apiGroup: rbac.authorization.k8s.io

---
# Additional RBAC best practices:
#
# 1. **Least Privilege Principle**:
#    - Grant only minimum required permissions
#    - Use resourceNames to restrict access to specific resources
#    - Prefer Role over ClusterRole when possible
#
# 2. **Token Management**:
#    - Set automountServiceAccountToken: false by default
#    - Only mount tokens when API access is required
#    - Use projected volumes for token rotation (Kubernetes 1.20+)
#
# 3. **Security Auditing**:
#    - Review RBAC permissions quarterly
#    - Monitor ServiceAccount token usage
#    - Use audit logs to detect privilege escalation
#
# 4. **Testing RBAC**:
#    kubectl auth can-i get configmaps --as=system:serviceaccount:greenlang:gl-002-boiler-efficiency -n greenlang
#    kubectl auth can-i delete pods --as=system:serviceaccount:greenlang:gl-002-boiler-efficiency -n greenlang
#
# 5. **RBAC for Secrets Access**:
#    - Use External Secrets Operator or Sealed Secrets
#    - Avoid granting broad secrets/* access
#    - Use resourceNames to restrict to specific secrets
#
# 6. **Example: Projected ServiceAccount Token** (Kubernetes 1.20+):
#    volumes:
#      - name: service-account-token
#        projected:
#          sources:
#            - serviceAccountToken:
#                path: token
#                expirationSeconds: 3600
#                audience: api
#
# 7. **RBAC Debugging**:
#    kubectl get rolebinding -n greenlang
#    kubectl describe role gl-002-boiler-efficiency-role -n greenlang
#    kubectl describe rolebinding gl-002-boiler-efficiency-rolebinding -n greenlang
#
# 8. **Pod Security Standards** (PSS):
#    - Enforce Restricted PSS for production workloads
#    - GL-002 deployment already complies with Restricted PSS:
#      * runAsNonRoot: true
#      * allowPrivilegeEscalation: false
#      * readOnlyRootFilesystem: true
#      * capabilities dropped
