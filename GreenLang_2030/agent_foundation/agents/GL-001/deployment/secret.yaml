# GL-001 ProcessHeatOrchestrator - Secret Template
# ============================================================================
# WARNING: This file contains template placeholders ONLY
# NEVER commit actual secrets to version control
# ============================================================================
# Always use external secret management:
#   - HashiCorp Vault
#   - AWS Secrets Manager
#   - Azure Key Vault
#   - GCP Secret Manager
#   - Sealed Secrets
#   - External Secrets Operator
#
# Instructions:
#   1. Copy this file to a secure location OUTSIDE git repository
#   2. Replace ALL placeholder values with actual base64-encoded secrets
#   3. Apply with: kubectl create secret generic gl-001-secrets -n greenlang --from-literal=... etc.
#   OR use External Secrets Operator (recommended for production)
#
# Security Notice:
#   - All secrets MUST be base64-encoded
#   - Never print, log, or display actual secret values
#   - Rotate secrets regularly (minimum every 90 days)
#   - Use cryptographically secure random generation
#   - Monitor secret access and usage
# ============================================================================

apiVersion: v1
kind: Secret
metadata:
  name: gl-001-secrets
  namespace: greenlang
  labels:
    app: gl-001-process-heat
    agent: "GL-001"
    tier: "orchestration"
    criticality: "high"
  annotations:
    description: "Sensitive secrets for GL-001 ProcessHeatOrchestrator"
    warning: "NEVER COMMIT SECRETS TO GIT"
    rotation-policy: "90-days"
    last-rotated: "YYYY-MM-DD"  # Update when rotating secrets

# Data format: base64-encoded values
# To create: echo -n "actual_value" | base64
# To decode: echo "encoded_value" | base64 --decode
# Replace ALL REPLACE_* placeholders with actual base64-encoded secrets
type: Opaque
data:
  # ============================================================================
  # DATABASE CREDENTIALS
  # ============================================================================
  # PostgreSQL connection string
  # Format: postgresql://username:password@hostname:5432/database_name?sslmode=require
  # NOTE: Must be base64-encoded
  # Example generation: openssl rand -base64 32 | base64
  database_url: "UkVQTEFDRV9XSVRIX0JBU0U2NF9FTkNPREVEX0RBVEFCQVNFX1VSTAA="

  # Database credentials (alternative to connection string)
  database_host: "UkVQTEFDRV9XSVRIX0RBVEFCQVNFX0hPU1Q="
  database_port: "NTQzMg=="  # 5432 in base64
  database_name: "UkVQTEFDRV9XSVRIX0RBVEFCQVNFX05BTUU="
  database_username: "UkVQTEFDRV9XSVRIX0RBVEFCQVNFX1VTRVJOQU1FAA=="
  database_password: "UkVQTEFDRV9XSVRIX0RBVEFCQVNFX1BBU1NXT1JEAA=="

  # ============================================================================
  # REDIS CREDENTIALS
  # ============================================================================
  # Redis connection string
  # Format: redis://:[password]@hostname:6379/0?ssl=true
  redis_url: "UkVQTEFDRV9XSVRIX0JBU0U2NF9FTkNPREVEX1JFRElTX1VSTAA="

  # Redis credentials (alternative)
  redis_host: "UkVQTEFDRV9XSVRIX1JFRElTX0hPU1Q="
  redis_port: "NjM3OQ=="  # 6379 in base64
  redis_password: "UkVQTEFDRV9XSVRIX1JFRElTX1BBU1NXT1JEAA=="

  # ============================================================================
  # API AUTHENTICATION
  # ============================================================================
  # API key for external API access
  # Generation: openssl rand -hex 64 | base64
  api_key: "UkVQTEFDRV9XSVRIX0JBU0U2NF9FTkNPREVEX0FQSV9LRVkA"

  # JWT signing secret (HMAC-SHA256)
  # Generation: openssl rand -base64 64 | base64
  jwt_secret: "UkVQTEFDRV9XSVRIX0JBU0U2NF9FTkNPREVEX0pXVF9TRUNSRVQhA="

  # JWT refresh token secret
  jwt_refresh_secret: "UkVQTEFDRV9XSVRIX0JBU0U2NF9FTkNPREVEX0pXVF9SRUZSRVNIX1NFQ1JFVAA="

  # ============================================================================
  # OAUTH2 CREDENTIALS
  # ============================================================================
  # OAuth2 client credentials for ERP systems
  oauth_client_id: "UkVQTEFDRV9XSVRIX09BVVRIMl9DTElFTlRfSUQ="
  oauth_client_secret: "UkVQTEFDRV9XSVRIX09BVVRIMl9DTElFTlRfU0VDUkVUAA=="

  # ============================================================================
  # SCADA INTEGRATION CREDENTIALS
  # ============================================================================
  # OPC UA credentials
  scada_opcua_username: "UkVQTEFDRV9XSVRIX1NDQURBX09QQ1VBX1VTRVJOQU1FAA=="
  scada_opcua_password: "UkVQTEFDRV9XSVRIX1NDQURBX09QQ1VBX1BBU1NXT1JEAA=="

  # OPC UA certificate password (if using certificate authentication)
  scada_opcua_cert_password: "UkVQTEFDRV9XSVRIX1NDQURBX09QQ1VBX0NFUlRfUEFTU1dPUkQA"

  # Modbus TCP authentication (if applicable)
  scada_modbus_password: "UkVQTEFDRV9XSVRIX1NDQURBX01PREJVU19QQVNTV09SRAA="

  # MQTT broker credentials
  scada_mqtt_username: "UkVQTEFDRV9XSVRIX1NDQURBX01RVFRfVVNFUk5BTUU="
  scada_mqtt_password: "UkVQTEFDRV9XSVRIX1NDQURBX01RVFRfUEFTU1dPUkQ="

  # SCADA API key (if using REST API)
  scada_api_key: "UkVQTEFDRV9XSVRIX1NDQURBX0FQSV9LRVk="

  # ============================================================================
  # ERP SYSTEM CREDENTIALS
  # ============================================================================
  # SAP credentials
  erp_sap_username: "UkVQTEFDRV9XSVRIX0VSUF9TQVBfVVNFUk5BTUU="
  erp_sap_password: "UkVQTEFDRV9XSVRIX0VSUF9TQVBfUEFTU1dPUkQ="
  erp_sap_client_id: "UkVQTEFDRV9XSVRIX0VSUF9TQVBfQ0xJRU5UX0lE"
  erp_sap_client_secret: "UkVQTEFDRV9XSVRIX0VSUF9TQVBfQ0xJRU5UX1NFQ1JFVAA="

  # Oracle ERP credentials
  erp_oracle_username: "UkVQTEFDRV9XSVRIX0VSUF9PUkFDTEVfVVNFUk5BTUU="
  erp_oracle_password: "UkVQTEFDRV9XSVRIX0VSUF9PUkFDTEVfUEFTU1dPUkQ="

  # Microsoft Dynamics 365 credentials
  erp_dynamics_client_id: "UkVQTEFDRV9XSVRIX0VSUF9EWU5BTUlDU19DTElFTlRfSUQ="
  erp_dynamics_client_secret: "UkVQTEFDRV9XSVRIX0VSUF9EWU5BTUlDU19DTElFTlRfU0VDUkVUAA=="
  erp_dynamics_tenant_id: "UkVQTEFDRV9XSVRIX0VSUF9EWU5BTUlDU19URU5BTlRfSUQ="

  # Workday credentials
  erp_workday_username: "UkVQTEFDRV9XSVRIX0VSUF9XT1JLREFZX1VTRVJOQU1FAA=="
  erp_workday_password: "UkVQTEFDRV9XSVRIX0VSUF9XT1JLREFZX1BBU1NXT1JEAA=="
  erp_workday_api_key: "UkVQTEFDRV9XSVRIX0VSUF9XT1JLREFZX0FQSV9LRVk="

  # ============================================================================
  # MONITORING AND ALERTING CREDENTIALS
  # ============================================================================
  # Prometheus authentication (if required)
  prometheus_bearer_token: "UkVQTEFDRV9XSVRIX1BST01FVEhFVVNfQkVBUkVSX1RPS0VOAA=="

  # Grafana API key
  grafana_api_key: "UkVQTEFDRV9XSVRIX0dSQUZBTkFfQVBJX0tFWQ=="

  # Datadog API key (if using Datadog)
  datadog_api_key: "UkVQTEFDRV9XSVRIX0RBVEFET0dfQVBJX0tFWQ=="
  datadog_app_key: "UkVQTEFDRV9XSVRIX0RBVEFET0dfQVBQX0tFWQ=="

  # PagerDuty integration key
  pagerduty_integration_key: "UkVQTEFDRV9XSVRIX1BBR0VSRFVUWV9JTlRFR1JBVElPTl9LRVk="

  # Slack webhook URL for alerts
  slack_webhook_url: "UkVQTEFDRV9XSVRIX1NMQUNLX1dFQkhPT0tfVVJMQVNFNjRfRU5DT0RFRA=="

  # Email SMTP credentials for alerting
  smtp_username: "UkVQTEFDRV9XSVRIX1NNVFBfVVNFUk5BTUU="
  smtp_password: "UkVQTEFDRV9XSVRIX1NNVFBfUEFTU1dPUkQ="

  # ============================================================================
  # TLS/SSL CERTIFICATES
  # ============================================================================
  # TLS certificate for HTTPS (PEM format, base64-encoded)
  # NOTE: If using cert-manager, these are auto-generated
  # tls_cert: "UkVQTEFDRV9XSVRIX0JBU0U2NF9FTkNPREVEX1RMU19DRVJUSUZJQ0FURSA="
  # tls_key: "UkVQTEFDRV9XSVRIX0JBU0U2NF9FTkNPREVEX1RMU19QUklWQVRFX0tFWQA="

  # CA certificate for verification
  # ca_cert: "UkVQTEFDRV9XSVRIX0JBU0U2NF9FTkNPREVEX0NBX0NFUlQA"

  # ============================================================================
  # ENCRYPTION KEYS
  # ============================================================================
  # Data encryption key (AES-256)
  # Generation: openssl rand -base64 32 | base64
  data_encryption_key: "UkVQTEFDRV9XSVRIX0RBVEFfRU5DUllQVElPTl9LRVlfQkFTRTY0AA=="

  # Field-level encryption key
  field_encryption_key: "UkVQTEFDRV9XSVRIX0ZJRUxEX0VOQ1JZUFRJT05fS0VZX0JBU0U2NAA="

  # ============================================================================
  # AUDIT AND COMPLIANCE
  # ============================================================================
  # Audit log signing key (for tamper-proof logs)
  audit_signing_key: "UkVQTEFDRV9XSVRIX0FVRElUX1NJR05JTkdfS0VZX0JBU0U2NAA="

---
# ============================================================================
# RECOMMENDED: Use Sealed Secrets for GitOps-compatible secret management
# ============================================================================
# Install Sealed Secrets controller:
# kubectl apply -f https://github.com/bitnami-labs/sealed-secrets/releases/download/v0.24.0/controller.yaml
#
# Seal a secret:
# kubeseal -f secret.yaml -w secret-sealed.yaml --controller-namespace kube-system
#
# The sealed secret can be safely committed to git
# ============================================================================

---
# ============================================================================
# RECOMMENDED: Use External Secrets Operator for production
# ============================================================================
# Install External Secrets Operator:
# helm repo add external-secrets https://charts.external-secrets.io
# helm install external-secrets external-secrets/external-secrets \
#   -n external-secrets-system --create-namespace
#
# Example SecretStore for AWS Secrets Manager:
# ============================================================================

apiVersion: external-secrets.io/v1beta1
kind: SecretStore
metadata:
  name: gl-001-secret-store
  namespace: greenlang
spec:
  provider:
    aws:
      service: SecretsManager
      region: us-east-1
      auth:
        jwt:
          serviceAccountRef:
            name: gl-001-process-heat

---
# Example ExternalSecret for AWS Secrets Manager
apiVersion: external-secrets.io/v1beta1
kind: ExternalSecret
metadata:
  name: gl-001-secrets
  namespace: greenlang
  labels:
    app: gl-001-process-heat
    agent: "GL-001"
spec:
  refreshInterval: 1h
  secretStoreRef:
    name: gl-001-secret-store
    kind: SecretStore
  target:
    name: gl-001-secrets
    creationPolicy: Owner
    template:
      type: Opaque
      metadata:
        labels:
          app: gl-001-process-heat
          agent: "GL-001"
  data:
    # Database
    - secretKey: database_url
      remoteRef:
        key: gl-001/production/database_url
    - secretKey: redis_url
      remoteRef:
        key: gl-001/production/redis_url

    # API Authentication
    - secretKey: api_key
      remoteRef:
        key: gl-001/production/api_key
    - secretKey: jwt_secret
      remoteRef:
        key: gl-001/production/jwt_secret

    # SCADA
    - secretKey: scada_opcua_username
      remoteRef:
        key: gl-001/production/scada_opcua_username
    - secretKey: scada_opcua_password
      remoteRef:
        key: gl-001/production/scada_opcua_password

    # ERP
    - secretKey: erp_sap_client_id
      remoteRef:
        key: gl-001/production/erp_sap_client_id
    - secretKey: erp_sap_client_secret
      remoteRef:
        key: gl-001/production/erp_sap_client_secret

---
# ============================================================================
# DEPLOYMENT SCRIPT for manual secret creation
# Save as: deployment/setup-secrets.sh
# ============================================================================
# #!/bin/bash
# set -e
#
# ENVIRONMENT=${1:-production}
# NAMESPACE="greenlang"
#
# echo "Setting up secrets for GL-001 ProcessHeatOrchestrator"
# echo "Environment: ${ENVIRONMENT}"
#
# # Load secrets from secure vault (example: AWS Secrets Manager)
# # aws secretsmanager get-secret-value --secret-id gl-001/${ENVIRONMENT}/database_url --query SecretString --output text
#
# # For testing, you can source from a secure file:
# # source ~/.greenlang-secrets-${ENVIRONMENT}
#
# # Validate required secrets
# if [ -z "${DATABASE_URL}" ]; then
#   echo "ERROR: DATABASE_URL not set"
#   exit 1
# fi
#
# # Create Kubernetes secret
# kubectl create secret generic gl-001-secrets \
#   --from-literal=database_url="${DATABASE_URL}" \
#   --from-literal=redis_url="${REDIS_URL}" \
#   --from-literal=api_key="${API_KEY}" \
#   --from-literal=jwt_secret="${JWT_SECRET}" \
#   --from-literal=scada_opcua_username="${SCADA_OPCUA_USERNAME}" \
#   --from-literal=scada_opcua_password="${SCADA_OPCUA_PASSWORD}" \
#   --from-literal=erp_sap_client_id="${ERP_SAP_CLIENT_ID}" \
#   --from-literal=erp_sap_client_secret="${ERP_SAP_CLIENT_SECRET}" \
#   -n ${NAMESPACE} \
#   --dry-run=client \
#   -o yaml | kubectl apply -f -
#
# echo "Secrets created successfully"
#
# # Verify secret exists
# kubectl get secret gl-001-secrets -n ${NAMESPACE} -o jsonpath='{.metadata.name}' && echo " âœ“"
#
# ============================================================================
# SECRET ROTATION SCRIPT
# Save as: deployment/rotate-secrets.sh
# ============================================================================
# #!/bin/bash
# set -e
#
# ENVIRONMENT=${1:-production}
# NAMESPACE="greenlang"
#
# echo "Rotating secrets for GL-001 ProcessHeatOrchestrator"
# echo "Environment: ${ENVIRONMENT}"
#
# # Generate new secrets
# NEW_JWT_SECRET=$(openssl rand -base64 64)
# NEW_API_KEY=$(openssl rand -hex 64)
#
# # Update in secret manager
# # aws secretsmanager update-secret --secret-id gl-001/${ENVIRONMENT}/jwt_secret --secret-string "${NEW_JWT_SECRET}"
#
# # Trigger External Secrets refresh or update Kubernetes secret directly
# kubectl delete secret gl-001-secrets -n ${NAMESPACE}
# ./deployment/setup-secrets.sh ${ENVIRONMENT}
#
# # Rolling restart to pick up new secrets
# kubectl rollout restart deployment/gl-001-process-heat -n ${NAMESPACE}
#
# # Update rotation date annotation
# kubectl annotate secret gl-001-secrets last-rotated=$(date +%Y-%m-%d) -n ${NAMESPACE} --overwrite
#
# echo "Secret rotation complete"
# ============================================================================
