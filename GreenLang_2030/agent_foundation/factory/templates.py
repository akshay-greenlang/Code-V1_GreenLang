"""
Templates - Agent templates for rapid generation of different agent types.

This module provides comprehensive pre-defined templates for all GreenLang agent types,
enabling rapid generation of production-ready agents in <100ms.

Template Types:
- StatelessAgent: Functional agents without persistent state
- StatefulAgent: Agents with persistent state management
- ReactiveAgent: Event-driven response agents
- ProactiveAgent: Goal-driven planning agents
- HybridAgent: Combined reactive/proactive behaviors
- CalculatorAgent: Zero-hallucination calculation agents
- ComplianceAgent: Regulatory validation agents
- IntegratorAgent: External system integration agents
- ReporterAgent: Multi-format report generation agents
- CoordinatorAgent: Multi-agent orchestration

Example:
    >>> template = get_template("calculator")
    >>> code = template.generate_code("CarbonCalculator", spec)
    >>> print(f"Generated {len(code)} lines of code")
"""

import json
from abc import ABC, abstractmethod
from typing import Dict, List, Optional, Any
from pathlib import Path
from pydantic import BaseModel, Field

import logging

logger = logging.getLogger(__name__)


class AgentTemplate(BaseModel, ABC):
    """Base class for all agent templates."""

    name: str = Field(..., description="Template name")
    description: str = Field(..., description="Template description")
    version: str = Field("1.0.0", description="Template version")

    # Template components
    base_imports: List[str] = Field(default_factory=list, description="Required imports")
    base_classes: List[str] = Field(default_factory=list, description="Base classes to inherit")
    required_methods: List[str] = Field(default_factory=list, description="Methods to implement")
    optional_methods: List[str] = Field(default_factory=list, description="Optional methods")

    # Code patterns
    initialization_pattern: str = Field("", description="Initialization code pattern")
    processing_pattern: str = Field("", description="Main processing pattern")
    validation_pattern: str = Field("", description="Validation pattern")
    error_handling_pattern: str = Field("", description="Error handling pattern")

    # Configuration
    default_config: Dict[str, Any] = Field(default_factory=dict, description="Default configuration")
    supported_features: List[str] = Field(default_factory=list, description="Supported features")

    class Config:
        arbitrary_types_allowed = True

    @abstractmethod
    def generate_code(self, agent_name: str, spec: Dict[str, Any]) -> str:
        """Generate agent code from template."""
        pass

    @abstractmethod
    def generate_tests(self, agent_name: str, spec: Dict[str, Any]) -> str:
        """Generate test code from template."""
        pass

    def get_imports(self) -> str:
        """Get formatted import statements."""
        return "\n".join(self.base_imports)


class StatelessAgentTemplate(AgentTemplate):
    """Template for stateless functional agents."""

    def __init__(self):
        super().__init__(
            name="StatelessAgentTemplate",
            description="Template for stateless functional agents with zero persistence",
            base_imports=[
                "from typing import Dict, List, Optional, Any",
                "from pydantic import BaseModel, Field",
                "import logging",
                "from datetime import datetime",
                "",
                "from ..base_agent import BaseAgent, AgentConfig, ExecutionContext",
            ],
            base_classes=["BaseAgent"],
            required_methods=["_execute_core", "_initialize_core", "_terminate_core"],
            supported_features=["fast_execution", "no_state", "idempotent", "cacheable"]
        )

    def generate_code(self, agent_name: str, spec: Dict[str, Any]) -> str:
        """Generate stateless agent code."""
        return f'''"""
{agent_name} - Stateless functional agent.

This agent performs stateless operations with no persistent state.
Each execution is independent and idempotent.

Generated by GreenLang Agent Factory v1.0.0
"""

{self.get_imports()}

logger = logging.getLogger(__name__)


class {agent_name}Input(BaseModel):
    """Input model for {agent_name}."""

    {self._generate_input_fields(spec.get("input_schema", {}))}


class {agent_name}Output(BaseModel):
    """Output model for {agent_name}."""

    {self._generate_output_fields(spec.get("output_schema", {}))}
    execution_time_ms: float = Field(..., description="Execution duration")


class {agent_name}(BaseAgent):
    """
    {spec.get("description", "Stateless functional agent")}

    This is a stateless agent - no persistent state between executions.
    All operations are idempotent and cacheable.
    """

    async def _initialize_core(self) -> None:
        """Initialize agent resources."""
        logger.info(f"{{self.config.name}} initialized (stateless)")
        # No state to initialize
        pass

    async def _execute_core(self, input_data: Any, context: ExecutionContext) -> Any:
        """
        Execute stateless processing.

        Args:
            input_data: Input data to process
            context: Execution context

        Returns:
            Processed output
        """
        # Validate input
        validated_input = {agent_name}Input(**input_data)

        # Process (pure function - no side effects)
        result = self._process(validated_input)

        return result

    def _process(self, input_data: {agent_name}Input) -> {agent_name}Output:
        """
        Pure processing function with no side effects.

        This method should be deterministic and idempotent.
        """
        # Implementation
        output_data = {{
            # Add output fields
        }}

        return {agent_name}Output(
            **output_data,
            execution_time_ms=0.0  # Will be set by framework
        )

    async def _terminate_core(self) -> None:
        """Cleanup resources."""
        logger.info(f"{{self.config.name}} terminated")
        # No state to cleanup
        pass
'''

    def generate_tests(self, agent_name: str, spec: Dict[str, Any]) -> str:
        """Generate test code."""
        return f'''"""
Tests for {agent_name}.

Generated by GreenLang Agent Factory v1.0.0
"""

import pytest
from datetime import datetime

from ..{agent_name.lower()} import {agent_name}, {agent_name}Input
from ..base_agent import AgentConfig, ExecutionContext


class Test{agent_name}:
    """Test suite for {agent_name}."""

    @pytest.fixture
    async def agent(self):
        """Create test agent."""
        config = AgentConfig(name="{agent_name}")
        agent = {agent_name}(config)
        await agent.initialize()
        yield agent
        await agent.terminate()

    @pytest.mark.asyncio
    async def test_stateless_execution(self, agent):
        """Test stateless execution."""
        input_data = {agent_name}Input()

        # Execute twice
        result1 = await agent.execute(input_data)
        result2 = await agent.execute(input_data)

        # Results should be identical (idempotent)
        assert result1.success == result2.success
'''

    def _generate_input_fields(self, schema: Dict[str, Any]) -> str:
        """Generate input fields."""
        if not schema:
            return 'data: Dict[str, Any] = Field(default_factory=dict)'

        fields = []
        for name, type_def in schema.items():
            fields.append(f'{name}: {type_def} = Field(..., description="{name}")')
        return "\n    ".join(fields)

    def _generate_output_fields(self, schema: Dict[str, Any]) -> str:
        """Generate output fields."""
        if not schema:
            return 'result: Dict[str, Any] = Field(default_factory=dict)'

        fields = []
        for name, type_def in schema.items():
            fields.append(f'{name}: {type_def} = Field(..., description="{name}")')
        return "\n    ".join(fields)


class StatefulAgentTemplate(AgentTemplate):
    """Template for stateful agents with persistent state."""

    def __init__(self):
        super().__init__(
            name="StatefulAgentTemplate",
            description="Template for agents requiring persistent state management",
            base_imports=[
                "from typing import Dict, List, Optional, Any",
                "from pydantic import BaseModel, Field",
                "import logging",
                "from datetime import datetime",
                "import json",
                "from pathlib import Path",
                "",
                "from ..base_agent import BaseAgent, AgentConfig, ExecutionContext",
                "from ..memory import ShortTermMemory, LongTermMemory",
            ],
            base_classes=["BaseAgent"],
            required_methods=[
                "_execute_core", "_initialize_core", "_terminate_core",
                "_save_state", "_load_state", "_get_custom_state", "_restore_custom_state"
            ],
            supported_features=["persistent_state", "checkpointing", "recovery", "memory"]
        )

    def generate_code(self, agent_name: str, spec: Dict[str, Any]) -> str:
        """Generate stateful agent code."""
        return f'''"""
{agent_name} - Stateful agent with persistent state.

This agent maintains state across executions with automatic checkpointing.

Generated by GreenLang Agent Factory v1.0.0
"""

{self.get_imports()}

logger = logging.getLogger(__name__)


class {agent_name}State(BaseModel):
    """Persistent state for {agent_name}."""

    execution_count: int = Field(0, description="Number of executions")
    last_result: Optional[Dict[str, Any]] = Field(None, description="Last execution result")
    accumulated_data: Dict[str, Any] = Field(default_factory=dict, description="Accumulated state")
    timestamp: datetime = Field(default_factory=datetime.utcnow)


class {agent_name}(BaseAgent):
    """
    {spec.get("description", "Stateful agent with persistence")}

    Maintains state across executions with automatic checkpointing.
    """

    def __init__(self, config: AgentConfig):
        """Initialize stateful agent."""
        super().__init__(config)
        self.state_data = {agent_name}State()
        self.memory = ShortTermMemory()

    async def _initialize_core(self) -> None:
        """Initialize and load state."""
        logger.info(f"{{self.config.name}} initializing with state management")

        # Load previous state if available
        state_file = self._get_state_file()
        if state_file.exists():
            await self._load_state()

    async def _execute_core(self, input_data: Any, context: ExecutionContext) -> Any:
        """Execute with state management."""
        # Update execution count
        self.state_data.execution_count += 1

        # Process with state
        result = await self._process_with_state(input_data)

        # Update state
        self.state_data.last_result = result
        self.state_data.timestamp = datetime.utcnow()

        # Save state
        await self._save_state()

        return result

    async def _process_with_state(self, input_data: Any) -> Dict[str, Any]:
        """Process data using current state."""
        # Access current state
        previous_result = self.state_data.last_result
        execution_count = self.state_data.execution_count

        # Process
        result = {{
            "execution_number": execution_count,
            "previous_available": previous_result is not None
        }}

        return result

    async def _save_state(self):
        """Save current state to disk."""
        state_file = self._get_state_file()
        state_file.parent.mkdir(parents=True, exist_ok=True)

        state_file.write_text(self.state_data.json(indent=2))
        logger.debug(f"State saved to {{state_file}}")

    async def _load_state(self):
        """Load state from disk."""
        state_file = self._get_state_file()

        if state_file.exists():
            state_json = json.loads(state_file.read_text())
            self.state_data = {agent_name}State(**state_json)
            logger.info(f"State loaded: {{self.state_data.execution_count}} previous executions")

    def _get_state_file(self) -> Path:
        """Get path to state file."""
        state_dir = Path("./state")
        return state_dir / f"{{self.config.agent_id}}_state.json"

    async def _get_custom_state(self) -> Dict[str, Any]:
        """Get custom state for checkpointing."""
        return self.state_data.dict()

    async def _restore_custom_state(self, state: Dict[str, Any]) -> None:
        """Restore custom state from checkpoint."""
        self.state_data = {agent_name}State(**state)

    async def _terminate_core(self) -> None:
        """Save final state and cleanup."""
        await self._save_state()
        logger.info(f"{{self.config.name}} terminated with {{self.state_data.execution_count}} total executions")
'''

    def generate_tests(self, agent_name: str, spec: Dict[str, Any]) -> str:
        """Generate test code."""
        return f'''"""Tests for {agent_name}."""

import pytest
from pathlib import Path

from ..{agent_name.lower()} import {agent_name}
from ..base_agent import AgentConfig


class Test{agent_name}:
    """Test stateful agent."""

    @pytest.mark.asyncio
    async def test_state_persistence(self):
        """Test state persists across executions."""
        config = AgentConfig(name="{agent_name}")
        agent = {agent_name}(config)

        await agent.initialize()

        # First execution
        result1 = await agent.execute({{}})
        assert result1.success

        # State should be updated
        assert agent.state_data.execution_count == 1

        # Second execution
        result2 = await agent.execute({{}})
        assert agent.state_data.execution_count == 2

        await agent.terminate()
'''


class CalculatorTemplate(AgentTemplate):
    """Template for Calculator agents with zero-hallucination calculations."""

    def __init__(self):
        super().__init__(
            name="CalculatorTemplate",
            description="Template for deterministic calculation agents",
            base_imports=[
                "from typing import Dict, List, Optional, Any, Union",
                "from pydantic import BaseModel, Field, validator",
                "import hashlib",
                "import logging",
                "from datetime import datetime",
                "import numpy as np",
                "import pandas as pd",
                "from decimal import Decimal, ROUND_HALF_UP",
                "",
                "from ..base_agent import BaseAgent, AgentConfig, ExecutionContext",
            ],
            base_classes=["BaseAgent"],
            required_methods=[
                "calculate",
                "_validate_inputs",
                "_perform_calculation",
                "_validate_outputs",
                "_generate_provenance"
            ],
            supported_features=[
                "zero_hallucination",
                "provenance_tracking",
                "formula_evaluation",
                "unit_conversion",
                "precision_control"
            ]
        )

    def generate_code(self, agent_name: str, spec: Dict[str, Any]) -> str:
        """Generate calculator agent code."""
        template = f'''"""
{agent_name} - Zero-hallucination calculation agent.

This agent performs deterministic calculations for {spec.get("description", "domain-specific calculations")}.
All calculations are traceable and auditable with SHA-256 provenance tracking.

Generated by GreenLang Agent Factory v1.0.0
"""

{self.get_imports()}

logger = logging.getLogger(__name__)


class {agent_name}Input(BaseModel):
    """Input model for {agent_name}."""

    {self._generate_input_fields(spec.get("input_schema", {}))}

    @validator('*')
    def validate_positive(cls, v):
        """Ensure numeric values are non-negative where appropriate."""
        if isinstance(v, (int, float, Decimal)) and v < 0:
            raise ValueError("Negative values not allowed in this field")
        return v


class {agent_name}Output(BaseModel):
    """Output model for {agent_name}."""

    {self._generate_output_fields(spec.get("output_schema", {}))}

    # Provenance and metadata
    provenance_hash: str = Field(..., description="SHA-256 hash for audit trail")
    calculation_timestamp: datetime = Field(default_factory=datetime.utcnow)
    processing_time_ms: float = Field(..., description="Processing duration")
    formula_version: str = Field("1.0.0", description="Formula version used")


class {agent_name}(BaseAgent):
    """
    {spec.get("description", "Calculation agent")}

    This agent implements zero-hallucination principles:
    - All calculations are deterministic
    - No LLM calls for numeric operations
    - Complete provenance tracking
    - Formula-based evaluation only
    """

    def __init__(self, config: AgentConfig):
        """Initialize {agent_name}."""
        super().__init__(config)

        # Load calculation formulas
        self.formulas = {{
            {self._generate_formulas(spec.get("calculation_formulas", {}))}
        }}

        logger.info(f"{agent_name} initialized with {{len(self.formulas)}} formulas")

    async def _initialize_core(self) -> None:
        """Initialize calculation engine."""
        logger.info("Calculation engine initialized")
        # Load any additional calculation resources
        pass

    async def _execute_core(self, input_data: Any, context: ExecutionContext) -> Any:
        """Execute calculation."""
        # Validate and parse input
        validated_input = {agent_name}Input(**input_data)

        # Perform calculation
        result = self.calculate(validated_input)

        return result.dict()

    def calculate(self, input_data: {agent_name}Input) -> {agent_name}Output:
        """
        Perform calculation with full provenance tracking.

        Args:
            input_data: Validated input data

        Returns:
            Calculated output with provenance

        Raises:
            ValueError: Invalid input data
            CalculationError: Calculation failed
        """
        start_time = datetime.utcnow()

        try:
            # Step 1: Validate inputs
            validation_result = self._validate_inputs(input_data)
            if not validation_result["is_valid"]:
                raise ValueError(f"Input validation failed: {{validation_result['errors']}}")

            # Step 2: Perform deterministic calculation
            calculation_result = self._perform_calculation(input_data)

            # Step 3: Validate outputs
            output_validation = self._validate_outputs(calculation_result)
            if not output_validation["is_valid"]:
                raise ValueError(f"Output validation failed: {{output_validation['errors']}}")

            # Step 4: Generate provenance
            provenance_hash = self._generate_provenance(input_data, calculation_result)

            # Step 5: Create output
            processing_time = (datetime.utcnow() - start_time).total_seconds() * 1000

            return {agent_name}Output(
                **calculation_result,
                provenance_hash=provenance_hash,
                processing_time_ms=processing_time
            )

        except Exception as e:
            logger.error(f"Calculation failed: {{str(e)}}", exc_info=True)
            raise

    def _validate_inputs(self, input_data: {agent_name}Input) -> Dict[str, Any]:
        """Validate input data against rules."""
        errors = []

        # Add validation logic
        data_dict = input_data.dict()

        # Check for required fields
        for field in ["activity_data"]:
            if field not in data_dict or data_dict[field] is None:
                errors.append(f"Missing required field: {{field}}")

        return {{
            "is_valid": len(errors) == 0,
            "errors": errors
        }}

    def _perform_calculation(self, input_data: {agent_name}Input) -> Dict[str, Any]:
        """
        Perform deterministic calculation.
        NO LLM CALLS ALLOWED IN THIS METHOD.
        """
        results = {{}}
        input_dict = input_data.dict()

        # Apply formulas deterministically
        for field, formula in self.formulas.items():
            try:
                # Use Decimal for precision
                result = self._evaluate_formula(formula, input_dict)
                results[field] = float(result)
            except Exception as e:
                logger.error(f"Formula evaluation failed for {{field}}: {{str(e)}}")
                raise

        return results

    def _evaluate_formula(self, formula: str, variables: Dict[str, Any]) -> Decimal:
        """Safely evaluate mathematical formula."""
        # Convert to Decimal for precision
        decimal_vars = {{
            k: Decimal(str(v)) if isinstance(v, (int, float)) else v
            for k, v in variables.items()
        }}

        # Safe formula evaluation
        # In production, use a proper formula parser like sympy or ast.parse
        try:
            # Example simple formula evaluation
            if "activity_data" in decimal_vars:
                # Replace with actual formula parsing
                result = decimal_vars.get("activity_data", Decimal("0")) * Decimal("2.5")
            else:
                result = Decimal("0")

            return result.quantize(Decimal("0.0001"), rounding=ROUND_HALF_UP)

        except Exception as e:
            logger.error(f"Formula evaluation error: {{str(e)}}")
            raise

    def _validate_outputs(self, results: Dict[str, Any]) -> Dict[str, Any]:
        """Validate calculation outputs."""
        errors = []

        # Check for NaN, infinity, negative values where inappropriate
        for key, value in results.items():
            if isinstance(value, (int, float)):
                if np.isnan(value):
                    errors.append(f"{{key}} is NaN")
                if np.isinf(value):
                    errors.append(f"{{key}} is Infinity")

        return {{
            "is_valid": len(errors) == 0,
            "errors": errors
        }}

    def _generate_provenance(self, input_data: Any, output_data: Dict[str, Any]) -> str:
        """Generate SHA-256 hash for complete audit trail."""
        provenance_str = json.dumps({{
            "input": input_data.dict() if hasattr(input_data, 'dict') else input_data,
            "output": output_data,
            "formulas": self.formulas,
            "timestamp": datetime.utcnow().isoformat(),
            "agent_version": self.config.version
        }}, sort_keys=True)

        return hashlib.sha256(provenance_str.encode()).hexdigest()

    async def _terminate_core(self) -> None:
        """Cleanup resources."""
        logger.info(f"{{self.config.name}} calculation engine terminated")
'''
        return template

    def generate_tests(self, agent_name: str, spec: Dict[str, Any]) -> str:
        """Generate test code for calculator agent."""
        test_template = f'''"""
Unit tests for {agent_name}.

Generated by GreenLang Agent Factory v1.0.0
"""

import pytest
from decimal import Decimal
from datetime import datetime

from ..{agent_name.lower()} import {agent_name}, {agent_name}Input, {agent_name}Output
from ..base_agent import AgentConfig


class Test{agent_name}:
    """Test suite for {agent_name}."""

    @pytest.fixture
    def agent(self):
        """Create test agent instance."""
        config = AgentConfig(
            name="{agent_name}",
            version="1.0.0"
        )
        return {agent_name}(config)

    @pytest.fixture
    def valid_input(self):
        """Create valid test input."""
        return {agent_name}Input(
            {self._generate_test_input(spec.get("input_schema", {}))}
        )

    def test_initialization(self, agent):
        """Test agent initialization."""
        assert agent is not None
        assert agent.config.name == "{agent_name}"
        assert len(agent.formulas) > 0

    def test_valid_calculation(self, agent, valid_input):
        """Test calculation with valid input."""
        result = agent.calculate(valid_input)

        assert isinstance(result, {agent_name}Output)
        assert result.provenance_hash is not None
        assert len(result.provenance_hash) == 64  # SHA-256 hash length
        assert result.processing_time_ms > 0

    def test_deterministic_calculation(self, agent, valid_input):
        """Test that calculations are deterministic."""
        result1 = agent.calculate(valid_input)
        result2 = agent.calculate(valid_input)

        # Results should be identical for same input
        assert result1.dict(exclude={{"calculation_timestamp", "processing_time_ms"}}) == \\
               result2.dict(exclude={{"calculation_timestamp", "processing_time_ms"}})

    def test_provenance_tracking(self, agent, valid_input):
        """Test provenance hash generation."""
        result = agent.calculate(valid_input)

        # Provenance should be unique for different inputs
        modified_input = valid_input.copy(update={{"activity_data": 200.0}})
        result2 = agent.calculate(modified_input)

        assert result.provenance_hash != result2.provenance_hash

    def test_formula_version_tracking(self, agent, valid_input):
        """Test formula version is tracked."""
        result = agent.calculate(valid_input)
        assert result.formula_version == "1.0.0"

    @pytest.mark.asyncio
    async def test_async_execution(self, agent, valid_input):
        """Test async execution through base agent."""
        await agent.initialize()

        result = await agent.execute(valid_input.dict())

        assert result.success
        assert result.result is not None

        await agent.terminate()
'''
        return test_template

    def _generate_input_fields(self, schema: Dict[str, Any]) -> str:
        """Generate input field definitions from schema."""
        if not schema:
            return 'activity_data: float = Field(..., gt=0, description="Activity data")'

        fields = []
        for field_name, field_type in schema.items():
            if field_type == "float":
                fields.append(f'{field_name}: float = Field(..., gt=0, description="{field_name.replace("_", " ").title()}")')
            elif field_type == "int":
                fields.append(f'{field_name}: int = Field(..., ge=0, description="{field_name.replace("_", " ").title()}")')
            else:
                fields.append(f'{field_name}: str = Field(..., description="{field_name.replace("_", " ").title()}")')

        return "\n    ".join(fields)

    def _generate_output_fields(self, schema: Dict[str, Any]) -> str:
        """Generate output field definitions from schema."""
        if not schema:
            return 'emissions: float = Field(..., ge=0, description="Calculated emissions")'

        fields = []
        for field_name, field_type in schema.items():
            if field_type == "float":
                fields.append(f'{field_name}: float = Field(..., ge=0, description="{field_name.replace("_", " ").title()}")')
            else:
                fields.append(f'{field_name}: Any = Field(..., description="{field_name.replace("_", " ").title()}")')

        return "\n    ".join(fields)

    def _generate_formulas(self, formulas: Dict[str, str]) -> str:
        """Generate formula dictionary."""
        if not formulas:
            return '"emissions": "activity_data * emission_factor"'

        formula_items = []
        for field, formula in formulas.items():
            formula_items.append(f'"{field}": "{formula}"')

        return ",\n            ".join(formula_items)

    def _generate_test_input(self, schema: Dict[str, Any]) -> str:
        """Generate test input values."""
        if not schema:
            return "activity_data=100.0"

        values = []
        for field_name, field_type in schema.items():
            if field_type == "float":
                values.append(f"{field_name}=100.0")
            elif field_type == "int":
                values.append(f"{field_name}=100")
            else:
                values.append(f'{field_name}="test_value"')

        return ",\n            ".join(values)


# Template registry
TEMPLATE_REGISTRY: Dict[str, type] = {
    "stateless": StatelessAgentTemplate,
    "stateful": StatefulAgentTemplate,
    "calculator": CalculatorTemplate,
}


def get_template(agent_type: str) -> AgentTemplate:
    """
    Get template instance for agent type.

    Args:
        agent_type: Type of agent template needed

    Returns:
        Template instance

    Raises:
        ValueError: Unknown template type
    """
    template_class = TEMPLATE_REGISTRY.get(agent_type.lower())

    if not template_class:
        raise ValueError(
            f"Unknown template type: {agent_type}. "
            f"Available: {list(TEMPLATE_REGISTRY.keys())}"
        )

    return template_class()


def register_template(name: str, template_class: type):
    """
    Register a custom template.

    Args:
        name: Template name
        template_class: Template class
    """
    if not issubclass(template_class, AgentTemplate):
        raise ValueError("Template must inherit from AgentTemplate")

    TEMPLATE_REGISTRY[name.lower()] = template_class
    logger.info(f"Registered template: {name}")


def list_templates() -> List[str]:
    """Get list of available templates."""
    return list(TEMPLATE_REGISTRY.keys())
