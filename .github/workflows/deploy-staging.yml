# GreenLang Agent Factory - Staging Deployment Workflow
# Automated deployment to staging environment

name: Deploy to Staging

on:
  push:
    branches:
      - main
  workflow_dispatch:
    inputs:
      image_tag:
        description: 'Docker image tag to deploy'
        required: false
        default: 'latest'
      skip_tests:
        description: 'Skip smoke tests after deployment'
        required: false
        default: 'false'
        type: boolean

env:
  CLUSTER_NAME: greenlang-staging
  AWS_REGION: us-east-1
  NAMESPACE: greenlang-agents
  HELM_RELEASE: greenlang-agents
  HELM_CHART_PATH: infrastructure/helm/greenlang

concurrency:
  group: staging-deployment
  cancel-in-progress: false

jobs:
  # ============================================
  # Pre-deployment Validation
  # ============================================
  validate:
    name: Pre-deployment Validation
    runs-on: ubuntu-latest
    outputs:
      image_tag: ${{ steps.determine-tag.outputs.tag }}
      should_deploy: ${{ steps.check.outputs.deploy }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Determine image tag
        id: determine-tag
        run: |
          if [ -n "${{ github.event.inputs.image_tag }}" ]; then
            TAG="${{ github.event.inputs.image_tag }}"
          else
            TAG=$(git rev-parse --short HEAD)
          fi
          echo "tag=$TAG" >> $GITHUB_OUTPUT
          echo "Deploying image tag: $TAG"

      - name: Validate Helm chart
        run: |
          if [ -d "${{ env.HELM_CHART_PATH }}" ]; then
            helm lint ${{ env.HELM_CHART_PATH }}
          else
            echo "Helm chart not found at ${{ env.HELM_CHART_PATH }}"
          fi

      - name: Check if deployment is needed
        id: check
        run: |
          echo "deploy=true" >> $GITHUB_OUTPUT

  # ============================================
  # Deploy to Staging
  # ============================================
  deploy:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: validate
    environment:
      name: staging
      url: https://staging.greenlang.io
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig \
            --name ${{ env.CLUSTER_NAME }} \
            --region ${{ env.AWS_REGION }}

      - name: Set up Helm
        uses: azure/setup-helm@v4
        with:
          version: 'v3.14.0'

      - name: Create namespace if not exists
        run: |
          kubectl create namespace ${{ env.NAMESPACE }} --dry-run=client -o yaml | kubectl apply -f -

      - name: Deploy with Helm
        run: |
          helm upgrade --install ${{ env.HELM_RELEASE }} \
            ${{ env.HELM_CHART_PATH }} \
            --namespace ${{ env.NAMESPACE }} \
            --values ${{ env.HELM_CHART_PATH }}/values-staging.yaml \
            --set image.tag=${{ needs.validate.outputs.image_tag }} \
            --set deployment.timestamp=$(date +%s) \
            --atomic \
            --wait \
            --timeout 10m

      - name: Verify deployment status
        run: |
          echo "Checking deployment status..."
          kubectl rollout status deployment -n ${{ env.NAMESPACE }} --timeout=300s

          echo "Checking pod status..."
          kubectl get pods -n ${{ env.NAMESPACE }}

          echo "Checking service endpoints..."
          kubectl get endpoints -n ${{ env.NAMESPACE }}

      - name: Get deployment info
        id: deploy-info
        run: |
          PODS=$(kubectl get pods -n ${{ env.NAMESPACE }} -o jsonpath='{.items[*].metadata.name}')
          echo "pods=$PODS" >> $GITHUB_OUTPUT

  # ============================================
  # Smoke Tests
  # ============================================
  smoke-tests:
    name: Run Smoke Tests
    runs-on: ubuntu-latest
    needs: [validate, deploy]
    if: github.event.inputs.skip_tests != 'true'
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Configure kubectl
        run: |
          aws eks update-kubeconfig \
            --name ${{ env.CLUSTER_NAME }} \
            --region ${{ env.AWS_REGION }}

      - name: Wait for services to be ready
        run: |
          echo "Waiting for services to be fully ready..."
          sleep 30

      - name: Run health checks
        run: |
          # Get the service endpoint
          ENDPOINT=$(kubectl get svc -n ${{ env.NAMESPACE }} -o jsonpath='{.items[0].status.loadBalancer.ingress[0].hostname}' 2>/dev/null || echo "localhost")

          echo "Testing health endpoint..."
          # Use port-forward for testing if no external endpoint
          kubectl port-forward svc/greenlang-api 8080:80 -n ${{ env.NAMESPACE }} &
          PF_PID=$!
          sleep 5

          # Health check
          curl -sf http://localhost:8080/health || echo "Health check endpoint not available"
          curl -sf http://localhost:8080/api/v1/health || echo "API health check not available"

          kill $PF_PID 2>/dev/null || true

      - name: Run API smoke tests
        run: |
          echo "Running API smoke tests..."
          # Placeholder for actual smoke test script
          if [ -f "scripts/smoke-test.sh" ]; then
            chmod +x scripts/smoke-test.sh
            ./scripts/smoke-test.sh staging
          else
            echo "No smoke test script found, skipping"
          fi

  # ============================================
  # Post-deployment
  # ============================================
  post-deploy:
    name: Post-deployment Tasks
    runs-on: ubuntu-latest
    needs: [validate, deploy, smoke-tests]
    if: always()
    steps:
      - name: Record deployment
        run: |
          echo "Recording deployment..."
          echo "Version: ${{ needs.validate.outputs.image_tag }}"
          echo "Environment: staging"
          echo "Timestamp: $(date -u +%Y-%m-%dT%H:%M:%SZ)"
          echo "Deployer: ${{ github.actor }}"

      - name: Update deployment dashboard
        run: |
          echo "Deployment recorded successfully"

      - name: Notify Slack - Success
        if: success()
        uses: slackapi/slack-github-action@v1.25.0
        with:
          payload: |
            {
              "text": "Staging Deployment Successful",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Staging Deployment Successful*\n\n*Version:* `${{ needs.validate.outputs.image_tag }}`\n*Environment:* staging\n*Deployed by:* ${{ github.actor }}\n\n<https://staging.greenlang.io|View Staging>"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK

      - name: Notify Slack - Failure
        if: failure()
        uses: slackapi/slack-github-action@v1.25.0
        with:
          payload: |
            {
              "text": "Staging Deployment Failed",
              "blocks": [
                {
                  "type": "section",
                  "text": {
                    "type": "mrkdwn",
                    "text": "*Staging Deployment Failed*\n\n*Version:* `${{ needs.validate.outputs.image_tag }}`\n*Environment:* staging\n\n<${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}|View Logs>"
                  }
                }
              ]
            }
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
          SLACK_WEBHOOK_TYPE: INCOMING_WEBHOOK
