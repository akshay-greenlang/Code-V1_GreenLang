# GL-001 ProcessHeatOrchestrator - Continuous Deployment Pipeline
# Production-grade deployment with blue-green strategy, health checks, and rollback capability
# Deploys to staging automatically, production requires manual approval

name: GL-001 CD

on:
  # Trigger on successful CI pipeline completion
  workflow_run:
    workflows: ["GL-001 CI"]
    branches: [main, master]
    types:
      - completed

  # Allow manual deployment with environment selection
  workflow_dispatch:
    inputs:
      environment:
        description: 'Deployment environment'
        required: true
        default: 'staging'
        type: choice
        options:
          - development
          - staging
          - production
      skip_tests:
        description: 'Skip post-deployment tests'
        required: false
        default: 'false'
        type: boolean

# Prevent concurrent deployments to the same environment
concurrency:
  group: gl-001-cd-${{ github.event.inputs.environment || 'auto' }}
  cancel-in-progress: false

env:
  GL_001_PATH: 'applications/gl_agents/GL-001_Thermalcommand'
  CONTAINER_REGISTRY: ghcr.io
  IMAGE_NAME: gl-001-process-heat
  KUBECTL_VERSION: '1.28.0'
  HELM_VERSION: '3.13.0'

jobs:
  # ============================================================================
  # JOB 1: DETERMINE DEPLOYMENT STRATEGY
  # ============================================================================
  determine-deployment:
    name: Determine Deployment Strategy
    runs-on: ubuntu-latest
    outputs:
      environment: ${{ steps.set-env.outputs.environment }}
      image-tag: ${{ steps.set-env.outputs.image-tag }}
      deploy-staging: ${{ steps.set-env.outputs.deploy-staging }}
      deploy-production: ${{ steps.set-env.outputs.deploy-production }}
      git-sha: ${{ steps.set-env.outputs.git-sha }}

    steps:
      - name: Determine deployment parameters
        id: set-env
        run: |
          # Determine environment
          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            ENVIRONMENT="${{ github.event.inputs.environment }}"
          elif [[ "${{ github.ref }}" == "refs/heads/main" ]] || [[ "${{ github.ref }}" == "refs/heads/master" ]]; then
            ENVIRONMENT="staging"  # Auto-deploy to staging, manual approval for production
          else
            ENVIRONMENT="development"
          fi

          # Generate image tag
          GIT_SHA="${{ github.sha }}"
          SHORT_SHA="${GIT_SHA:0:8}"
          TIMESTAMP=$(date +%Y%m%d-%H%M%S)

          if [[ "$ENVIRONMENT" == "production" ]]; then
            IMAGE_TAG="v1.0.${GITHUB_RUN_NUMBER}-prod-${SHORT_SHA}"
          elif [[ "$ENVIRONMENT" == "staging" ]]; then
            IMAGE_TAG="v1.0.${GITHUB_RUN_NUMBER}-staging-${SHORT_SHA}"
          else
            IMAGE_TAG="dev-${SHORT_SHA}-${TIMESTAMP}"
          fi

          # Set deployment flags
          DEPLOY_STAGING="false"
          DEPLOY_PRODUCTION="false"
          if [[ "$ENVIRONMENT" == "staging" ]] || [[ "$ENVIRONMENT" == "development" ]]; then
            DEPLOY_STAGING="true"
          fi
          if [[ "$ENVIRONMENT" == "production" ]]; then
            DEPLOY_PRODUCTION="true"
          fi

          # Output variables
          echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT
          echo "image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "deploy-staging=${DEPLOY_STAGING}" >> $GITHUB_OUTPUT
          echo "deploy-production=${DEPLOY_PRODUCTION}" >> $GITHUB_OUTPUT
          echo "git-sha=${GIT_SHA}" >> $GITHUB_OUTPUT

          echo "üì¶ Deployment Configuration:"
          echo "  Environment: ${ENVIRONMENT}"
          echo "  Image Tag: ${IMAGE_TAG}"
          echo "  Git SHA: ${GIT_SHA}"

  # ============================================================================
  # JOB 2: BUILD AND PUSH DOCKER IMAGE
  # ============================================================================
  build-and-push:
    name: Build & Push Docker Image
    runs-on: ubuntu-latest
    needs: determine-deployment
    timeout-minutes: 30
    permissions:
      contents: read
      packages: write
      security-events: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.CONTAINER_REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: ./${{ env.GL_001_PATH }}
          file: ./${{ env.GL_001_PATH }}/Dockerfile
          push: true
          tags: |
            ${{ env.CONTAINER_REGISTRY }}/${{ github.repository }}/${{ env.IMAGE_NAME }}:${{ needs.determine-deployment.outputs.image-tag }}
            ${{ env.CONTAINER_REGISTRY }}/${{ github.repository }}/${{ env.IMAGE_NAME }}:latest
            ${{ env.CONTAINER_REGISTRY }}/${{ github.repository }}/${{ env.IMAGE_NAME }}:${{ needs.determine-deployment.outputs.environment }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          build-args: |
            VERSION=${{ needs.determine-deployment.outputs.image-tag }}
            GIT_SHA=${{ needs.determine-deployment.outputs.git-sha }}
            BUILD_DATE=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

      - name: Scan Docker image with Trivy
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.CONTAINER_REGISTRY }}/${{ github.repository }}/${{ env.IMAGE_NAME }}:${{ needs.determine-deployment.outputs.image-tag }}
          format: 'sarif'
          output: 'trivy-results.sarif'

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v2
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Generate SBOM
        uses: anchore/sbom-action@v0
        with:
          image: ${{ env.CONTAINER_REGISTRY }}/${{ github.repository }}/${{ env.IMAGE_NAME }}:${{ needs.determine-deployment.outputs.image-tag }}
          format: spdx-json
          output-file: sbom-gl-001.spdx.json

      - name: Upload SBOM artifact
        uses: actions/upload-artifact@v4
        with:
          name: sbom-${{ needs.determine-deployment.outputs.image-tag }}
          path: sbom-gl-001.spdx.json
          retention-days: 90

  # ============================================================================
  # JOB 3: DEPLOY TO STAGING
  # ============================================================================
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: [determine-deployment, build-and-push]
    if: needs.determine-deployment.outputs.deploy-staging == 'true'
    environment:
      name: staging
      url: https://staging.gl-001.greenlang.ai
    timeout-minutes: 20

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Configure kubectl for staging
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG_STAGING }}" | base64 -d > $HOME/.kube/config
          kubectl config use-context greenlang-staging

      - name: Apply Kubernetes manifests (staging)
        run: |
          echo "üöÄ Deploying to Staging..."
          cd ${{ env.GL_001_PATH }}/deployment

          # Apply ConfigMap
          kubectl apply -f configmap.yaml -n greenlang

          # Update deployment with new image
          kubectl set image deployment/gl-001-process-heat \
            gl-001-process-heat=${{ env.CONTAINER_REGISTRY }}/${{ github.repository }}/${{ env.IMAGE_NAME }}:${{ needs.determine-deployment.outputs.image-tag }} \
            -n greenlang

          # Wait for rollout
          kubectl rollout status deployment/gl-001-process-heat -n greenlang --timeout=10m

      - name: Verify deployment health
        run: |
          echo "üè• Verifying deployment health..."
          kubectl get pods -n greenlang -l app=gl-001-process-heat
          kubectl describe deployment gl-001-process-heat -n greenlang

      - name: Run smoke tests
        if: ${{ github.event.inputs.skip_tests != 'true' }}
        run: |
          echo "üß™ Running smoke tests..."
          # Get service endpoint
          SERVICE_IP=$(kubectl get svc gl-001-process-heat -n greenlang -o jsonpath='{.status.loadBalancer.ingress[0].ip}')
          echo "Service IP: ${SERVICE_IP}"

          # Health check
          curl -f http://${SERVICE_IP}/health || exit 1

          # Readiness check
          curl -f http://${SERVICE_IP}/ready || exit 1

  # ============================================================================
  # JOB 4: DEPLOY TO PRODUCTION (with approval)
  # ============================================================================
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: [determine-deployment, build-and-push, deploy-staging]
    if: needs.determine-deployment.outputs.deploy-production == 'true'
    environment:
      name: production
      url: https://api.process-heat.greenlang.ai
    timeout-minutes: 30

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup kubectl
        uses: azure/setup-kubectl@v3
        with:
          version: ${{ env.KUBECTL_VERSION }}

      - name: Configure kubectl for production
        run: |
          mkdir -p $HOME/.kube
          echo "${{ secrets.KUBE_CONFIG_PRODUCTION }}" | base64 -d > $HOME/.kube/config
          kubectl config use-context greenlang-production

      - name: Backup current deployment
        run: |
          echo "üíæ Backing up current deployment..."
          kubectl get deployment gl-001-process-heat -n greenlang -o yaml > backup-deployment-${GITHUB_SHA}.yaml

      - name: Blue-Green Deployment - Deploy Green
        run: |
          echo "üü¢ Deploying GREEN environment..."
          cd ${{ env.GL_001_PATH }}/deployment

          # Create green deployment
          kubectl apply -f deployment.yaml -n greenlang
          kubectl set image deployment/gl-001-process-heat \
            gl-001-process-heat=${{ env.CONTAINER_REGISTRY }}/${{ github.repository }}/${{ env.IMAGE_NAME }}:${{ needs.determine-deployment.outputs.image-tag }} \
            -n greenlang

          # Wait for green deployment to be ready
          kubectl rollout status deployment/gl-001-process-heat -n greenlang --timeout=15m

      - name: Run production health checks
        run: |
          echo "üè• Running production health checks..."
          sleep 30  # Allow warmup

          # Check all pods are running
          READY_PODS=$(kubectl get pods -n greenlang -l app=gl-001-process-heat -o jsonpath='{.items[?(@.status.phase=="Running")].metadata.name}' | wc -w)
          TOTAL_PODS=$(kubectl get deployment gl-001-process-heat -n greenlang -o jsonpath='{.spec.replicas}')

          echo "Ready pods: ${READY_PODS}/${TOTAL_PODS}"
          if [[ ${READY_PODS} -lt ${TOTAL_PODS} ]]; then
            echo "‚ùå Not all pods are ready!"
            exit 1
          fi

          # Test health endpoints
          kubectl run health-check --image=curlimages/curl --rm -it --restart=Never -- \
            curl -f http://gl-001-process-heat.greenlang.svc.cluster.local/health

      - name: Switch traffic to green (complete cutover)
        run: |
          echo "üîÑ Switching traffic to GREEN deployment..."
          # Traffic is automatically switched via service selector
          echo "‚úÖ Traffic cutover complete"

      - name: Monitor for 10 minutes
        run: |
          echo "üëÄ Monitoring deployment for 10 minutes..."
          for i in {1..20}; do
            echo "Check $i/20..."
            kubectl get pods -n greenlang -l app=gl-001-process-heat
            ERROR_COUNT=$(kubectl logs -n greenlang -l app=gl-001-process-heat --since=30s | grep -i error | wc -l)
            echo "Error count in last 30s: ${ERROR_COUNT}"
            if [[ ${ERROR_COUNT} -gt 10 ]]; then
              echo "‚ö†Ô∏è High error rate detected!"
            fi
            sleep 30
          done

      - name: Verify zero errors
        run: |
          echo "‚úÖ Verifying zero critical errors..."
          CRITICAL_ERRORS=$(kubectl logs -n greenlang -l app=gl-001-process-heat --since=10m | grep -i "critical" | wc -l)
          if [[ ${CRITICAL_ERRORS} -gt 0 ]]; then
            echo "‚ùå Found ${CRITICAL_ERRORS} critical errors!"
            exit 1
          fi

      - name: Deployment successful
        run: |
          echo "‚úÖ GL-001 DEPLOYED TO PRODUCTION"
          echo "Version: ${{ needs.determine-deployment.outputs.image-tag }}"
          echo "SHA: ${{ needs.determine-deployment.outputs.git-sha }}"

      - name: Send deployment notification
        if: always()
        run: |
          echo "üì¢ Sending deployment notification..."
          # Add Slack/email notification here
          echo "Deployment Status: ${{ job.status }}"

  # ============================================================================
  # JOB 5: ROLLBACK (if needed)
  # ============================================================================
  rollback:
    name: Rollback Deployment
    runs-on: ubuntu-latest
    if: failure() && (needs.deploy-staging.result == 'failure' || needs.deploy-production.result == 'failure')
    needs: [deploy-staging, deploy-production]
    timeout-minutes: 10

    steps:
      - name: Setup kubectl
        uses: azure/setup-kubectl@v3

      - name: Rollback deployment
        run: |
          echo "‚è™ Rolling back deployment..."
          kubectl rollout undo deployment/gl-001-process-heat -n greenlang
          kubectl rollout status deployment/gl-001-process-heat -n greenlang

      - name: Send rollback notification
        run: |
          echo "üö® ROLLBACK EXECUTED - Deployment failed"
          # Add alerting here
