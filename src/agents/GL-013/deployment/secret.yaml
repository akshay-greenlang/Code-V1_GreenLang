# ==============================================================================
# GL-013 PREDICTMAINT - Kubernetes Secret Template
# ==============================================================================
# SECURITY WARNING:
#   - This is a TEMPLATE file with placeholder values
#   - DO NOT commit actual secrets to version control
#   - Use external secret management (Vault, AWS Secrets Manager, etc.)
#   - In production, use SealedSecrets, External Secrets Operator, or similar
#
# Usage:
#   1. Copy this file: cp secret.yaml secret.yaml.local
#   2. Replace placeholder values with actual secrets
#   3. Apply: kubectl apply -f secret.yaml.local
#   4. Delete local file: rm secret.yaml.local
#
# For production, consider using:
#   - HashiCorp Vault with Vault Secrets Operator
#   - AWS Secrets Manager with External Secrets Operator
#   - Azure Key Vault with secrets-store-csi-driver
#   - Google Secret Manager with Config Connector
# ==============================================================================
---
apiVersion: v1
kind: Secret
metadata:
  name: gl-013-predictmaint-secrets
  namespace: greenlang
  labels:
    app: gl-013-predictmaint
    app.kubernetes.io/name: gl-013-predictmaint
    app.kubernetes.io/component: secrets
    app.kubernetes.io/part-of: greenlang-platform
    team: iota
  annotations:
    description: "GL-013 PREDICTMAINT - Sensitive credentials"
    # Kubernetes Reloader annotation for automatic pod restart on secret change
    reloader.stakater.com/match: "true"
# Type of secret - Opaque for arbitrary data
type: Opaque
# String data allows plain text values (base64 encoded automatically)
stringData:
  # ==============================================================================
  # Database Credentials
  # ==============================================================================
  # PostgreSQL username
  DB_USER: "gl013_app_user"
  # PostgreSQL password - REPLACE WITH ACTUAL PASSWORD
  DB_PASSWORD: "<REPLACE_WITH_SECURE_PASSWORD>"
  # Full database connection URL
  DATABASE_URL: "postgresql://gl013_app_user:<REPLACE_WITH_SECURE_PASSWORD>@postgresql.greenlang.svc.cluster.local:5432/gl013_predictmaint"

  # ==============================================================================
  # Redis Credentials
  # ==============================================================================
  # Redis password - REPLACE WITH ACTUAL PASSWORD
  REDIS_PASSWORD: "<REPLACE_WITH_SECURE_PASSWORD>"
  # Full Redis connection URL
  REDIS_URL: "redis://:<REPLACE_WITH_SECURE_PASSWORD>@redis.greenlang.svc.cluster.local:6379/0"

  # ==============================================================================
  # API Security
  # ==============================================================================
  # API secret key for general encryption
  API_SECRET_KEY: "<REPLACE_WITH_SECURE_64_CHAR_HEX_STRING>"
  # JWT signing secret
  JWT_SECRET: "<REPLACE_WITH_SECURE_64_CHAR_HEX_STRING>"
  # JWT algorithm
  JWT_ALGORITHM: "HS256"
  # JWT token expiration (seconds)
  JWT_EXPIRATION: "3600"

  # ==============================================================================
  # External Service Credentials
  # ==============================================================================
  # MQTT broker credentials
  MQTT_USERNAME: "gl013_mqtt_user"
  MQTT_PASSWORD: "<REPLACE_WITH_SECURE_PASSWORD>"

  # OPC UA credentials
  OPCUA_USERNAME: "gl013_opcua_user"
  OPCUA_PASSWORD: "<REPLACE_WITH_SECURE_PASSWORD>"
  # OPC UA certificate (base64 encoded)
  OPCUA_CERTIFICATE: "<REPLACE_WITH_BASE64_ENCODED_CERTIFICATE>"
  OPCUA_PRIVATE_KEY: "<REPLACE_WITH_BASE64_ENCODED_PRIVATE_KEY>"

  # ==============================================================================
  # Encryption Keys
  # ==============================================================================
  # AES encryption key for data at rest
  ENCRYPTION_KEY: "<REPLACE_WITH_SECURE_32_BYTE_KEY>"
  # Initialization vector for AES
  ENCRYPTION_IV: "<REPLACE_WITH_SECURE_16_BYTE_IV>"

  # ==============================================================================
  # Third-Party API Keys
  # ==============================================================================
  # Monitoring service API key
  DATADOG_API_KEY: "<REPLACE_WITH_DATADOG_API_KEY>"
  # Alert service API key
  PAGERDUTY_API_KEY: "<REPLACE_WITH_PAGERDUTY_API_KEY>"
  # Slack webhook for notifications
  SLACK_WEBHOOK_URL: "<REPLACE_WITH_SLACK_WEBHOOK_URL>"

---
# ==============================================================================
# Image Pull Secret for Private Container Registry
# ==============================================================================
apiVersion: v1
kind: Secret
metadata:
  name: gcr-json-key
  namespace: greenlang
  labels:
    app: gl-013-predictmaint
    app.kubernetes.io/component: registry-credentials
type: kubernetes.io/dockerconfigjson
data:
  # Replace with actual base64-encoded Docker config JSON
  # To create: kubectl create secret docker-registry gcr-json-key \
  #   --docker-server=gcr.io \
  #   --docker-username=_json_key \
  #   --docker-password="$(cat service-account.json)" \
  #   --docker-email=devops@greenlang.io \
  #   --dry-run=client -o yaml
  .dockerconfigjson: <REPLACE_WITH_BASE64_ENCODED_DOCKER_CONFIG>

---
# ==============================================================================
# TLS Certificate Secret (for Ingress)
# ==============================================================================
# Note: For production, use cert-manager with Let's Encrypt
# This is a template for manually managed certificates
apiVersion: v1
kind: Secret
metadata:
  name: gl-013-predictmaint-tls
  namespace: greenlang
  labels:
    app: gl-013-predictmaint
    app.kubernetes.io/component: tls
type: kubernetes.io/tls
data:
  # Base64-encoded TLS certificate
  tls.crt: <REPLACE_WITH_BASE64_ENCODED_TLS_CERTIFICATE>
  # Base64-encoded TLS private key
  tls.key: <REPLACE_WITH_BASE64_ENCODED_TLS_PRIVATE_KEY>
