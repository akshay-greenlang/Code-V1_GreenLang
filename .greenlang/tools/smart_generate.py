#!/usr/bin/env python3
"""
Smart Code Generator

LLM-powered code generation using natural language descriptions.
Generates complete agents, pipelines, and infrastructure code with tests.
"""

import argparse
import json
import os
import sys
from pathlib import Path
from typing import Dict, Any, List, Optional
from dataclasses import dataclass
import re


@dataclass
class GeneratedCode:
    """Generated code artifact."""
    filename: str
    content: str
    description: str
    file_type: str  # "agent", "test", "config", "pipeline"


class TemplateLibrary:
    """Library of code generation templates."""

    @staticmethod
    def get_agent_template(name: str, description: str, features: Dict[str, bool]) -> str:
        """Generate agent template."""

        has_llm = features.get('llm', False)
        has_validation = features.get('validation', True)
        has_batch = features.get('batch', True)
        has_caching = features.get('caching', False)

        imports = ['from shared.infrastructure.agents import BaseAgent']
        if has_llm:
            imports.append('from shared.infrastructure.llm import ChatSession')
        if has_validation:
            imports.append('from shared.infrastructure.validation import ValidationFramework, Field')
        if has_caching:
            imports.append('from shared.infrastructure.cache import CacheManager')

        imports.append('from shared.infrastructure.logging import Logger')
        imports.append('from typing import Dict, Any, List')

        template = f'''"""
{name}

{description}

Generated by GreenLang Smart Generator
"""

{chr(10).join(imports)}


class {name}(BaseAgent):
    """
    {description}
    """

    def __init__(self):
        super().__init__()
        self.logger = Logger(name=__name__)
{("        self.chat_session = ChatSession(provider='openai', model='gpt-4')" if has_llm else "")}
{("        self.cache = CacheManager(ttl=3600)" if has_caching else "")}

    def execute(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute the agent.

        Args:
            input_data: Input data dictionary

        Returns:
            Result dictionary
        """
        self.logger.info(f"Executing {name}", extra={{"input": input_data}})

        # Validate input
        if not self.validate_input(input_data):
            raise ValueError("Invalid input data")

        try:
            # Process data
            result = self._process(input_data)

            self.logger.info("Execution completed successfully")
            return {{
                "status": "success",
                "result": result
            }}

        except Exception as e:
            self.logger.error(f"Execution failed: {{e}}", exc_info=True)
            return {{
                "status": "error",
                "error": str(e)
            }}

    def _process(self, data: Dict[str, Any]) -> Any:
        """
        Core processing logic.

        Args:
            data: Input data

        Returns:
            Processed result
        """
        # TODO: Implement processing logic
{self._get_llm_example() if has_llm else "        # Add your processing logic here"}
        result = {{"processed": data}}

        return result

    def validate_input(self, input_data: Dict[str, Any]) -> bool:
        """
        Validate input data.

        Args:
            input_data: Data to validate

        Returns:
            True if valid
        """
        # TODO: Add validation logic
        required_fields = ["data"]  # Customize as needed

        for field in required_fields:
            if field not in input_data:
                self.logger.error(f"Missing required field: {{field}}")
                return False

        return True

    def validate_output(self, output_data: Dict[str, Any]) -> bool:
        """
        Validate output data.

        Args:
            output_data: Data to validate

        Returns:
            True if valid
        """
        return "result" in output_data


# Example usage
if __name__ == "__main__":
    agent = {name}()

    # Test data
    test_data = {{
        "data": "sample input"
    }}

    # Execute
    result = agent.execute(test_data)
    print(json.dumps(result, indent=2))

    # Batch execution
    batch_data = [
        {{"data": "input1"}},
        {{"data": "input2"}},
        {{"data": "input3"}}
    ]

    batch_results = agent.batch_execute(batch_data)
    print(f"Processed {{len(batch_results)}} items")
'''

        return template

    def _get_llm_example(self) -> str:
        """Get LLM usage example."""
        return '''        # LLM processing example
        prompt = f"Process this data: {data}"
        response = self.chat_session.chat(prompt)

        # Parse LLM response
        result = {"llm_output": response.content}
'''

    @staticmethod
    def get_pipeline_template(name: str, agents: List[str], description: str) -> str:
        """Generate pipeline template."""

        agent_imports = '\n'.join([f'from agents.{agent.lower()} import {agent}' for agent in agents])

        template = f'''"""
{name}

{description}

Generated by GreenLang Smart Generator
"""

from shared.infrastructure.agents import AgentPipeline
from shared.infrastructure.logging import Logger
{agent_imports}
from typing import Dict, Any


class {name}:
    """
    {description}

    Pipeline stages:
    {chr(10).join([f"    - {agent}" for agent in agents])}
    """

    def __init__(self, parallel: bool = False):
        """
        Initialize pipeline.

        Args:
            parallel: Run agents in parallel
        """
        self.logger = Logger(name=__name__)

        # Initialize agents
        self.agents = [
            {',\n            '.join([f'{agent}()' for agent in agents])}
        ]

        # Create pipeline
        self.pipeline = AgentPipeline(
            agents=self.agents,
            parallel=parallel
        )

    def execute(self, input_data: Dict[str, Any]) -> Dict[str, Any]:
        """
        Execute the pipeline.

        Args:
            input_data: Input data

        Returns:
            Pipeline result
        """
        self.logger.info("Starting pipeline execution")

        try:
            result = self.pipeline.execute(input_data)

            self.logger.info("Pipeline completed successfully")
            return result

        except Exception as e:
            self.logger.error(f"Pipeline failed: {{e}}", exc_info=True)
            raise


# Example usage
if __name__ == "__main__":
    pipeline = {name}(parallel=False)

    test_data = {{
        "data": "pipeline input"
    }}

    result = pipeline.execute(test_data)
    print(f"Pipeline result: {{result}}")
'''

        return template

    @staticmethod
    def get_test_template(agent_name: str) -> str:
        """Generate test template."""

        template = f'''"""
Tests for {agent_name}

Generated by GreenLang Smart Generator
"""

import pytest
import json
from agents.{agent_name.lower()} import {agent_name}


class Test{agent_name}:
    """Test suite for {agent_name}."""

    @pytest.fixture
    def agent(self):
        """Create agent instance."""
        return {agent_name}()

    def test_execute_success(self, agent):
        """Test successful execution."""
        input_data = {{
            "data": "test input"
        }}

        result = agent.execute(input_data)

        assert result["status"] == "success"
        assert "result" in result

    def test_execute_invalid_input(self, agent):
        """Test execution with invalid input."""
        input_data = {{}}

        result = agent.execute(input_data)

        assert result["status"] == "error"

    def test_validate_input_valid(self, agent):
        """Test input validation with valid data."""
        input_data = {{
            "data": "valid"
        }}

        assert agent.validate_input(input_data) is True

    def test_validate_input_invalid(self, agent):
        """Test input validation with invalid data."""
        input_data = {{}}

        assert agent.validate_input(input_data) is False

    def test_batch_execute(self, agent):
        """Test batch execution."""
        batch_data = [
            {{"data": "input1"}},
            {{"data": "input2"}},
            {{"data": "input3"}}
        ]

        results = agent.batch_execute(batch_data)

        assert len(results) == 3
        assert all(r["status"] == "success" for r in results)

    def test_validate_output(self, agent):
        """Test output validation."""
        output_data = {{
            "status": "success",
            "result": {{"processed": True}}
        }}

        assert agent.validate_output(output_data) is True


# Integration tests
class Test{agent_name}Integration:
    """Integration tests."""

    def test_end_to_end(self):
        """Test complete workflow."""
        agent = {agent_name}()

        # Real data
        real_data = {{
            "data": "production data"
        }}

        result = agent.execute(real_data)

        assert result["status"] == "success"
        # Add more assertions based on expected behavior
'''

        return template

    @staticmethod
    def get_config_template(name: str) -> str:
        """Generate configuration template."""

        template = f'''"""
Configuration for {name}

Generated by GreenLang Smart Generator
"""

import os
from shared.infrastructure.config import ConfigManager


class {name}Config:
    """Configuration management."""

    def __init__(self):
        self.config = ConfigManager()
        self.config.load()

    def get_llm_config(self) -> dict:
        """Get LLM configuration."""
        return {{
            "provider": self.config.get("LLM_PROVIDER", default="openai"),
            "model": self.config.get("LLM_MODEL", default="gpt-4"),
            "api_key": self.config.get("OPENAI_API_KEY"),
            "temperature": float(self.config.get("LLM_TEMPERATURE", default="0.7"))
        }}

    def get_cache_config(self) -> dict:
        """Get cache configuration."""
        return {{
            "ttl": int(self.config.get("CACHE_TTL", default="3600")),
            "redis_url": self.config.get("REDIS_URL", default="redis://localhost:6379")
        }}

    def get_database_config(self) -> dict:
        """Get database configuration."""
        return {{
            "url": self.config.get("DATABASE_URL"),
            "pool_size": int(self.config.get("DB_POOL_SIZE", default="10"))
        }}

    def is_production(self) -> bool:
        """Check if running in production."""
        return self.config.get("ENVIRONMENT", default="development") == "production"


# Example .env file:
"""
# LLM Configuration
LLM_PROVIDER=openai
LLM_MODEL=gpt-4
OPENAI_API_KEY=your-api-key
LLM_TEMPERATURE=0.7

# Cache Configuration
CACHE_TTL=3600
REDIS_URL=redis://localhost:6379

# Database Configuration
DATABASE_URL=postgresql://user:pass@localhost/db
DB_POOL_SIZE=10

# Environment
ENVIRONMENT=development
"""
'''

        return template


class RequirementParser:
    """Parse natural language requirements."""

    @staticmethod
    def parse(description: str) -> Dict[str, Any]:
        """
        Parse natural language description.

        Returns:
            Parsed requirements
        """
        description_lower = description.lower()

        # Detect component type
        if 'pipeline' in description_lower or 'workflow' in description_lower:
            component_type = 'pipeline'
        elif 'agent' in description_lower:
            component_type = 'agent'
        else:
            component_type = 'agent'  # Default

        # Detect features
        features = {
            'llm': any(keyword in description_lower for keyword in ['llm', 'gpt', 'ai', 'chat', 'openai', 'anthropic']),
            'validation': any(keyword in description_lower for keyword in ['validate', 'validation', 'check', 'verify']),
            'caching': any(keyword in description_lower for keyword in ['cache', 'caching', 'cached']),
            'batch': any(keyword in description_lower for keyword in ['batch', 'multiple', 'bulk']),
            'api': any(keyword in description_lower for keyword in ['api', 'rest', 'http', 'request']),
            'database': any(keyword in description_lower for keyword in ['database', 'db', 'sql', 'postgres']),
            'csv': 'csv' in description_lower,
            'excel': any(keyword in description_lower for keyword in ['excel', 'xlsx']),
            'json': 'json' in description_lower,
            'pdf': 'pdf' in description_lower,
        }

        # Extract agent names from pipeline descriptions
        agents = []
        if component_type == 'pipeline':
            # Look for "A then B then C" or "A, B, and C"
            agent_pattern = r'(\w+Agent)'
            agents = re.findall(agent_pattern, description)

        # Generate name from description
        words = re.findall(r'\b[A-Z][a-z]+|\b[a-z]+', description)
        name_words = [w.capitalize() for w in words[:3]]
        suggested_name = ''.join(name_words) + 'Agent'

        return {
            'type': component_type,
            'suggested_name': suggested_name,
            'features': features,
            'agents': agents,
            'description': description
        }


class SmartGenerator:
    """Smart code generator."""

    def __init__(self):
        self.template_lib = TemplateLibrary()
        self.parser = RequirementParser()

    def generate_from_description(self, description: str, output_dir: str = None) -> List[GeneratedCode]:
        """
        Generate code from natural language description.

        Args:
            description: Natural language description
            output_dir: Output directory

        Returns:
            List of generated code files
        """
        # Parse requirements
        requirements = self.parser.parse(description)

        print(f"Detected component type: {requirements['type']}")
        print(f"Suggested name: {requirements['suggested_name']}")
        print(f"Features: {[k for k, v in requirements['features'].items() if v]}")

        # Generate code
        generated = []

        if requirements['type'] == 'agent':
            generated.extend(self._generate_agent(requirements))
        elif requirements['type'] == 'pipeline':
            generated.extend(self._generate_pipeline(requirements))

        # Write files if output directory specified
        if output_dir:
            self._write_files(generated, output_dir)

        return generated

    def _generate_agent(self, requirements: Dict[str, Any]) -> List[GeneratedCode]:
        """Generate agent code."""
        name = requirements['suggested_name']
        description = requirements['description']
        features = requirements['features']

        generated = []

        # Main agent file
        agent_code = self.template_lib.get_agent_template(name, description, features)
        generated.append(GeneratedCode(
            filename=f"{name.lower()}.py",
            content=agent_code,
            description=f"Main agent implementation",
            file_type="agent"
        ))

        # Test file
        test_code = self.template_lib.get_test_template(name)
        generated.append(GeneratedCode(
            filename=f"test_{name.lower()}.py",
            content=test_code,
            description=f"Unit tests for {name}",
            file_type="test"
        ))

        # Config file
        config_code = self.template_lib.get_config_template(name)
        generated.append(GeneratedCode(
            filename=f"{name.lower()}_config.py",
            content=config_code,
            description=f"Configuration for {name}",
            file_type="config"
        ))

        # README
        readme = self._generate_readme(name, description, features)
        generated.append(GeneratedCode(
            filename="README.md",
            content=readme,
            description="Documentation",
            file_type="docs"
        ))

        return generated

    def _generate_pipeline(self, requirements: Dict[str, Any]) -> List[GeneratedCode]:
        """Generate pipeline code."""
        name = requirements['suggested_name'].replace('Agent', 'Pipeline')
        description = requirements['description']
        agents = requirements.get('agents', ['Agent1', 'Agent2', 'Agent3'])

        generated = []

        # Pipeline file
        pipeline_code = self.template_lib.get_pipeline_template(name, agents, description)
        generated.append(GeneratedCode(
            filename=f"{name.lower()}.py",
            content=pipeline_code,
            description=f"Pipeline implementation",
            file_type="pipeline"
        ))

        return generated

    def _generate_readme(self, name: str, description: str, features: Dict[str, bool]) -> str:
        """Generate README."""

        enabled_features = [k for k, v in features.items() if v]

        readme = f"""# {name}

{description}

## Features

{chr(10).join([f'- {feature.upper()}' for feature in enabled_features])}

## Installation

```bash
pip install -r requirements.txt
```

## Usage

```python
from agents.{name.lower()} import {name}

# Create agent
agent = {name}()

# Execute
input_data = {{
    "data": "your data"
}}

result = agent.execute(input_data)
print(result)
```

## Batch Processing

```python
# Batch execution
batch_data = [
    {{"data": "input1"}},
    {{"data": "input2"}},
    {{"data": "input3"}}
]

results = agent.batch_execute(batch_data)
```

## Testing

```bash
pytest tests/test_{name.lower()}.py -v
```

## Configuration

Set environment variables in `.env`:

```
# LLM Configuration (if using LLM features)
OPENAI_API_KEY=your-key
LLM_MODEL=gpt-4

# Cache Configuration (if using caching)
REDIS_URL=redis://localhost:6379
CACHE_TTL=3600
```

## Generated by GreenLang Smart Generator

This code was automatically generated. Customize as needed.
"""

        return readme

    def _write_files(self, generated: List[GeneratedCode], output_dir: str):
        """Write generated files to disk."""
        os.makedirs(output_dir, exist_ok=True)

        for code in generated:
            file_path = os.path.join(output_dir, code.filename)
            os.makedirs(os.path.dirname(file_path), exist_ok=True)

            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(code.content)

            print(f"Generated: {file_path}")


def main():
    """CLI entry point."""
    parser = argparse.ArgumentParser(
        description='Smart code generator using natural language',
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
Examples:
  # Generate an agent
  greenlang generate "Create an agent that validates CSV files and outputs JSON"

  # Generate with LLM
  greenlang generate "Build a reporting agent that uses GPT-4 to analyze emissions"

  # Generate pipeline
  greenlang generate "Create a pipeline with ValidationAgent, ProcessorAgent, and ExportAgent"

  # Specify output directory
  greenlang generate "CSV validator agent" --output agents/csv_validator/

  # Interactive mode
  greenlang generate --interactive
        """
    )

    parser.add_argument('description', nargs='?', help='Natural language description of what to generate')
    parser.add_argument('--output', help='Output directory')
    parser.add_argument('--interactive', action='store_true', help='Interactive mode')
    parser.add_argument('--preview', action='store_true', help='Preview without writing files')

    args = parser.parse_args()

    generator = SmartGenerator()

    # Interactive mode
    if args.interactive or not args.description:
        print("Smart Code Generator - Interactive Mode")
        print("=" * 60)
        description = input("\nDescribe what you want to generate:\n> ")
    else:
        description = args.description

    # Generate
    print(f"\nGenerating code from: '{description}'")
    print("=" * 60)

    generated = generator.generate_from_description(
        description,
        output_dir=args.output if not args.preview else None
    )

    # Display preview
    print(f"\nGenerated {len(generated)} files:")
    print("=" * 60)

    for code in generated:
        print(f"\n{code.filename} ({code.file_type})")
        print(f"  {code.description}")

        if args.preview:
            print(f"\nPreview of {code.filename}:")
            print("-" * 60)
            lines = code.content.split('\n')
            preview_lines = lines[:30]  # First 30 lines
            print('\n'.join(preview_lines))
            if len(lines) > 30:
                print(f"\n... ({len(lines) - 30} more lines)")
            print("-" * 60)

    if args.preview:
        print("\nPreview mode - no files written")
        print("Remove --preview to generate files")


if __name__ == '__main__':
    main()
