"""
Security Penetration Testing Orchestration Runner

Orchestrates all security penetration tests including:
- SQL injection tests
- XSS vulnerability scans
- CSRF protection tests
- Authentication bypass attempts
- Authorization boundary tests
- API security tests
- OWASP ZAP integration

Usage:
    python pentest_runner.py --target https://api.greenlang.io --report-output pentest_report.json
"""

import asyncio
import argparse
import json
import logging
import sys
from datetime import datetime
from pathlib import Path
from typing import Dict, Any, List
import subprocess

# Import test modules
from test_sql_injection import SQLInjectionTester
from test_xss_vulnerabilities import XSSTester
from test_csrf_protection import CSRFTester
from test_auth_bypass import AuthBypassTester
from test_authorization_boundaries import AuthorizationTester
from test_api_security import APISecurityTester

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class PentestRunner:
    """
    Comprehensive penetration testing orchestrator.

    Coordinates all security tests and generates comprehensive reports.
    """

    def __init__(self, target_url: str, api_key: str = None):
        """
        Initialize penetration testing runner.

        Args:
            target_url: Target API base URL
            api_key: API key for authentication (if required)
        """
        self.target_url = target_url
        self.api_key = api_key
        self.results = {
            "target": target_url,
            "start_time": None,
            "end_time": None,
            "duration_seconds": 0,
            "tests_run": 0,
            "vulnerabilities_found": 0,
            "test_results": {}
        }

    async def run_all_tests(self) -> Dict[str, Any]:
        """
        Run all penetration tests.

        Returns:
            Comprehensive test results
        """
        logger.info(f"Starting penetration tests against {self.target_url}")
        self.results["start_time"] = datetime.now().isoformat()
        start_time = datetime.now()

        try:
            # Run each test category
            await self._run_sql_injection_tests()
            await self._run_xss_tests()
            await self._run_csrf_tests()
            await self._run_auth_bypass_tests()
            await self._run_authorization_tests()
            await self._run_api_security_tests()

            # Run OWASP ZAP if available
            await self._run_zap_scan()

        except Exception as e:
            logger.error(f"Error during penetration testing: {e}")
            self.results["error"] = str(e)

        finally:
            end_time = datetime.now()
            self.results["end_time"] = end_time.isoformat()
            self.results["duration_seconds"] = (end_time - start_time).total_seconds()

        logger.info(f"Penetration testing completed in {self.results['duration_seconds']:.2f}s")
        logger.info(f"Vulnerabilities found: {self.results['vulnerabilities_found']}")

        return self.results

    async def _run_sql_injection_tests(self):
        """Run SQL injection tests."""
        logger.info("Running SQL injection tests...")

        try:
            tester = SQLInjectionTester()

            endpoints = [
                f"{self.target_url}/api/v1/auth/login",
                f"{self.target_url}/api/v1/packs/search",
                f"{self.target_url}/api/v1/users/search",
            ]

            results = await tester.test_all_endpoints(endpoints)

            self.results["tests_run"] += results["total_tests"]
            self.results["vulnerabilities_found"] += results["vulnerabilities_found"]
            self.results["test_results"]["sql_injection"] = results

            logger.info(
                f"SQL injection tests: {results['total_tests']} tests, "
                f"{results['vulnerabilities_found']} vulnerabilities"
            )

        except Exception as e:
            logger.error(f"SQL injection tests failed: {e}")
            self.results["test_results"]["sql_injection"] = {"error": str(e)}

    async def _run_xss_tests(self):
        """Run XSS vulnerability tests."""
        logger.info("Running XSS vulnerability tests...")

        try:
            tester = XSSTester()

            endpoints = [
                f"{self.target_url}/api/v1/search",
                f"{self.target_url}/api/v1/packs/search",
                f"{self.target_url}/api/v1/users/profile",
            ]

            results = await tester.test_all_endpoints(endpoints)

            self.results["tests_run"] += results["total_tests"]
            self.results["vulnerabilities_found"] += results["vulnerabilities_found"]
            self.results["test_results"]["xss"] = results

            logger.info(
                f"XSS tests: {results['total_tests']} tests, "
                f"{results['vulnerabilities_found']} vulnerabilities"
            )

        except Exception as e:
            logger.error(f"XSS tests failed: {e}")
            self.results["test_results"]["xss"] = {"error": str(e)}

    async def _run_csrf_tests(self):
        """Run CSRF protection tests."""
        logger.info("Running CSRF protection tests...")

        try:
            tester = CSRFTester()

            endpoints = [
                f"{self.target_url}/api/v1/users/update",
                f"{self.target_url}/api/v1/packs/upload",
                f"{self.target_url}/api/v1/tenants/create",
            ]

            results = await tester.test_csrf_protection(endpoints)

            self.results["tests_run"] += results["total_tests"]
            self.results["vulnerabilities_found"] += results["vulnerabilities_found"]
            self.results["test_results"]["csrf"] = results

            logger.info(
                f"CSRF tests: {results['total_tests']} tests, "
                f"{results['vulnerabilities_found']} vulnerabilities"
            )

        except Exception as e:
            logger.error(f"CSRF tests failed: {e}")
            self.results["test_results"]["csrf"] = {"error": str(e)}

    async def _run_auth_bypass_tests(self):
        """Run authentication bypass tests."""
        logger.info("Running authentication bypass tests...")

        try:
            tester = AuthBypassTester()

            results = {}
            results["default_credentials"] = await tester.test_default_credentials()
            results["weak_passwords"] = await tester.test_weak_password_policy()
            results["brute_force"] = await tester.test_brute_force_protection()

            # Count vulnerabilities
            vulns = sum(1 for r in results.values() if r.get("vulnerable", False))
            self.results["tests_run"] += len(results)
            self.results["vulnerabilities_found"] += vulns
            self.results["test_results"]["auth_bypass"] = results

            logger.info(f"Auth bypass tests: {len(results)} tests, {vulns} vulnerabilities")

        except Exception as e:
            logger.error(f"Auth bypass tests failed: {e}")
            self.results["test_results"]["auth_bypass"] = {"error": str(e)}

    async def _run_authorization_tests(self):
        """Run authorization boundary tests."""
        logger.info("Running authorization boundary tests...")

        try:
            tester = AuthorizationTester()

            results = {}
            results["idor"] = await tester.test_idor_vulnerabilities("test_user")
            results["vertical_escalation"] = await tester.test_vertical_privilege_escalation()
            results["horizontal_escalation"] = await tester.test_horizontal_privilege_escalation()
            results["path_traversal"] = await tester.test_path_traversal()

            vulns = sum(1 for r in results.values() if r.get("vulnerable", False))
            self.results["tests_run"] += len(results)
            self.results["vulnerabilities_found"] += vulns
            self.results["test_results"]["authorization"] = results

            logger.info(f"Authorization tests: {len(results)} tests, {vulns} vulnerabilities")

        except Exception as e:
            logger.error(f"Authorization tests failed: {e}")
            self.results["test_results"]["authorization"] = {"error": str(e)}

    async def _run_api_security_tests(self):
        """Run API security tests."""
        logger.info("Running API security tests...")

        try:
            tester = APISecurityTester()

            results = {}
            results["rate_limiting"] = await tester.test_rate_limiting(
                f"{self.target_url}/api/v1/packs"
            )
            results["graphql_introspection"] = await tester.test_graphql_introspection()
            results["mass_assignment"] = await tester.test_mass_assignment()
            results["data_exposure"] = await tester.test_excessive_data_exposure()

            vulns = sum(1 for r in results.values() if r.get("vulnerable", False))
            self.results["tests_run"] += len(results)
            self.results["vulnerabilities_found"] += vulns
            self.results["test_results"]["api_security"] = results

            logger.info(f"API security tests: {len(results)} tests, {vulns} vulnerabilities")

        except Exception as e:
            logger.error(f"API security tests failed: {e}")
            self.results["test_results"]["api_security"] = {"error": str(e)}

    async def _run_zap_scan(self):
        """Run OWASP ZAP automated scan if available."""
        logger.info("Checking for OWASP ZAP...")

        try:
            # Check if ZAP is installed
            result = subprocess.run(
                ["zap.sh", "-version"],
                capture_output=True,
                timeout=5
            )

            if result.returncode == 0:
                logger.info("Running OWASP ZAP scan...")
                await self._execute_zap_scan()
            else:
                logger.info("OWASP ZAP not available, skipping automated scan")

        except (FileNotFoundError, subprocess.TimeoutExpired):
            logger.info("OWASP ZAP not found, skipping automated scan")

    async def _execute_zap_scan(self):
        """Execute OWASP ZAP scan."""
        zap_config = Path(__file__).parent / "zap_config.yaml"

        try:
            # Run ZAP baseline scan
            result = subprocess.run(
                [
                    "zap-baseline.py",
                    "-t", self.target_url,
                    "-c", str(zap_config),
                    "-J", "zap_report.json",
                ],
                capture_output=True,
                timeout=600  # 10 minute timeout
            )

            if result.returncode == 0:
                # Parse ZAP results
                with open("zap_report.json") as f:
                    zap_results = json.load(f)

                self.results["test_results"]["zap_scan"] = zap_results
                logger.info("OWASP ZAP scan completed")

        except Exception as e:
            logger.error(f"ZAP scan failed: {e}")

    def generate_json_report(self, output_path: str):
        """Generate JSON report."""
        with open(output_path, 'w') as f:
            json.dump(self.results, f, indent=2)

        logger.info(f"JSON report saved to {output_path}")

    def generate_markdown_report(self, output_path: str):
        """Generate Markdown report."""
        report = f"""# Security Penetration Test Report

## Executive Summary

- **Target**: {self.results['target']}
- **Test Date**: {self.results['start_time']}
- **Duration**: {self.results['duration_seconds']:.2f} seconds
- **Total Tests**: {self.results['tests_run']}
- **Vulnerabilities Found**: {self.results['vulnerabilities_found']}

## Security Status

{'ðŸ”´ **CRITICAL**: Vulnerabilities found!' if self.results['vulnerabilities_found'] > 0 else 'ðŸŸ¢ **SECURE**: No vulnerabilities found'}

## Test Results

### SQL Injection Tests
{self._format_test_section('sql_injection')}

### XSS Vulnerability Tests
{self._format_test_section('xss')}

### CSRF Protection Tests
{self._format_test_section('csrf')}

### Authentication Bypass Tests
{self._format_test_section('auth_bypass')}

### Authorization Boundary Tests
{self._format_test_section('authorization')}

### API Security Tests
{self._format_test_section('api_security')}

## Recommendations

1. **Immediate Actions** (Critical vulnerabilities)
2. **Short-term Actions** (High severity)
3. **Long-term Actions** (Medium/Low severity)

## Compliance

- OWASP Top 10: Assessed
- PCI DSS: Security requirements validated
- CWE: Common weakness enumeration checked

## Next Steps

1. Remediate all critical vulnerabilities immediately
2. Schedule follow-up pentests after fixes
3. Implement continuous security monitoring
4. Regular security training for development team
"""

        with open(output_path, 'w') as f:
            f.write(report)

        logger.info(f"Markdown report saved to {output_path}")

    def _format_test_section(self, section_name: str) -> str:
        """Format test section for markdown report."""
        section_data = self.results["test_results"].get(section_name, {})

        if not section_data:
            return "*No tests run*"

        if "error" in section_data:
            return f"*Error: {section_data['error']}*"

        vulns = section_data.get("vulnerabilities_found", 0)
        tests = section_data.get("total_tests", len(section_data))

        status = "âœ… PASS" if vulns == 0 else f"âŒ FAIL ({vulns} vulnerabilities)"

        return f"- Tests run: {tests}\n- Status: {status}"


async def main():
    """Main entry point for penetration testing."""
    parser = argparse.ArgumentParser(
        description="GreenLang Security Penetration Testing Runner"
    )
    parser.add_argument(
        "--target",
        required=True,
        help="Target API base URL"
    )
    parser.add_argument(
        "--api-key",
        help="API key for authentication"
    )
    parser.add_argument(
        "--json-output",
        default="pentest_report.json",
        help="JSON report output path"
    )
    parser.add_argument(
        "--md-output",
        default="pentest_report.md",
        help="Markdown report output path"
    )

    args = parser.parse_args()

    # Run penetration tests
    runner = PentestRunner(args.target, args.api_key)
    results = await runner.run_all_tests()

    # Generate reports
    runner.generate_json_report(args.json_output)
    runner.generate_markdown_report(args.md_output)

    # Exit with error code if vulnerabilities found
    sys.exit(1 if results["vulnerabilities_found"] > 0 else 0)


if __name__ == "__main__":
    asyncio.run(main())
