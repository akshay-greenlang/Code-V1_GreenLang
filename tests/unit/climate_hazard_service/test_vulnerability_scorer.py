# -*- coding: utf-8 -*-
"""
Unit tests for VulnerabilityScorerEngine (Engine 5 of 7).

AGENT-DATA-020: Climate Hazard Connector
Tests vulnerability scoring, sector scoring, sensitivity/adaptive profiles,
residual risk calculations, entity ranking, score listing, statistics,
and engine lifecycle management.

Target: 85%+ code coverage with 90+ test functions.
"""

from __future__ import annotations

import copy
import threading
import time
from typing import Any, Dict, List
from unittest.mock import MagicMock, patch

import pytest

from greenlang.climate_hazard.vulnerability_scorer import (
    DEFAULT_ADAPTIVE_CAPACITY_INDICATORS,
    HAZARD_SECTOR_MULTIPLIERS,
    SCENARIO_MULTIPLIERS,
    SECTOR_SENSITIVITY_FACTORS,
    TIME_HORIZON_MULTIPLIERS,
    VALID_HAZARD_TYPES,
    VALID_SECTORS,
    AdaptationEffectivenessLevel,
    AdaptiveCapacityProfile,
    EntityRanking,
    ResidualRiskResult,
    SensitivityProfile,
    VulnerabilityLevel,
    VulnerabilityScore,
    VulnerabilityScorerEngine,
    _classify_effectiveness,
    _classify_vulnerability,
    _clamp,
    _safe_mean,
)


# ---------------------------------------------------------------------------
# Fixtures
# ---------------------------------------------------------------------------


@pytest.fixture
def engine() -> VulnerabilityScorerEngine:
    """Return a fresh VulnerabilityScorerEngine for each test."""
    return VulnerabilityScorerEngine()


@pytest.fixture
def sensitivity_factors() -> Dict[str, float]:
    """Standard sensitivity factors."""
    return {"crop_diversity": 0.3, "irrigation_coverage": 0.7}


@pytest.fixture
def adaptive_capacity() -> Dict[str, float]:
    """Standard adaptive capacity indicators."""
    return {"financial_reserves": 0.6, "insurance_coverage": 0.8}


@pytest.fixture
def scored_entity(engine, sensitivity_factors, adaptive_capacity) -> Dict[str, Any]:
    """Score a vulnerability and return the result."""
    return engine.score_vulnerability(
        entity_id="entity-001",
        hazard_type="flood",
        exposure_score=65.0,
        sensitivity_factors=sensitivity_factors,
        adaptive_capacity_indicators=adaptive_capacity,
    )


# ===================================================================
# Helper function tests
# ===================================================================


class TestHelperFunctions:
    """Tests for module-level helper functions."""

    def test_safe_mean_empty(self):
        """Empty list returns 0.0."""
        assert _safe_mean([]) == 0.0

    def test_safe_mean_single(self):
        """Single value returns that value."""
        assert _safe_mean([5.0]) == pytest.approx(5.0)

    def test_safe_mean_multiple(self):
        """Multiple values return arithmetic mean."""
        assert _safe_mean([2.0, 4.0, 6.0]) == pytest.approx(4.0)

    def test_clamp_within_range(self):
        """Value within range is unchanged."""
        assert _clamp(50.0) == 50.0

    def test_clamp_below(self):
        """Value below lower bound is clamped."""
        assert _clamp(-10.0) == 0.0

    def test_clamp_above(self):
        """Value above upper bound is clamped."""
        assert _clamp(150.0) == 100.0

    def test_clamp_custom_bounds(self):
        """Custom bounds are respected."""
        assert _clamp(0.5, 0.0, 1.0) == 0.5
        assert _clamp(-0.5, 0.0, 1.0) == 0.0
        assert _clamp(1.5, 0.0, 1.0) == 1.0


# ===================================================================
# Classification function tests
# ===================================================================


class TestClassificationFunctions:
    """Tests for vulnerability and effectiveness classification."""

    def test_classify_negligible(self):
        """Score < 20 is NEGLIGIBLE."""
        assert _classify_vulnerability(10.0) == VulnerabilityLevel.NEGLIGIBLE

    def test_classify_low(self):
        """Score 20-40 is LOW."""
        assert _classify_vulnerability(30.0) == VulnerabilityLevel.LOW

    def test_classify_moderate(self):
        """Score 40-60 is MODERATE."""
        assert _classify_vulnerability(50.0) == VulnerabilityLevel.MODERATE

    def test_classify_high(self):
        """Score 60-80 is HIGH."""
        assert _classify_vulnerability(70.0) == VulnerabilityLevel.HIGH

    def test_classify_critical(self):
        """Score >= 80 is CRITICAL."""
        assert _classify_vulnerability(90.0) == VulnerabilityLevel.CRITICAL

    def test_classify_boundary_20(self):
        """Score exactly 20 is LOW."""
        assert _classify_vulnerability(20.0) == VulnerabilityLevel.LOW

    def test_classify_boundary_40(self):
        """Score exactly 40 is MODERATE."""
        assert _classify_vulnerability(40.0) == VulnerabilityLevel.MODERATE

    def test_classify_boundary_60(self):
        """Score exactly 60 is HIGH."""
        assert _classify_vulnerability(60.0) == VulnerabilityLevel.HIGH

    def test_classify_boundary_80(self):
        """Score exactly 80 is CRITICAL."""
        assert _classify_vulnerability(80.0) == VulnerabilityLevel.CRITICAL

    def test_classify_boundary_0(self):
        """Score 0 is NEGLIGIBLE."""
        assert _classify_vulnerability(0.0) == VulnerabilityLevel.NEGLIGIBLE

    def test_classify_boundary_100(self):
        """Score 100 is CRITICAL."""
        assert _classify_vulnerability(100.0) == VulnerabilityLevel.CRITICAL

    def test_effectiveness_very_high(self):
        """Reduction >= 80% is VERY_HIGH."""
        assert _classify_effectiveness(85.0) == AdaptationEffectivenessLevel.VERY_HIGH

    def test_effectiveness_high(self):
        """Reduction 60-80% is HIGH."""
        assert _classify_effectiveness(70.0) == AdaptationEffectivenessLevel.HIGH

    def test_effectiveness_moderate(self):
        """Reduction 40-60% is MODERATE."""
        assert _classify_effectiveness(50.0) == AdaptationEffectivenessLevel.MODERATE

    def test_effectiveness_low(self):
        """Reduction 20-40% is LOW."""
        assert _classify_effectiveness(30.0) == AdaptationEffectivenessLevel.LOW

    def test_effectiveness_negligible(self):
        """Reduction < 20% is NEGLIGIBLE."""
        assert _classify_effectiveness(10.0) == AdaptationEffectivenessLevel.NEGLIGIBLE


# ===================================================================
# Data model tests
# ===================================================================


class TestDataModels:
    """Tests for dataclass models."""

    def test_vulnerability_score_to_dict(self):
        """VulnerabilityScore.to_dict serializes correctly."""
        vs = VulnerabilityScore(
            score_id="VS-test",
            entity_id="e-001",
            hazard_type="flood",
            vulnerability_score=55.0,
            vulnerability_level="moderate",
        )
        d = vs.to_dict()
        assert d["score_id"] == "VS-test"
        assert d["vulnerability_score"] == 55.0

    def test_sensitivity_profile_to_dict(self):
        """SensitivityProfile.to_dict serializes correctly."""
        sp = SensitivityProfile(
            profile_id="SP-test",
            entity_id="e-001",
            sector="agriculture",
            factors={"a": 0.5},
            overall_sensitivity=0.5,
        )
        d = sp.to_dict()
        assert d["profile_id"] == "SP-test"
        assert d["factors"] == {"a": 0.5}

    def test_adaptive_capacity_profile_to_dict(self):
        """AdaptiveCapacityProfile.to_dict serializes correctly."""
        acp = AdaptiveCapacityProfile(
            profile_id="ACP-test",
            entity_id="e-001",
            indicators={"b": 0.6},
            overall_capacity=0.6,
        )
        d = acp.to_dict()
        assert d["profile_id"] == "ACP-test"
        assert d["indicators"] == {"b": 0.6}

    def test_residual_risk_to_dict(self):
        """ResidualRiskResult.to_dict serializes correctly."""
        rr = ResidualRiskResult(
            result_id="RR-test",
            original_score=80.0,
            residual_score=40.0,
            risk_reduction_pct=50.0,
        )
        d = rr.to_dict()
        assert d["result_id"] == "RR-test"
        assert d["risk_reduction_pct"] == 50.0

    def test_entity_ranking_to_dict(self):
        """EntityRanking.to_dict serializes correctly."""
        er = EntityRanking(
            rank=1,
            entity_id="e-001",
            vulnerability_score=90.0,
            vulnerability_level="critical",
            percentile=100.0,
        )
        d = er.to_dict()
        assert d["rank"] == 1
        assert d["percentile"] == 100.0


# ===================================================================
# Engine initialization tests
# ===================================================================


class TestEngineInit:
    """Tests for engine construction."""

    def test_default_init(self, engine):
        """Default engine initialises with empty state."""
        stats = engine.get_statistics()
        assert stats["total_scores"] == 0
        assert stats["total_profiles"] == 0
        assert stats["total_errors"] == 0

    def test_init_with_exposure_engine(self):
        """Engine accepts optional exposure_engine."""
        mock = MagicMock()
        eng = VulnerabilityScorerEngine(exposure_engine=mock)
        assert eng._exposure_engine is mock

    def test_init_custom_genesis_hash(self):
        """Custom genesis hash is accepted."""
        eng = VulnerabilityScorerEngine(genesis_hash="test-genesis")
        assert eng is not None

    def test_default_weights(self, engine):
        """Default vulnerability weights match expected values."""
        stats = engine.get_statistics()
        weights = stats["config_weights"]
        assert weights["exposure"] == pytest.approx(0.40)
        assert weights["sensitivity"] == pytest.approx(0.35)
        assert weights["adaptive_capacity"] == pytest.approx(0.25)


# ===================================================================
# score_vulnerability tests
# ===================================================================


class TestScoreVulnerability:
    """Tests for score_vulnerability."""

    def test_basic_scoring(self, scored_entity):
        """Basic scoring returns expected structure."""
        assert "score_id" in scored_entity
        assert scored_entity["entity_id"] == "entity-001"
        assert scored_entity["hazard_type"] == "flood"
        assert 0.0 <= scored_entity["vulnerability_score"] <= 100.0
        assert scored_entity["vulnerability_level"] in [
            v.value for v in VulnerabilityLevel
        ]
        assert len(scored_entity["provenance_hash"]) == 64

    def test_exposure_score_range(self, engine, sensitivity_factors, adaptive_capacity):
        """Exposure score is reflected in vulnerability."""
        low = engine.score_vulnerability(
            entity_id="low",
            hazard_type="flood",
            exposure_score=10.0,
            sensitivity_factors=sensitivity_factors,
            adaptive_capacity_indicators=adaptive_capacity,
        )
        high = engine.score_vulnerability(
            entity_id="high",
            hazard_type="flood",
            exposure_score=90.0,
            sensitivity_factors=sensitivity_factors,
            adaptive_capacity_indicators=adaptive_capacity,
        )
        assert high["vulnerability_score"] > low["vulnerability_score"]

    def test_high_adaptive_reduces_vulnerability(self, engine, sensitivity_factors):
        """High adaptive capacity reduces vulnerability."""
        low_adapt = engine.score_vulnerability(
            entity_id="la",
            hazard_type="flood",
            exposure_score=60.0,
            sensitivity_factors=sensitivity_factors,
            adaptive_capacity_indicators={"a": 0.1},
        )
        high_adapt = engine.score_vulnerability(
            entity_id="ha",
            hazard_type="flood",
            exposure_score=60.0,
            sensitivity_factors=sensitivity_factors,
            adaptive_capacity_indicators={"a": 0.9},
        )
        assert high_adapt["vulnerability_score"] < low_adapt["vulnerability_score"]

    def test_high_sensitivity_increases_vulnerability(self, engine, adaptive_capacity):
        """High sensitivity increases vulnerability."""
        low_sens = engine.score_vulnerability(
            entity_id="ls",
            hazard_type="flood",
            exposure_score=60.0,
            sensitivity_factors={"a": 0.1},
            adaptive_capacity_indicators=adaptive_capacity,
        )
        high_sens = engine.score_vulnerability(
            entity_id="hs",
            hazard_type="flood",
            exposure_score=60.0,
            sensitivity_factors={"a": 0.9},
            adaptive_capacity_indicators=adaptive_capacity,
        )
        assert high_sens["vulnerability_score"] > low_sens["vulnerability_score"]

    def test_empty_entity_id_raises(self, engine, sensitivity_factors, adaptive_capacity):
        """Empty entity_id raises ValueError."""
        with pytest.raises(ValueError, match="non-empty string"):
            engine.score_vulnerability(
                entity_id="",
                hazard_type="flood",
                exposure_score=50.0,
                sensitivity_factors=sensitivity_factors,
                adaptive_capacity_indicators=adaptive_capacity,
            )

    def test_non_numeric_exposure_raises(self, engine, sensitivity_factors, adaptive_capacity):
        """Non-numeric exposure_score raises TypeError."""
        with pytest.raises(TypeError, match="numeric"):
            engine.score_vulnerability(
                entity_id="e-001",
                hazard_type="flood",
                exposure_score="not_a_number",
                sensitivity_factors=sensitivity_factors,
                adaptive_capacity_indicators=adaptive_capacity,
            )

    def test_empty_sensitivity_factors_raises(self, engine, adaptive_capacity):
        """Empty sensitivity factors raises ValueError."""
        with pytest.raises(ValueError, match="must not be empty"):
            engine.score_vulnerability(
                entity_id="e-001",
                hazard_type="flood",
                exposure_score=50.0,
                sensitivity_factors={},
                adaptive_capacity_indicators=adaptive_capacity,
            )

    def test_empty_adaptive_indicators_raises(self, engine, sensitivity_factors):
        """Empty adaptive capacity indicators raises ValueError."""
        with pytest.raises(ValueError, match="must not be empty"):
            engine.score_vulnerability(
                entity_id="e-001",
                hazard_type="flood",
                exposure_score=50.0,
                sensitivity_factors=sensitivity_factors,
                adaptive_capacity_indicators={},
            )

    def test_sensitivity_not_dict_raises(self, engine, adaptive_capacity):
        """Non-dict sensitivity factors raises TypeError."""
        with pytest.raises(TypeError, match="must be a dict"):
            engine.score_vulnerability(
                entity_id="e-001",
                hazard_type="flood",
                exposure_score=50.0,
                sensitivity_factors="not_a_dict",
                adaptive_capacity_indicators=adaptive_capacity,
            )

    def test_exposure_clamped_above_100(self, engine, sensitivity_factors, adaptive_capacity):
        """Exposure score > 100 is clamped to 100."""
        result = engine.score_vulnerability(
            entity_id="e-clamp",
            hazard_type="flood",
            exposure_score=150.0,
            sensitivity_factors=sensitivity_factors,
            adaptive_capacity_indicators=adaptive_capacity,
        )
        assert result["exposure_score"] == pytest.approx(100.0)

    def test_exposure_clamped_below_0(self, engine, sensitivity_factors, adaptive_capacity):
        """Exposure score < 0 is clamped to 0."""
        result = engine.score_vulnerability(
            entity_id="e-clamp-lo",
            hazard_type="flood",
            exposure_score=-10.0,
            sensitivity_factors=sensitivity_factors,
            adaptive_capacity_indicators=adaptive_capacity,
        )
        assert result["exposure_score"] == pytest.approx(0.0)

    def test_factor_contributions_present(self, scored_entity):
        """Factor contributions breakdown is present."""
        contrib = scored_entity["factor_contributions"]
        assert "weights" in contrib
        assert "component_scores" in contrib
        assert "component_contributions" in contrib
        assert "sensitivity_factors" in contrib
        assert "adaptive_capacity_indicators" in contrib
        assert "formula" in contrib

    def test_default_scenario_applied(self, scored_entity):
        """Default scenario (SSP2-4.5) is applied when none specified."""
        assert scored_entity["scenario"] == "SSP2-4.5"

    def test_default_time_horizon_applied(self, scored_entity):
        """Default time horizon (MID_TERM) is applied when none specified."""
        assert scored_entity["time_horizon"] == "MID_TERM"

    def test_custom_scenario(self, engine, sensitivity_factors, adaptive_capacity):
        """Custom scenario is stored and applied."""
        result = engine.score_vulnerability(
            entity_id="e-custom",
            hazard_type="flood",
            exposure_score=50.0,
            sensitivity_factors=sensitivity_factors,
            adaptive_capacity_indicators=adaptive_capacity,
            scenario="SSP5-8.5",
        )
        assert result["scenario"] == "SSP5-8.5"

    def test_custom_time_horizon(self, engine, sensitivity_factors, adaptive_capacity):
        """Custom time horizon is stored and applied."""
        result = engine.score_vulnerability(
            entity_id="e-custom-h",
            hazard_type="flood",
            exposure_score=50.0,
            sensitivity_factors=sensitivity_factors,
            adaptive_capacity_indicators=adaptive_capacity,
            time_horizon="LONG_TERM",
        )
        assert result["time_horizon"] == "LONG_TERM"

    def test_vulnerability_clamped_to_0_100(self, engine):
        """Vulnerability score is always in [0, 100]."""
        result = engine.score_vulnerability(
            entity_id="e-extreme",
            hazard_type="flood",
            exposure_score=100.0,
            sensitivity_factors={"a": 1.0},
            adaptive_capacity_indicators={"b": 0.01},
        )
        assert 0.0 <= result["vulnerability_score"] <= 100.0

    def test_all_valid_hazard_types(self, engine, sensitivity_factors, adaptive_capacity):
        """All 13 hazard types produce valid scores."""
        for ht in VALID_HAZARD_TYPES:
            result = engine.score_vulnerability(
                entity_id=f"e-{ht}",
                hazard_type=ht,
                exposure_score=50.0,
                sensitivity_factors=sensitivity_factors,
                adaptive_capacity_indicators=adaptive_capacity,
            )
            assert 0.0 <= result["vulnerability_score"] <= 100.0

    def test_score_stored_and_retrievable(self, engine, scored_entity):
        """Score is stored and retrievable by ID."""
        stored = engine.get_vulnerability_score(scored_entity["score_id"])
        assert stored is not None
        assert stored["score_id"] == scored_entity["score_id"]

    def test_stats_incremented(self, engine, scored_entity):
        """Total scored counter is incremented."""
        stats = engine.get_statistics()
        assert stats["total_scores"] == 1

    def test_sensitivity_factor_values_clamped(self, engine, adaptive_capacity):
        """Sensitivity factor values outside [0, 1] are clamped."""
        result = engine.score_vulnerability(
            entity_id="e-clamp-sens",
            hazard_type="flood",
            exposure_score=50.0,
            sensitivity_factors={"a": 1.5, "b": -0.2},
            adaptive_capacity_indicators=adaptive_capacity,
        )
        # Should not error; values are clamped internally
        assert 0.0 <= result["vulnerability_score"] <= 100.0


# ===================================================================
# score_sector_vulnerability tests
# ===================================================================


class TestScoreSectorVulnerability:
    """Tests for score_sector_vulnerability."""

    def test_basic_sector_scoring(self, engine):
        """Sector scoring returns expected structure."""
        result = engine.score_sector_vulnerability(
            sector="agriculture",
            location="Iowa, USA",
            hazard_type="drought",
            exposure_score=70.0,
        )
        assert result["entity_id"].startswith("sector:agriculture:")
        assert result["hazard_type"] == "drought"
        assert 0.0 <= result["vulnerability_score"] <= 100.0
        assert len(result["provenance_hash"]) == 64

    def test_all_valid_sectors(self, engine):
        """All 8 sectors produce valid scores."""
        for sector in VALID_SECTORS:
            result = engine.score_sector_vulnerability(
                sector=sector,
                location="TestCity",
                hazard_type="flood",
                exposure_score=50.0,
            )
            assert 0.0 <= result["vulnerability_score"] <= 100.0

    def test_hazard_sector_multiplier_applied(self, engine):
        """Agriculture/drought has higher sensitivity than financial/drought."""
        agri = engine.score_sector_vulnerability(
            sector="agriculture",
            location="Farm",
            hazard_type="drought",
            exposure_score=50.0,
        )
        fin = engine.score_sector_vulnerability(
            sector="financial",
            location="Bank",
            hazard_type="drought",
            exposure_score=50.0,
        )
        # Agriculture has 1.35 multiplier for drought vs 1.0 for financial
        assert agri["vulnerability_score"] > fin["vulnerability_score"]

    def test_empty_sector_raises(self, engine):
        """Empty sector raises ValueError."""
        with pytest.raises(ValueError, match="non-empty string"):
            engine.score_sector_vulnerability(
                sector="",
                location="Test",
                hazard_type="flood",
                exposure_score=50.0,
            )

    def test_empty_location_raises(self, engine):
        """Empty location raises ValueError."""
        with pytest.raises(ValueError, match="non-empty string"):
            engine.score_sector_vulnerability(
                sector="agriculture",
                location="",
                hazard_type="flood",
                exposure_score=50.0,
            )

    def test_non_numeric_exposure_raises(self, engine):
        """Non-numeric exposure_score raises TypeError."""
        with pytest.raises(TypeError, match="numeric"):
            engine.score_sector_vulnerability(
                sector="agriculture",
                location="Test",
                hazard_type="flood",
                exposure_score="not_a_number",
            )

    def test_sector_factor_contributions(self, engine):
        """Sector scoring includes sector-specific contribution metadata."""
        result = engine.score_sector_vulnerability(
            sector="agriculture",
            location="Test",
            hazard_type="drought",
            exposure_score=50.0,
        )
        contrib = result["factor_contributions"]
        assert "sector" in contrib
        assert contrib["sector"] == "agriculture"
        assert "hazard_sector_multiplier" in contrib

    def test_custom_scenario_and_horizon(self, engine):
        """Custom scenario and horizon are applied."""
        result = engine.score_sector_vulnerability(
            sector="agriculture",
            location="Test",
            hazard_type="flood",
            exposure_score=50.0,
            scenario="SSP5-8.5",
            time_horizon="LONG_TERM",
        )
        assert result["scenario"] == "SSP5-8.5"
        assert result["time_horizon"] == "LONG_TERM"


# ===================================================================
# create_sensitivity_profile tests
# ===================================================================


class TestCreateSensitivityProfile:
    """Tests for create_sensitivity_profile."""

    def test_basic_profile(self, engine):
        """Profile is created with correct structure."""
        result = engine.create_sensitivity_profile(
            entity_id="e-001",
            sector="agriculture",
            factors={"crop_diversity": 0.3, "irrigation_coverage": 0.7},
        )
        assert result["profile_id"].startswith("SP-")
        assert result["entity_id"] == "e-001"
        assert result["sector"] == "agriculture"
        assert result["overall_sensitivity"] == pytest.approx(0.5)
        assert len(result["provenance_hash"]) == 64

    def test_empty_entity_id_raises(self, engine):
        """Empty entity_id raises ValueError."""
        with pytest.raises(ValueError, match="non-empty string"):
            engine.create_sensitivity_profile("", "agriculture", {"a": 0.5})

    def test_empty_factors_raises(self, engine):
        """Empty factors dict raises ValueError."""
        with pytest.raises(ValueError, match="must not be empty"):
            engine.create_sensitivity_profile("e-001", "agriculture", {})

    def test_profile_stored(self, engine):
        """Created profile is retrievable."""
        result = engine.create_sensitivity_profile(
            "e-001", "agriculture", {"a": 0.5}
        )
        stored = engine.get_sensitivity_profile(result["profile_id"])
        assert stored is not None
        assert stored["profile_id"] == result["profile_id"]

    def test_profiles_counter_incremented(self, engine):
        """Total profiles counter is incremented."""
        engine.create_sensitivity_profile("e-001", "agriculture", {"a": 0.5})
        stats = engine.get_statistics()
        assert stats["total_profiles"] >= 1


# ===================================================================
# get_sensitivity_profile tests
# ===================================================================


class TestGetSensitivityProfile:
    """Tests for get_sensitivity_profile."""

    def test_existing_profile(self, engine):
        """Existing profile is retrieved."""
        created = engine.create_sensitivity_profile(
            "e-001", "agriculture", {"a": 0.5}
        )
        result = engine.get_sensitivity_profile(created["profile_id"])
        assert result is not None
        assert result["entity_id"] == "e-001"

    def test_non_existent_profile(self, engine):
        """Non-existent profile returns None."""
        assert engine.get_sensitivity_profile("DOES_NOT_EXIST") is None

    def test_empty_id(self, engine):
        """Empty profile_id returns None."""
        assert engine.get_sensitivity_profile("") is None


# ===================================================================
# create_adaptive_capacity_profile tests
# ===================================================================


class TestCreateAdaptiveCapacityProfile:
    """Tests for create_adaptive_capacity_profile."""

    def test_basic_profile(self, engine):
        """Profile is created with correct structure."""
        result = engine.create_adaptive_capacity_profile(
            entity_id="e-001",
            indicators={"financial_reserves": 0.6, "insurance_coverage": 0.8},
        )
        assert result["profile_id"].startswith("ACP-")
        assert result["entity_id"] == "e-001"
        assert result["overall_capacity"] == pytest.approx(0.7)
        assert len(result["provenance_hash"]) == 64

    def test_empty_entity_id_raises(self, engine):
        """Empty entity_id raises ValueError."""
        with pytest.raises(ValueError, match="non-empty string"):
            engine.create_adaptive_capacity_profile("", {"a": 0.5})

    def test_empty_indicators_raises(self, engine):
        """Empty indicators dict raises ValueError."""
        with pytest.raises(ValueError, match="must not be empty"):
            engine.create_adaptive_capacity_profile("e-001", {})

    def test_profile_stored(self, engine):
        """Created profile is retrievable."""
        result = engine.create_adaptive_capacity_profile(
            "e-001", {"a": 0.5}
        )
        stored = engine.get_adaptive_capacity_profile(result["profile_id"])
        assert stored is not None
        assert stored["profile_id"] == result["profile_id"]


# ===================================================================
# get_adaptive_capacity_profile tests
# ===================================================================


class TestGetAdaptiveCapacityProfile:
    """Tests for get_adaptive_capacity_profile."""

    def test_existing_profile(self, engine):
        """Existing profile is retrieved."""
        created = engine.create_adaptive_capacity_profile(
            "e-001", {"a": 0.5}
        )
        result = engine.get_adaptive_capacity_profile(created["profile_id"])
        assert result is not None

    def test_non_existent_profile(self, engine):
        """Non-existent profile returns None."""
        assert engine.get_adaptive_capacity_profile("DOES_NOT_EXIST") is None

    def test_empty_id(self, engine):
        """Empty profile_id returns None."""
        assert engine.get_adaptive_capacity_profile("") is None


# ===================================================================
# calculate_residual_risk tests
# ===================================================================


class TestCalculateResidualRisk:
    """Tests for calculate_residual_risk."""

    def test_basic_residual_risk(self, engine):
        """Basic residual risk calculation works."""
        result = engine.calculate_residual_risk(
            vulnerability_score=80.0,
            adaptation_measures=[
                {"measure_name": "flood barriers", "effectiveness": 0.5},
            ],
        )
        assert result["result_id"].startswith("RR-")
        assert result["original_score"] == pytest.approx(80.0)
        assert result["residual_score"] == pytest.approx(40.0)
        assert result["risk_reduction_pct"] == pytest.approx(50.0)
        assert result["effectiveness_level"] == "moderate"

    def test_multiple_measures(self, engine):
        """Multiple measures are applied sequentially."""
        result = engine.calculate_residual_risk(
            vulnerability_score=100.0,
            adaptation_measures=[
                {"measure_name": "measure1", "effectiveness": 0.5},
                {"measure_name": "measure2", "effectiveness": 0.5},
            ],
        )
        # 100 * (1-0.5) * (1-0.5) = 25
        assert result["residual_score"] == pytest.approx(25.0)
        assert result["risk_reduction_pct"] == pytest.approx(75.0)

    def test_zero_effectiveness(self, engine):
        """Zero effectiveness means no reduction."""
        result = engine.calculate_residual_risk(
            vulnerability_score=80.0,
            adaptation_measures=[
                {"measure_name": "nothing", "effectiveness": 0.0},
            ],
        )
        assert result["residual_score"] == pytest.approx(80.0)
        assert result["risk_reduction_pct"] == pytest.approx(0.0)
        assert result["effectiveness_level"] == "negligible"

    def test_full_effectiveness(self, engine):
        """100% effectiveness eliminates all risk."""
        result = engine.calculate_residual_risk(
            vulnerability_score=80.0,
            adaptation_measures=[
                {"measure_name": "perfect", "effectiveness": 1.0},
            ],
        )
        assert result["residual_score"] == pytest.approx(0.0)
        assert result["risk_reduction_pct"] == pytest.approx(100.0)
        assert result["effectiveness_level"] == "very_high"

    def test_non_numeric_score_raises(self, engine):
        """Non-numeric vulnerability_score raises TypeError."""
        with pytest.raises(TypeError, match="numeric"):
            engine.calculate_residual_risk(
                vulnerability_score="not_a_number",
                adaptation_measures=[{"measure_name": "a", "effectiveness": 0.5}],
            )

    def test_empty_measures_raises(self, engine):
        """Empty adaptation_measures raises ValueError."""
        with pytest.raises(ValueError, match="must not be empty"):
            engine.calculate_residual_risk(
                vulnerability_score=80.0,
                adaptation_measures=[],
            )

    def test_non_list_measures_raises(self, engine):
        """Non-list adaptation_measures raises TypeError."""
        with pytest.raises(TypeError, match="must be a list"):
            engine.calculate_residual_risk(
                vulnerability_score=80.0,
                adaptation_measures="not_a_list",
            )

    def test_effectiveness_clamped(self, engine):
        """Effectiveness outside [0, 1] is clamped."""
        result = engine.calculate_residual_risk(
            vulnerability_score=100.0,
            adaptation_measures=[
                {"measure_name": "over", "effectiveness": 1.5},
            ],
        )
        # Clamped to 1.0
        assert result["residual_score"] == pytest.approx(0.0)

    def test_entity_id_optional(self, engine):
        """Entity ID is optional; defaults to 'anonymous'."""
        result = engine.calculate_residual_risk(
            vulnerability_score=80.0,
            adaptation_measures=[
                {"measure_name": "a", "effectiveness": 0.5},
            ],
        )
        assert result["entity_id"] == "anonymous"

    def test_entity_id_provided(self, engine):
        """Entity ID is stored when provided."""
        result = engine.calculate_residual_risk(
            vulnerability_score=80.0,
            adaptation_measures=[
                {"measure_name": "a", "effectiveness": 0.5},
            ],
            entity_id="farm-001",
        )
        assert result["entity_id"] == "farm-001"

    def test_cost_usd_tracked(self, engine):
        """Cost USD is tracked in applied measures."""
        result = engine.calculate_residual_risk(
            vulnerability_score=80.0,
            adaptation_measures=[
                {"measure_name": "barrier", "effectiveness": 0.5, "cost_usd": 10000},
            ],
        )
        assert result["measures_applied"][0]["cost_usd"] == 10000.0

    def test_residual_calc_counter(self, engine):
        """Residual calculation counter is incremented."""
        engine.calculate_residual_risk(
            vulnerability_score=80.0,
            adaptation_measures=[{"measure_name": "a", "effectiveness": 0.5}],
        )
        stats = engine.get_statistics()
        assert stats["total_residual_calcs"] == 1

    def test_zero_original_score(self, engine):
        """Zero original score produces zero reduction."""
        result = engine.calculate_residual_risk(
            vulnerability_score=0.0,
            adaptation_measures=[{"measure_name": "a", "effectiveness": 0.5}],
        )
        assert result["residual_score"] == pytest.approx(0.0)
        assert result["risk_reduction_pct"] == pytest.approx(0.0)

    def test_non_dict_measures_skipped(self, engine):
        """Non-dict items in measures list are skipped."""
        result = engine.calculate_residual_risk(
            vulnerability_score=80.0,
            adaptation_measures=[
                "not_a_dict",
                {"measure_name": "real", "effectiveness": 0.5},
            ],
        )
        assert len(result["measures_applied"]) == 1


# ===================================================================
# rank_entities tests
# ===================================================================


class TestRankEntities:
    """Tests for rank_entities."""

    def test_basic_ranking(self, engine):
        """Entities are ranked by vulnerability score descending."""
        entity_scores = [
            {"entity_id": "e-low", "vulnerability_score": 20.0},
            {"entity_id": "e-high", "vulnerability_score": 80.0},
            {"entity_id": "e-mid", "vulnerability_score": 50.0},
        ]
        rankings = engine.rank_entities(entity_scores)
        assert len(rankings) == 3
        assert rankings[0]["entity_id"] == "e-high"
        assert rankings[0]["rank"] == 1
        assert rankings[1]["entity_id"] == "e-mid"
        assert rankings[1]["rank"] == 2
        assert rankings[2]["entity_id"] == "e-low"
        assert rankings[2]["rank"] == 3

    def test_percentile_values(self, engine):
        """Percentile values are computed correctly."""
        entity_scores = [
            {"entity_id": "a", "vulnerability_score": 90.0},
            {"entity_id": "b", "vulnerability_score": 10.0},
        ]
        rankings = engine.rank_entities(entity_scores)
        assert rankings[0]["percentile"] == 100.0
        assert rankings[1]["percentile"] == 50.0

    def test_single_entity(self, engine):
        """Single entity gets rank 1 and 100th percentile."""
        entity_scores = [
            {"entity_id": "only", "vulnerability_score": 50.0},
        ]
        rankings = engine.rank_entities(entity_scores)
        assert len(rankings) == 1
        assert rankings[0]["rank"] == 1
        assert rankings[0]["percentile"] == 100.0

    def test_empty_list_raises(self, engine):
        """Empty entity scores list raises ValueError."""
        with pytest.raises(ValueError, match="must not be empty"):
            engine.rank_entities([])

    def test_non_list_raises(self, engine):
        """Non-list entity scores raises TypeError."""
        with pytest.raises(TypeError, match="must be a list"):
            engine.rank_entities("not_a_list")

    def test_vulnerability_levels_assigned(self, engine):
        """Each ranked entity has a vulnerability level."""
        entity_scores = [
            {"entity_id": "a", "vulnerability_score": 90.0},
            {"entity_id": "b", "vulnerability_score": 30.0},
        ]
        rankings = engine.rank_entities(entity_scores)
        assert rankings[0]["vulnerability_level"] == "critical"
        assert rankings[1]["vulnerability_level"] == "low"

    def test_ranking_counter_incremented(self, engine):
        """Ranking counter is incremented."""
        engine.rank_entities([
            {"entity_id": "a", "vulnerability_score": 50.0},
        ])
        stats = engine.get_statistics()
        assert stats["total_rankings"] == 1


# ===================================================================
# get_vulnerability_score tests
# ===================================================================


class TestGetVulnerabilityScore:
    """Tests for get_vulnerability_score."""

    def test_existing_score(self, engine, scored_entity):
        """Existing score is retrieved."""
        result = engine.get_vulnerability_score(scored_entity["score_id"])
        assert result is not None
        assert result["score_id"] == scored_entity["score_id"]

    def test_non_existent_score(self, engine):
        """Non-existent score returns None."""
        assert engine.get_vulnerability_score("DOES_NOT_EXIST") is None

    def test_empty_id(self, engine):
        """Empty score_id returns None."""
        assert engine.get_vulnerability_score("") is None


# ===================================================================
# list_vulnerability_scores tests
# ===================================================================


class TestListVulnerabilityScores:
    """Tests for list_vulnerability_scores."""

    def test_list_all(self, engine, scored_entity):
        """list_vulnerability_scores returns stored scores."""
        result = engine.list_vulnerability_scores()
        assert len(result) >= 1

    def test_filter_by_entity(self, engine, sensitivity_factors, adaptive_capacity):
        """Filter by entity_id works."""
        engine.score_vulnerability("e1", "flood", 50.0, sensitivity_factors, adaptive_capacity)
        engine.score_vulnerability("e2", "flood", 50.0, sensitivity_factors, adaptive_capacity)
        result = engine.list_vulnerability_scores(entity_id="e1")
        assert all(r["entity_id"] == "e1" for r in result)

    def test_filter_by_hazard(self, engine, sensitivity_factors, adaptive_capacity):
        """Filter by hazard_type works."""
        engine.score_vulnerability("e1", "flood", 50.0, sensitivity_factors, adaptive_capacity)
        engine.score_vulnerability("e2", "drought", 50.0, sensitivity_factors, adaptive_capacity)
        result = engine.list_vulnerability_scores(hazard_type="flood")
        assert all(r["hazard_type"] == "flood" for r in result)

    def test_filter_by_level(self, engine, sensitivity_factors, adaptive_capacity):
        """Filter by vulnerability_level works."""
        engine.score_vulnerability("e1", "flood", 90.0, sensitivity_factors, adaptive_capacity)
        engine.score_vulnerability("e2", "flood", 10.0, sensitivity_factors, adaptive_capacity)
        result = engine.list_vulnerability_scores(vulnerability_level="negligible")
        assert all(r["vulnerability_level"] == "negligible" for r in result)

    def test_limit_respected(self, engine, sensitivity_factors, adaptive_capacity):
        """Limit parameter is respected."""
        for i in range(5):
            engine.score_vulnerability(f"e{i}", "flood", 50.0, sensitivity_factors, adaptive_capacity)
        result = engine.list_vulnerability_scores(limit=3)
        assert len(result) == 3


# ===================================================================
# get_statistics tests
# ===================================================================


class TestGetStatistics:
    """Tests for get_statistics."""

    def test_initial_stats(self, engine):
        """Initial stats are all zeros."""
        stats = engine.get_statistics()
        assert stats["total_scores"] == 0
        assert stats["total_profiles"] == 0
        assert stats["total_residual_calcs"] == 0
        assert stats["total_rankings"] == 0
        assert stats["total_errors"] == 0
        assert stats["stored_scores"] == 0

    def test_stats_weights(self, engine):
        """Stats include config weights."""
        stats = engine.get_statistics()
        weights = stats["config_weights"]
        assert "exposure" in weights
        assert "sensitivity" in weights
        assert "adaptive_capacity" in weights

    def test_stats_level_distribution(self, engine, sensitivity_factors, adaptive_capacity):
        """Stats include vulnerability level distribution."""
        engine.score_vulnerability("e1", "flood", 90.0, sensitivity_factors, adaptive_capacity)
        engine.score_vulnerability("e2", "flood", 10.0, sensitivity_factors, adaptive_capacity)
        stats = engine.get_statistics()
        dist = stats["vulnerability_level_distribution"]
        total = sum(dist.values())
        assert total == 2


# ===================================================================
# clear tests
# ===================================================================


class TestClear:
    """Tests for clear."""

    def test_clear_resets_all(self, engine, scored_entity):
        """clear removes all stored state."""
        engine.create_sensitivity_profile("e-001", "agriculture", {"a": 0.5})
        engine.create_adaptive_capacity_profile("e-001", {"b": 0.5})
        engine.calculate_residual_risk(80.0, [{"measure_name": "a", "effectiveness": 0.5}])

        engine.clear()

        stats = engine.get_statistics()
        assert stats["total_scores"] == 0
        assert stats["total_profiles"] == 0
        assert stats["total_residual_calcs"] == 0
        assert stats["total_errors"] == 0
        assert stats["stored_scores"] == 0
        assert stats["stored_sensitivity_profiles"] == 0
        assert stats["stored_adaptive_profiles"] == 0
        assert stats["stored_residual_results"] == 0

    def test_clear_idempotent(self, engine):
        """Clearing empty engine is safe."""
        engine.clear()
        stats = engine.get_statistics()
        assert stats["total_scores"] == 0


# ===================================================================
# Additional public helper tests
# ===================================================================


class TestPublicHelpers:
    """Tests for additional public helper methods."""

    def test_get_sector_sensitivity_defaults(self, engine):
        """Returns default sensitivity factors for sector."""
        factors = engine.get_sector_sensitivity_defaults("agriculture")
        assert len(factors) == 5
        assert all(v == 0.5 for v in factors.values())

    def test_get_sector_sensitivity_unknown(self, engine):
        """Unknown sector returns empty dict."""
        factors = engine.get_sector_sensitivity_defaults("unknown_sector")
        assert factors == {}

    def test_get_adaptive_capacity_defaults(self, engine):
        """Returns default adaptive capacity indicators."""
        indicators = engine.get_adaptive_capacity_defaults()
        assert len(indicators) == 10
        assert all(v == 0.5 for v in indicators.values())

    def test_get_supported_sectors(self, engine):
        """Returns sorted list of sectors."""
        sectors = engine.get_supported_sectors()
        assert len(sectors) == 8
        assert sectors == sorted(sectors)
        assert "agriculture" in sectors
        assert "financial" in sectors

    def test_get_supported_hazard_types(self, engine):
        """Returns sorted list of hazard types."""
        types = engine.get_supported_hazard_types()
        assert len(types) == 13
        assert types == sorted(types)
        assert "flood" in types
        assert "drought" in types

    def test_get_vulnerability_levels(self, engine):
        """Returns all 5 vulnerability level descriptions."""
        levels = engine.get_vulnerability_levels()
        assert len(levels) == 5
        level_names = [l["level"] for l in levels]
        assert "negligible" in level_names
        assert "critical" in level_names


# ===================================================================
# Constants validation tests
# ===================================================================


class TestConstants:
    """Tests for module-level constant integrity."""

    def test_sector_sensitivity_all_have_5_factors(self):
        """Each sector has exactly 5 sensitivity factors."""
        for sector, factors in SECTOR_SENSITIVITY_FACTORS.items():
            assert len(factors) == 5, f"Sector {sector} has {len(factors)} factors"

    def test_sector_sensitivity_all_default_05(self):
        """All sector sensitivity defaults are 0.5."""
        for sector, factors in SECTOR_SENSITIVITY_FACTORS.items():
            for name, val in factors.items():
                assert val == 0.5, f"{sector}.{name} is {val}, expected 0.5"

    def test_adaptive_capacity_all_default_05(self):
        """All adaptive capacity defaults are 0.5."""
        for name, val in DEFAULT_ADAPTIVE_CAPACITY_INDICATORS.items():
            assert val == 0.5, f"Indicator {name} is {val}, expected 0.5"

    def test_hazard_sector_multipliers_coverage(self):
        """All hazard types have sector multipliers."""
        for ht in VALID_HAZARD_TYPES:
            assert ht in HAZARD_SECTOR_MULTIPLIERS, f"Missing multipliers for {ht}"

    def test_scenario_multipliers(self):
        """Scenario multipliers exist for key scenarios."""
        assert "SSP2-4.5" in SCENARIO_MULTIPLIERS
        assert SCENARIO_MULTIPLIERS["SSP2-4.5"] == 1.0
        assert SCENARIO_MULTIPLIERS["SSP5-8.5"] > 1.0
        assert SCENARIO_MULTIPLIERS["SSP1-1.9"] < 1.0

    def test_time_horizon_multipliers(self):
        """Time horizon multipliers exist."""
        assert "MID_TERM" in TIME_HORIZON_MULTIPLIERS
        assert TIME_HORIZON_MULTIPLIERS["MID_TERM"] == 1.0
        assert TIME_HORIZON_MULTIPLIERS["LONG_TERM"] > 1.0


# ===================================================================
# Thread safety tests
# ===================================================================


class TestThreadSafety:
    """Tests for thread safety."""

    def test_concurrent_scoring(self, engine, sensitivity_factors, adaptive_capacity):
        """Concurrent scoring operations are thread safe."""
        errors = []

        def score(i):
            try:
                engine.score_vulnerability(
                    entity_id=f"thread-{i}",
                    hazard_type="flood",
                    exposure_score=50.0,
                    sensitivity_factors=sensitivity_factors,
                    adaptive_capacity_indicators=adaptive_capacity,
                )
            except Exception as exc:
                errors.append(str(exc))

        threads = [threading.Thread(target=score, args=(i,)) for i in range(20)]
        for t in threads:
            t.start()
        for t in threads:
            t.join(timeout=10.0)

        assert len(errors) == 0
        stats = engine.get_statistics()
        assert stats["total_scores"] == 20

    def test_concurrent_residual_risk(self, engine):
        """Concurrent residual risk calculations are safe."""
        errors = []

        def calc(i):
            try:
                engine.calculate_residual_risk(
                    vulnerability_score=80.0,
                    adaptation_measures=[
                        {"measure_name": f"m-{i}", "effectiveness": 0.5},
                    ],
                    entity_id=f"entity-{i}",
                )
            except Exception as exc:
                errors.append(str(exc))

        threads = [threading.Thread(target=calc, args=(i,)) for i in range(20)]
        for t in threads:
            t.start()
        for t in threads:
            t.join(timeout=10.0)

        assert len(errors) == 0
        stats = engine.get_statistics()
        assert stats["total_residual_calcs"] == 20


# ===================================================================
# Provenance tracking tests
# ===================================================================


class TestProvenanceTracking:
    """Tests for provenance hash generation and tracking."""

    def test_score_provenance_hash(self, scored_entity):
        """Score result includes 64-char SHA-256 provenance hash."""
        assert len(scored_entity["provenance_hash"]) == 64

    def test_provenance_entries_tracked(self, engine, scored_entity):
        """Provenance entries are counted in statistics."""
        stats = engine.get_statistics()
        assert stats["provenance_entries"] >= 1

    def test_provenance_reset_on_clear(self, engine, scored_entity):
        """Provenance counter resets on clear."""
        engine.clear()
        stats = engine.get_statistics()
        assert stats["provenance_entries"] == 0

    def test_residual_risk_provenance(self, engine):
        """Residual risk result includes provenance hash."""
        result = engine.calculate_residual_risk(
            vulnerability_score=80.0,
            adaptation_measures=[{"measure_name": "a", "effectiveness": 0.5}],
        )
        assert len(result["provenance_hash"]) == 64

    def test_sensitivity_profile_provenance(self, engine):
        """Sensitivity profile includes provenance hash."""
        result = engine.create_sensitivity_profile(
            "e-001", "agriculture", {"a": 0.5}
        )
        assert len(result["provenance_hash"]) == 64

    def test_adaptive_profile_provenance(self, engine):
        """Adaptive capacity profile includes provenance hash."""
        result = engine.create_adaptive_capacity_profile(
            "e-001", {"a": 0.5}
        )
        assert len(result["provenance_hash"]) == 64
